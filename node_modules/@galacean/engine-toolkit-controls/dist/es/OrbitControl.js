import { _ as _create_class } from './_create_class-8d4b456b.js';
import { _ as _inherits } from './_inherits-5a51c3d0.js';
import { Camera, Vector3, Script } from '@galacean/engine';
import { ControlHandlerType } from './enums/ControlHandlerType.js';
import { ControlKeyboard } from './inputDevice/ControlKeyboard.js';
import { ControlPointer } from './inputDevice/ControlPointer.js';
import { ControlWheel } from './inputDevice/ControlWheel.js';
import { Spherical } from './Spherical.js';
import './inputDevice/StaticInterfaceImplement.js';
import './tslib.es6-2e0713a3.js';

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */ var OrbitControl = /*#__PURE__*/ function(Script) {
    _inherits(OrbitControl, Script);
    function OrbitControl() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this.inputDevices = [
            ControlKeyboard,
            ControlPointer,
            ControlWheel
        ];
        /** Whether to automatically rotate the camera, the default is false. */ _this.autoRotate = false;
        /** The radian of automatic rotation per second. */ _this.autoRotateSpeed = Math.PI;
        /** Whether to enable camera damping, the default is true. */ _this.enableDamping = true;
        /** Rotation speed, default is 1.0 . */ _this.rotateSpeed = 1.0;
        /** Camera zoom speed, the default is 1.0. */ _this.zoomSpeed = 1.0;
        /** Keyboard translation speed, the default is 7.0 . */ _this.keyPanSpeed = 7.0;
        /** Rotation damping parameter, default is 0.1 . */ _this.dampingFactor = 0.1;
        /** Zoom damping parameter, default is 0.2 . */ _this.zoomFactor = 0.2;
        /**  The minimum distance, the default is 0.1, should be greater than 0. */ _this.minDistance = 0.1;
        /** The maximum distance, the default is infinite, should be greater than the minimum distance. */ _this.maxDistance = Infinity;
        /** Minimum zoom speed, the default is 0.0. */ _this.minZoom = 0.0;
        /** Maximum zoom speed, the default is positive infinity. */ _this.maxZoom = Infinity;
        /** The minimum radian in the vertical direction, the default is 1 degree. */ _this.minPolarAngle = 1;
        /** The maximum radian in the vertical direction,  the default is 179 degree.  */ _this.maxPolarAngle = 179 / 180 * Math.PI;
        /** The minimum radian in the horizontal direction, the default is negative infinity. */ _this.minAzimuthAngle = -Infinity;
        /** The maximum radian in the horizontal direction, the default is positive infinity.  */ _this.maxAzimuthAngle = Infinity;
        _this._enableKeys = true;
        _this._up = new Vector3(0, 1, 0);
        _this._target = new Vector3();
        _this._atTheBack = false;
        _this._spherical = new Spherical();
        _this._sphericalDelta = new Spherical();
        _this._sphericalDump = new Spherical();
        _this._zoomFrag = 0;
        _this._scale = 1;
        _this._panOffset = new Vector3();
        _this._tempVec3 = new Vector3();
        _this._enableHandler = ControlHandlerType.All;
        return _this;
    }
    var _proto = OrbitControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine = _this.engine, entity = _this.entity;
        this.canvas = engine.canvas;
        this.input = engine.inputManager;
        this.camera = entity.getComponent(Camera);
        this.cameraTransform = entity.transform;
        this._spherical.setYAxis(this._up);
        this._atTheBack = false;
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
        /** Update this._sphericalDelta, this._scale and this._panOffset. */ this._updateInputDelta(deltaTime);
        /** Update camera's transform. */ this._updateTransform();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
        var curHandlerType = ControlHandlerType.None;
        var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType & enableHandler) {
                curHandlerType |= handlerType;
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case ControlHandlerType.ROTATE:
                        this._rotate(delta);
                        break;
                    case ControlHandlerType.ZOOM:
                        this._zoom(delta);
                        break;
                    case ControlHandlerType.PAN:
                        this._pan(delta);
                        break;
                }
            }
        }
        var _this2 = this, _sphericalDump = _this2._sphericalDump, _sphericalDelta = _this2._sphericalDelta;
        if (this.enableDamping) {
            if (enableHandler & ControlHandlerType.ZOOM && curHandlerType ^ ControlHandlerType.ZOOM) {
                this._zoomFrag *= 1 - this.zoomFactor;
            }
            if (enableHandler & ControlHandlerType.ROTATE && curHandlerType ^ ControlHandlerType.ROTATE) {
                _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
                _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
            }
        }
        if (curHandlerType === ControlHandlerType.None && this.autoRotate) {
            var rotateAngle = this.autoRotateSpeed / 1000 * deltaTime;
            _sphericalDelta.theta -= rotateAngle;
        }
    };
    _proto._rotate = function _rotate(delta) {
        var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
        this._sphericalDelta.theta -= radianLeft;
        var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
        this._sphericalDelta.phi -= radianUp;
        if (this.enableDamping) {
            this._sphericalDump.theta = -radianLeft;
            this._sphericalDump.phi = -radianUp;
        }
    };
    _proto._zoom = function _zoom(delta) {
        if (delta.y > 0) {
            this._scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (delta.y < 0) {
            this._scale *= Math.pow(0.95, this.zoomSpeed);
        }
    };
    _proto._pan = function _pan(delta) {
        var cameraTransform = this.cameraTransform;
        var elements = cameraTransform.worldMatrix.elements;
        var height = this.canvas.height;
        var targetDistance = Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
        var distanceLeft = -2 * delta.x * (targetDistance / height);
        var distanceUp = 2 * delta.y * (targetDistance / height);
        this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
        this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
        this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
    };
    _proto._updateTransform = function _updateTransform() {
        var _this = this, cameraTransform = _this.cameraTransform, target = _this.target, _tempVec3 = _this._tempVec3, _spherical = _this._spherical, _sphericalDelta = _this._sphericalDelta, _panOffset = _this._panOffset;
        _tempVec3.copyFrom(cameraTransform.worldUp);
        this._atTheBack = _tempVec3.y <= 0;
        Vector3.subtract(cameraTransform.position, target, _tempVec3);
        _spherical.setFromVec3(_tempVec3, this._atTheBack);
        _spherical.theta += _sphericalDelta.theta;
        _spherical.phi += _sphericalDelta.phi;
        _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
        _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
        _spherical.makeSafe();
        if (this._scale !== 1) {
            this._zoomFrag = _spherical.radius * (this._scale - 1);
        }
        _spherical.radius += this._zoomFrag;
        _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
        this._atTheBack = _spherical.setToVec3(_tempVec3);
        Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.worldPosition);
        cameraTransform.lookAt(target, _tempVec3.copyFrom(this.up).scale(this._atTheBack ? -1 : 1));
        /** Reset cache value. */ this._zoomFrag = 0;
        this._scale = 1;
        _sphericalDelta.set(0, 0, 0);
        _panOffset.set(0, 0, 0);
    };
    _create_class(OrbitControl, [
        {
            key: "enableKeys",
            get: /**
   * Return whether to enable keyboard.
   */ function get() {
                return this._enableKeys;
            },
            set: function set(value) {
                if (this._enableKeys !== value) {
                    this._enableKeys = value;
                    var inputDevices = this.inputDevices;
                    if (value) {
                        inputDevices.push(ControlKeyboard);
                    } else {
                        for(var i = inputDevices.length - 1; i >= 0; i--){
                            if (inputDevices[i] === ControlKeyboard) {
                                inputDevices.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "up",
            get: /*
   * Return up vector.
   */ function get() {
                return this._up;
            },
            set: function set(value) {
                this._up.copyFrom(value);
                this._spherical.setYAxis(value);
                this._atTheBack = false;
            }
        },
        {
            key: "target",
            get: /**
   * Return target position.
   * */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
                this._atTheBack = false;
            }
        },
        {
            key: "enableRotate",
            get: /**
   *  Return Whether to enable rotation, the default is true.
   */ function get() {
                return (this._enableHandler & ControlHandlerType.ROTATE) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= ControlHandlerType.ROTATE;
                } else {
                    this._enableHandler &= ~ControlHandlerType.ROTATE;
                }
            }
        },
        {
            key: "enableZoom",
            get: /**
   *  Whether to enable camera damping, the default is true.
   */ function get() {
                return (this._enableHandler & ControlHandlerType.ZOOM) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= ControlHandlerType.ZOOM;
                } else {
                    this._enableHandler &= ~ControlHandlerType.ZOOM;
                }
            }
        },
        {
            key: "enablePan",
            get: /**
   *  Whether to enable translation, the default is true.
   */ function get() {
                return (this._enableHandler & ControlHandlerType.PAN) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= ControlHandlerType.PAN;
                } else {
                    this._enableHandler &= ~ControlHandlerType.PAN;
                }
            }
        }
    ]);
    return OrbitControl;
}(Script);

export { OrbitControl };
//# sourceMappingURL=OrbitControl.js.map

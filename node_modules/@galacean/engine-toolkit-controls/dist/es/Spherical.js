import { MathUtil, Vector3, Matrix } from '@galacean/engine';

// Prevent gimbal lock.
var ESP = MathUtil.zeroTolerance;
// Spherical.
var Spherical = /*#__PURE__*/ function() {
    function Spherical(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        this._matrix = new Matrix();
        this._matrixInv = new Matrix();
        this.radius = radius !== undefined ? radius : 1.0;
        this.phi = phi !== undefined ? phi : 0;
        this.theta = theta !== undefined ? theta : 0;
    }
    var _proto = Spherical.prototype;
    _proto.makeSafe = function makeSafe() {
        var count = Math.floor(this.phi / Math.PI);
        this.phi = MathUtil.clamp(this.phi, count * Math.PI + ESP, (count + 1) * Math.PI - ESP);
        return this;
    };
    _proto.set = function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    };
    _proto.setYAxis = function setYAxis(up) {
        var xAxis = Spherical._xAxis, yAxis = Spherical._yAxis, zAxis = Spherical._zAxis;
        if (Vector3.equals(xAxis.set(1, 0, 0), yAxis.copyFrom(up).normalize())) {
            xAxis.set(0, 1, 0);
        }
        Vector3.cross(xAxis, yAxis, zAxis);
        zAxis.normalize();
        Vector3.cross(yAxis, zAxis, xAxis);
        var _this__matrix = this._matrix, es = _this__matrix.elements;
        es[0] = xAxis.x, es[1] = xAxis.y, es[2] = xAxis.z;
        es[4] = yAxis.x, es[5] = yAxis.y, es[6] = yAxis.z;
        es[8] = zAxis.x, es[9] = zAxis.y, es[10] = zAxis.z;
        var _this__matrixInv = this._matrixInv, eInv = _this__matrixInv.elements;
        eInv[0] = xAxis.x, eInv[4] = xAxis.y, eInv[8] = xAxis.z;
        eInv[1] = yAxis.x, eInv[5] = yAxis.y, eInv[9] = yAxis.z;
        eInv[2] = zAxis.x, eInv[6] = zAxis.y, eInv[10] = zAxis.z;
    };
    _proto.setFromVec3 = function setFromVec3(value, atTheBack) {
        if (atTheBack === void 0) atTheBack = false;
        value.transformNormal(this._matrixInv);
        this.radius = value.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            if (atTheBack) {
                this.phi = 2 * Math.PI - Math.acos(MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(-value.x, -value.z);
            } else {
                this.phi = Math.acos(MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(value.x, value.z);
            }
        }
        return this;
    };
    _proto.setToVec3 = function setToVec3(value) {
        var _this = this, radius = _this.radius, phi = _this.phi, theta = _this.theta;
        var sinPhiRadius = Math.sin(phi) * radius;
        this.phi -= Math.floor(this.phi / Math.PI / 2) * Math.PI * 2;
        value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
        value.transformNormal(this._matrix);
        return this.phi > Math.PI;
    };
    return Spherical;
}();
(function() {
    Spherical._xAxis = new Vector3();
})();
(function() {
    Spherical._yAxis = new Vector3();
})();
(function() {
    Spherical._zAxis = new Vector3();
})();

export { Spherical };
//# sourceMappingURL=Spherical.js.map

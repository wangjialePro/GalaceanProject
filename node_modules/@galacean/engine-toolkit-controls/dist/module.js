import { Keys, PointerButton, MathUtil, Vector3, Matrix, Script, Vector2, Camera } from '@galacean/engine';

let ControlHandlerType = /*#__PURE__*/function (ControlHandlerType) {
  ControlHandlerType[ControlHandlerType["None"] = 0] = "None";
  ControlHandlerType[ControlHandlerType["ROTATE"] = 1] = "ROTATE";
  ControlHandlerType[ControlHandlerType["ZOOM"] = 2] = "ZOOM";
  ControlHandlerType[ControlHandlerType["PAN"] = 4] = "PAN";
  ControlHandlerType[ControlHandlerType["All"] = 7] = "All";
  return ControlHandlerType;
}({});

/**
 *  Static interface implement decorator.
 *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
 */
function StaticInterfaceImplement() {
  return constructor => {
  };
}

var _dec$4, _class$4;
let ControlFreeKeyboard = (_dec$4 = StaticInterfaceImplement(), _dec$4(_class$4 = class ControlFreeKeyboard {
  static onUpdateHandler(input) {
    if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.KeyA) || input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.KeyW) || input.isKeyHeldDown(Keys.ArrowDown) || input.isKeyHeldDown(Keys.KeyS) || input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.KeyD)) {
      return ControlHandlerType.PAN;
    } else {
      return ControlHandlerType.None;
    }
  }
  static onUpdateDelta(control, outDelta) {
    const {
      movementSpeed,
      input
    } = control;
    outDelta.x = outDelta.y = outDelta.z = 0;
    if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.KeyA)) {
      outDelta.x -= movementSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.KeyD)) {
      outDelta.x += movementSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.KeyW)) {
      outDelta.z -= movementSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowDown) || input.isKeyHeldDown(Keys.KeyS)) {
      outDelta.z += movementSpeed;
    }
  }
}) || _class$4);

var _dec$3, _class$3, _class2$1;
var DeltaType$1 = /*#__PURE__*/function (DeltaType) {
  DeltaType[DeltaType["Moving"] = 0] = "Moving";
  DeltaType[DeltaType["Distance"] = 1] = "Distance";
  DeltaType[DeltaType["None"] = 2] = "None";
  return DeltaType;
}(DeltaType$1 || {});
let ControlFreePointer = (_dec$3 = StaticInterfaceImplement(), _dec$3(_class$3 = (_class2$1 = class ControlFreePointer {
  static onUpdateHandler(input) {
    ++this._frameIndex;
    if (input.pointers.length === 1) {
      if (input.isPointerHeldDown(PointerButton.Primary)) {
        this._updateType(ControlHandlerType.ROTATE, DeltaType$1.Moving);
      } else {
        const {
          deltaPosition
        } = input.pointers[0];
        if ((deltaPosition.x !== 0 || deltaPosition.y !== 0) && input.isPointerUp(PointerButton.Primary)) {
          this._updateType(ControlHandlerType.ROTATE, DeltaType$1.Moving);
        } else {
          this._updateType(ControlHandlerType.None, DeltaType$1.None);
        }
      }
    } else {
      this._updateType(ControlHandlerType.None, DeltaType$1.None);
    }
    return this._handlerType;
  }
  static onUpdateDelta(control, outDelta) {
    const {
      _frameIndex: frameIndex
    } = this;
    switch (this._deltaType) {
      case DeltaType$1.Moving:
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          const {
            deltaPosition
          } = control.input.pointers[0];
          outDelta.x = deltaPosition.x;
          outDelta.y = deltaPosition.y;
        } else {
          outDelta.x = 0;
          outDelta.y = 0;
        }
        break;
    }
    this._lastUsefulFrameIndex = frameIndex;
  }
  static _updateType(handlerType, deltaType) {
    if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
      this._handlerType = handlerType;
      this._deltaType = deltaType;
      this._lastUsefulFrameIndex = -1;
    }
  }
}, _class2$1._deltaType = DeltaType$1.Moving, _class2$1._handlerType = ControlHandlerType.None, _class2$1._frameIndex = 0, _class2$1._lastUsefulFrameIndex = -1, _class2$1)) || _class$3);

// Prevent gimbal lock.
const ESP = MathUtil.zeroTolerance;
// Spherical.
class Spherical {
  constructor(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    this._matrix = new Matrix();
    this._matrixInv = new Matrix();
    this.radius = radius !== undefined ? radius : 1.0;
    this.phi = phi !== undefined ? phi : 0;
    this.theta = theta !== undefined ? theta : 0;
  }
  makeSafe() {
    const count = Math.floor(this.phi / Math.PI);
    this.phi = MathUtil.clamp(this.phi, count * Math.PI + ESP, (count + 1) * Math.PI - ESP);
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  setYAxis(up) {
    const {
      _xAxis: xAxis,
      _yAxis: yAxis,
      _zAxis: zAxis
    } = Spherical;
    if (Vector3.equals(xAxis.set(1, 0, 0), yAxis.copyFrom(up).normalize())) {
      xAxis.set(0, 1, 0);
    }
    Vector3.cross(xAxis, yAxis, zAxis);
    zAxis.normalize();
    Vector3.cross(yAxis, zAxis, xAxis);
    const {
      elements: es
    } = this._matrix;
    es[0] = xAxis.x, es[1] = xAxis.y, es[2] = xAxis.z;
    es[4] = yAxis.x, es[5] = yAxis.y, es[6] = yAxis.z;
    es[8] = zAxis.x, es[9] = zAxis.y, es[10] = zAxis.z;
    const {
      elements: eInv
    } = this._matrixInv;
    eInv[0] = xAxis.x, eInv[4] = xAxis.y, eInv[8] = xAxis.z;
    eInv[1] = yAxis.x, eInv[5] = yAxis.y, eInv[9] = yAxis.z;
    eInv[2] = zAxis.x, eInv[6] = zAxis.y, eInv[10] = zAxis.z;
  }
  setFromVec3(value, atTheBack = false) {
    value.transformNormal(this._matrixInv);
    this.radius = value.length();
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      if (atTheBack) {
        this.phi = 2 * Math.PI - Math.acos(MathUtil.clamp(value.y / this.radius, -1, 1));
        this.theta = Math.atan2(-value.x, -value.z);
      } else {
        this.phi = Math.acos(MathUtil.clamp(value.y / this.radius, -1, 1));
        this.theta = Math.atan2(value.x, value.z);
      }
    }
    return this;
  }
  setToVec3(value) {
    const {
      radius,
      phi,
      theta
    } = this;
    const sinPhiRadius = Math.sin(phi) * radius;
    this.phi -= Math.floor(this.phi / Math.PI / 2) * Math.PI * 2;
    value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
    value.transformNormal(this._matrix);
    return this.phi > Math.PI;
  }
}
Spherical._xAxis = new Vector3();
Spherical._yAxis = new Vector3();
Spherical._zAxis = new Vector3();

/**
 * The camera's roaming controller, can move up and down, left and right, and rotate the viewing angle.
 */
class FreeControl extends Script {
  constructor(entity) {
    super(entity);
    this.input = void 0;
    this.inputDevices = [ControlFreeKeyboard, ControlFreePointer];
    /** Movement distance per second, the unit is the unit before MVP conversion. */
    this.movementSpeed = 1.0;
    /** Rotate speed. */
    this.rotateSpeed = 1.0;
    /** Simulate a ground. */
    this.floorMock = true;
    /** Simulated ground height. */
    this.floorY = 0;
    this._cameraTransform = void 0;
    this._spherical = new Spherical();
    this._tempVec = new Vector3();
    this.input = this.engine.inputManager;
    const transform = this._cameraTransform = entity.transform;
    /** Init spherical. */
    const {
      _tempVec: tempVec,
      _spherical: spherical
    } = this;
    Vector3.transformByQuat(tempVec.set(0, 0, -1), transform.rotationQuaternion, tempVec);
    spherical.setFromVec3(tempVec);
  }
  onUpdate(deltaTime) {
    if (this.enabled === false) return;
    ControlHandlerType.None;
    const {
      _tempVec: delta
    } = this;
    const {
      inputDevices,
      input
    } = this;
    for (let i = inputDevices.length - 1; i >= 0; i--) {
      const handler = inputDevices[i];
      const handlerType = handler.onUpdateHandler(input);
      if (handlerType) {
        handler.onUpdateDelta(this, delta);
        switch (handlerType) {
          case ControlHandlerType.ROTATE:
            this._rotate(delta);
            break;
          case ControlHandlerType.PAN:
            this._pan(delta, deltaTime);
            break;
        }
      }
    }
    if (this.floorMock) {
      const position = this._cameraTransform.position;
      if (position.y !== this.floorY) {
        this._cameraTransform.setPosition(position.x, this.floorY, position.z);
      }
    }
  }
  _pan(moveDelta, delta) {
    const actualMoveSpeed = delta / 1000 * this.movementSpeed;
    moveDelta.normalize().scale(actualMoveSpeed);
    this._cameraTransform.translate(moveDelta, true);
  }
  _rotate(moveDelta) {
    if (moveDelta.x !== 0 || moveDelta.y !== 0) {
      const canvas = this.engine.canvas;
      const deltaAlpha = -moveDelta.x * 180 / canvas.width;
      const deltaPhi = moveDelta.y * 180 / canvas.height;
      this._spherical.theta += MathUtil.degreeToRadian(deltaAlpha);
      this._spherical.phi += MathUtil.degreeToRadian(deltaPhi);
      this._spherical.makeSafe();
      this._spherical.setToVec3(this._tempVec);
      Vector3.add(this._cameraTransform.position, this._tempVec, this._tempVec);
      this._cameraTransform.lookAt(this._tempVec, new Vector3(0, 1, 0));
    }
  }
}

var _dec$2, _class$2;
let ControlKeyboard = (_dec$2 = StaticInterfaceImplement(), _dec$2(_class$2 = class ControlKeyboard {
  static onUpdateHandler(input) {
    if (input.isKeyHeldDown(Keys.ArrowLeft) || input.isKeyHeldDown(Keys.ArrowRight) || input.isKeyHeldDown(Keys.ArrowUp) || input.isKeyHeldDown(Keys.ArrowDown)) {
      return ControlHandlerType.PAN;
    } else {
      return ControlHandlerType.None;
    }
  }
  static onUpdateDelta(control, outDelta) {
    const {
      keyPanSpeed,
      input
    } = control;
    outDelta.x = outDelta.y = 0;
    if (input.isKeyHeldDown(Keys.ArrowLeft)) {
      outDelta.x += keyPanSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowRight)) {
      outDelta.x -= keyPanSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowUp)) {
      outDelta.y += keyPanSpeed;
    }
    if (input.isKeyHeldDown(Keys.ArrowDown)) {
      outDelta.y -= keyPanSpeed;
    }
  }
}) || _class$2);

var _dec$1, _class$1, _class2;
var DeltaType = /*#__PURE__*/function (DeltaType) {
  DeltaType[DeltaType["Moving"] = 0] = "Moving";
  DeltaType[DeltaType["Distance"] = 1] = "Distance";
  DeltaType[DeltaType["None"] = 2] = "None";
  return DeltaType;
}(DeltaType || {});
let ControlPointer = (_dec$1 = StaticInterfaceImplement(), _dec$1(_class$1 = (_class2 = class ControlPointer {
  static onUpdateHandler(input) {
    ++this._frameIndex;
    const {
      pointers
    } = input;
    switch (pointers.length) {
      case 1:
        if (input.isPointerHeldDown(PointerButton.Secondary)) {
          this._updateType(ControlHandlerType.PAN, DeltaType.Moving);
        } else if (input.isPointerHeldDown(PointerButton.Auxiliary)) {
          this._updateType(ControlHandlerType.ZOOM, DeltaType.Moving);
        } else if (input.isPointerHeldDown(PointerButton.Primary)) {
          this._updateType(ControlHandlerType.ROTATE, DeltaType.Moving);
        } else {
          // When `onPointerMove` happens on the same frame as `onPointerUp`
          // Need to record the movement of this frame
          const {
            deltaPosition
          } = input.pointers[0];
          if (deltaPosition.x !== 0 && deltaPosition.y !== 0) {
            if (input.isPointerUp(PointerButton.Secondary)) {
              this._updateType(ControlHandlerType.PAN, DeltaType.Moving);
            } else if (input.isPointerUp(PointerButton.Auxiliary)) {
              this._updateType(ControlHandlerType.ZOOM, DeltaType.Moving);
            } else if (input.isPointerUp(PointerButton.Primary)) {
              this._updateType(ControlHandlerType.ROTATE, DeltaType.Moving);
            } else {
              this._updateType(ControlHandlerType.None, DeltaType.None);
            }
          } else {
            this._updateType(ControlHandlerType.None, DeltaType.None);
          }
        }
        break;
      case 2:
        this._updateType(ControlHandlerType.ZOOM, DeltaType.Distance);
        break;
      case 3:
        this._updateType(ControlHandlerType.PAN, DeltaType.Moving);
        break;
      default:
        this._updateType(ControlHandlerType.None, DeltaType.None);
        break;
    }
    return this._handlerType;
  }
  static onUpdateDelta(control, outDelta) {
    const {
      _frameIndex: frameIndex
    } = this;
    switch (this._deltaType) {
      case DeltaType.Moving:
        outDelta.x = 0;
        outDelta.y = 0;
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          const {
            pointers
          } = control.input;
          const length = pointers.length;
          for (let i = length - 1; i >= 0; i--) {
            const {
              deltaPosition
            } = pointers[i];
            outDelta.x += deltaPosition.x;
            outDelta.y += deltaPosition.y;
          }
          outDelta.x /= length;
          outDelta.y /= length;
        }
        break;
      case DeltaType.Distance:
        const {
          pointers
        } = control.input;
        const pointer1 = pointers[0];
        const pointer2 = pointers[1];
        const curDistance = Vector2.distance(pointer1.position, pointer2.position);
        if (this._lastUsefulFrameIndex === frameIndex - 1) {
          outDelta.set(0, this._distanceOfPointers - curDistance, 0);
        } else {
          outDelta.set(0, 0, 0);
        }
        this._distanceOfPointers = curDistance;
        break;
    }
    this._lastUsefulFrameIndex = frameIndex;
  }
  static _updateType(handlerType, deltaType) {
    if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
      this._handlerType = handlerType;
      this._deltaType = deltaType;
      this._lastUsefulFrameIndex = -1;
    }
  }
}, _class2._deltaType = DeltaType.None, _class2._handlerType = ControlHandlerType.None, _class2._frameIndex = 0, _class2._lastUsefulFrameIndex = -1, _class2._distanceOfPointers = 0, _class2)) || _class$1);

var _dec, _class;
let ControlWheel = (_dec = StaticInterfaceImplement(), _dec(_class = class ControlWheel {
  static onUpdateHandler(input) {
    const {
      wheelDelta
    } = input;
    if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
      return ControlHandlerType.None;
    } else {
      return ControlHandlerType.ZOOM;
    }
  }
  static onUpdateDelta(control, outDelta) {
    outDelta.copyFrom(control.input.wheelDelta);
  }
}) || _class);

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */
class OrbitControl extends Script {
  constructor(...args) {
    super(...args);
    this.canvas = void 0;
    this.input = void 0;
    this.inputDevices = [ControlKeyboard, ControlPointer, ControlWheel];
    this.camera = void 0;
    this.cameraTransform = void 0;
    /** Whether to automatically rotate the camera, the default is false. */
    this.autoRotate = false;
    /** The radian of automatic rotation per second. */
    this.autoRotateSpeed = Math.PI;
    /** Whether to enable camera damping, the default is true. */
    this.enableDamping = true;
    /** Rotation speed, default is 1.0 . */
    this.rotateSpeed = 1.0;
    /** Camera zoom speed, the default is 1.0. */
    this.zoomSpeed = 1.0;
    /** Keyboard translation speed, the default is 7.0 . */
    this.keyPanSpeed = 7.0;
    /** Rotation damping parameter, default is 0.1 . */
    this.dampingFactor = 0.1;
    /** Zoom damping parameter, default is 0.2 . */
    this.zoomFactor = 0.2;
    /**  The minimum distance, the default is 0.1, should be greater than 0. */
    this.minDistance = 0.1;
    /** The maximum distance, the default is infinite, should be greater than the minimum distance. */
    this.maxDistance = Infinity;
    /** Minimum zoom speed, the default is 0.0. */
    this.minZoom = 0.0;
    /** Maximum zoom speed, the default is positive infinity. */
    this.maxZoom = Infinity;
    /** The minimum radian in the vertical direction, the default is 1 degree. */
    this.minPolarAngle = 1;
    /** The maximum radian in the vertical direction,  the default is 179 degree.  */
    this.maxPolarAngle = 179 / 180 * Math.PI;
    /** The minimum radian in the horizontal direction, the default is negative infinity. */
    this.minAzimuthAngle = -Infinity;
    /** The maximum radian in the horizontal direction, the default is positive infinity.  */
    this.maxAzimuthAngle = Infinity;
    this._enableKeys = true;
    this._up = new Vector3(0, 1, 0);
    this._target = new Vector3();
    this._atTheBack = false;
    this._spherical = new Spherical();
    this._sphericalDelta = new Spherical();
    this._sphericalDump = new Spherical();
    this._zoomFrag = 0;
    this._scale = 1;
    this._panOffset = new Vector3();
    this._tempVec3 = new Vector3();
    this._enableHandler = ControlHandlerType.All;
  }
  /**
   * Return whether to enable keyboard.
   */
  get enableKeys() {
    return this._enableKeys;
  }
  set enableKeys(value) {
    if (this._enableKeys !== value) {
      this._enableKeys = value;
      const {
        inputDevices
      } = this;
      if (value) {
        inputDevices.push(ControlKeyboard);
      } else {
        for (let i = inputDevices.length - 1; i >= 0; i--) {
          if (inputDevices[i] === ControlKeyboard) {
            inputDevices.splice(i, 1);
            break;
          }
        }
      }
    }
  }

  /*
   * Return up vector.
   */
  get up() {
    return this._up;
  }
  set up(value) {
    this._up.copyFrom(value);
    this._spherical.setYAxis(value);
    this._atTheBack = false;
  }

  /**
   * Return target position.
   * */
  get target() {
    return this._target;
  }
  set target(value) {
    this._target.copyFrom(value);
    this._atTheBack = false;
  }

  /**
   *  Return Whether to enable rotation, the default is true.
   */
  get enableRotate() {
    return (this._enableHandler & ControlHandlerType.ROTATE) !== 0;
  }
  set enableRotate(value) {
    if (value) {
      this._enableHandler |= ControlHandlerType.ROTATE;
    } else {
      this._enableHandler &= ~ControlHandlerType.ROTATE;
    }
  }

  /**
   *  Whether to enable camera damping, the default is true.
   */
  get enableZoom() {
    return (this._enableHandler & ControlHandlerType.ZOOM) !== 0;
  }
  set enableZoom(value) {
    if (value) {
      this._enableHandler |= ControlHandlerType.ZOOM;
    } else {
      this._enableHandler &= ~ControlHandlerType.ZOOM;
    }
  }

  /**
   *  Whether to enable translation, the default is true.
   */
  get enablePan() {
    return (this._enableHandler & ControlHandlerType.PAN) !== 0;
  }
  set enablePan(value) {
    if (value) {
      this._enableHandler |= ControlHandlerType.PAN;
    } else {
      this._enableHandler &= ~ControlHandlerType.PAN;
    }
  }
  onAwake() {
    const {
      engine,
      entity
    } = this;
    this.canvas = engine.canvas;
    this.input = engine.inputManager;
    this.camera = entity.getComponent(Camera);
    this.cameraTransform = entity.transform;
    this._spherical.setYAxis(this._up);
    this._atTheBack = false;
  }
  onUpdate(deltaTime) {
    /** Update this._sphericalDelta, this._scale and this._panOffset. */
    this._updateInputDelta(deltaTime);
    /** Update camera's transform. */
    this._updateTransform();
  }
  _updateInputDelta(deltaTime) {
    let curHandlerType = ControlHandlerType.None;
    const {
      _tempVec3: delta,
      _enableHandler: enableHandler
    } = this;
    const {
      inputDevices,
      input
    } = this;
    for (let i = inputDevices.length - 1; i >= 0; i--) {
      const handler = inputDevices[i];
      const handlerType = handler.onUpdateHandler(input);
      if (handlerType & enableHandler) {
        curHandlerType |= handlerType;
        handler.onUpdateDelta(this, delta);
        switch (handlerType) {
          case ControlHandlerType.ROTATE:
            this._rotate(delta);
            break;
          case ControlHandlerType.ZOOM:
            this._zoom(delta);
            break;
          case ControlHandlerType.PAN:
            this._pan(delta);
            break;
        }
      }
    }
    const {
      _sphericalDump,
      _sphericalDelta
    } = this;
    if (this.enableDamping) {
      if (enableHandler & ControlHandlerType.ZOOM && curHandlerType ^ ControlHandlerType.ZOOM) {
        this._zoomFrag *= 1 - this.zoomFactor;
      }
      if (enableHandler & ControlHandlerType.ROTATE && curHandlerType ^ ControlHandlerType.ROTATE) {
        _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
        _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
      }
    }
    if (curHandlerType === ControlHandlerType.None && this.autoRotate) {
      const rotateAngle = this.autoRotateSpeed / 1000 * deltaTime;
      _sphericalDelta.theta -= rotateAngle;
    }
  }
  _rotate(delta) {
    const radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
    this._sphericalDelta.theta -= radianLeft;
    const radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
    this._sphericalDelta.phi -= radianUp;
    if (this.enableDamping) {
      this._sphericalDump.theta = -radianLeft;
      this._sphericalDump.phi = -radianUp;
    }
  }
  _zoom(delta) {
    if (delta.y > 0) {
      this._scale /= Math.pow(0.95, this.zoomSpeed);
    } else if (delta.y < 0) {
      this._scale *= Math.pow(0.95, this.zoomSpeed);
    }
  }
  _pan(delta) {
    const {
      cameraTransform
    } = this;
    const {
      elements
    } = cameraTransform.worldMatrix;
    const {
      height
    } = this.canvas;
    const targetDistance = Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
    const distanceLeft = -2 * delta.x * (targetDistance / height);
    const distanceUp = 2 * delta.y * (targetDistance / height);
    this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
    this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
    this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
  }
  _updateTransform() {
    const {
      cameraTransform,
      target,
      _tempVec3,
      _spherical,
      _sphericalDelta,
      _panOffset
    } = this;
    Vector3.subtract(cameraTransform.position, target, _tempVec3);
    _spherical.setFromVec3(_tempVec3, this._atTheBack);
    _spherical.theta += _sphericalDelta.theta;
    _spherical.phi += _sphericalDelta.phi;
    _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
    _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
    _spherical.makeSafe();
    if (this._scale !== 1) {
      this._zoomFrag = _spherical.radius * (this._scale - 1);
    }
    _spherical.radius += this._zoomFrag;
    _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
    this._atTheBack = _spherical.setToVec3(_tempVec3);
    Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.worldPosition);
    cameraTransform.lookAt(target, _tempVec3.copyFrom(this.up).scale(this._atTheBack ? -1 : 1));
    /** Reset cache value. */
    this._zoomFrag = 0;
    this._scale = 1;
    _sphericalDelta.set(0, 0, 0);
    _panOffset.set(0, 0, 0);
  }
}

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */
class OrthoControl extends Script {
  /**
   *  Return Whether to enable rotation, the default is true.
   */
  get enableRotate() {
    return (this._enableHandler & ControlHandlerType.ROTATE) !== 0;
  }
  set enableRotate(value) {
    if (value) {
      this._enableHandler |= ControlHandlerType.ROTATE;
    } else {
      this._enableHandler &= ~ControlHandlerType.ROTATE;
    }
  }

  /**
   *  Whether to enable camera damping, the default is true.
   */
  get enableZoom() {
    return (this._enableHandler & ControlHandlerType.ZOOM) !== 0;
  }
  set enableZoom(value) {
    if (value) {
      this._enableHandler |= ControlHandlerType.ZOOM;
    } else {
      this._enableHandler &= ~ControlHandlerType.ZOOM;
    }
  }

  /**
   *  Whether to enable translation, the default is true.
   */
  get enablePan() {
    return (this._enableHandler & ControlHandlerType.PAN) !== 0;
  }
  set enablePan(value) {
    if (value) {
      this._enableHandler |= ControlHandlerType.PAN;
    } else {
      this._enableHandler &= ~ControlHandlerType.PAN;
    }
  }
  constructor(entity) {
    super(entity);
    this.canvas = void 0;
    this.input = void 0;
    this.inputDevices = [ControlKeyboard, ControlPointer, ControlWheel];
    this.camera = void 0;
    this.cameraTransform = void 0;
    /** Target position. */
    this.target = new Vector3();
    /** Up vector */
    this.up = new Vector3(0, 1, 0);
    /** Whether to automatically rotate the camera, the default is false. */
    this.autoRotate = false;
    /** The radian of automatic rotation per second. */
    this.autoRotateSpeed = Math.PI;
    /** Whether to enable keyboard. */
    this.enableKeys = false;
    /** Whether to enable camera damping, the default is true. */
    this.enableDamping = true;
    /** Rotation speed, default is 1.0 . */
    this.rotateSpeed = 1.0;
    /** Camera zoom speed, the default is 1.0. */
    this.zoomSpeed = 1.0;
    /** Keyboard translation speed, the default is 7.0 . */
    this.keyPanSpeed = 7.0;
    /** Rotation damping parameter, default is 0.1 . */
    this.dampingFactor = 0.1;
    /** Zoom damping parameter, default is 0.2 . */
    this.zoomFactor = 0.2;
    /**  The minimum distance, the default is 0.1, should be greater than 0. */
    this.minDistance = 0.1;
    /** The maximum distance, the default is infinite, should be greater than the minimum distance. */
    this.maxDistance = Infinity;
    /** Minimum zoom speed, the default is 0.0. */
    this.minZoom = 0.0;
    /** Maximum zoom speed, the default is positive infinity. */
    this.maxZoom = Infinity;
    /** The minimum radian in the vertical direction, the default is 0 radian, the value range is 0 - Math.PI. */
    this.minPolarAngle = 0.0;
    /** The maximum radian in the vertical direction, the default is Math.PI, and the value range is 0 - Math.PI. */
    this.maxPolarAngle = Math.PI;
    /** The minimum radian in the horizontal direction, the default is negative infinity. */
    this.minAzimuthAngle = -Infinity;
    /** The maximum radian in the horizontal direction, the default is positive infinity.  */
    this.maxAzimuthAngle = Infinity;
    this._zoomScaleUnit = 25;
    this._scale = 1;
    this._panOffset = new Vector3();
    this._tempVec3 = new Vector3();
    this._enableHandler = ControlHandlerType.All;
    this.enableRotate = false;
  }
  onAwake() {
    const {
      engine,
      entity
    } = this;
    this.canvas = engine.canvas;
    this.input = engine.inputManager;
    this.camera = entity.getComponent(Camera);
    this.cameraTransform = entity.transform;
  }
  onUpdate(deltaTime) {
    /** Update this._sphericalDelta, this._scale and this._panOffset. */
    this._updateInputDelta(deltaTime);
    /** Update camera's transform. */
    this._updateCamera();
  }
  _updateInputDelta(deltaTime) {
    ControlHandlerType.None;
    const {
      _tempVec3: delta,
      _enableHandler: enableHandler
    } = this;
    const {
      inputDevices,
      input
    } = this;
    for (let i = inputDevices.length - 1; i >= 0; i--) {
      const handler = inputDevices[i];
      const handlerType = handler.onUpdateHandler(input);
      if (handlerType & enableHandler) {
        handler.onUpdateDelta(this, delta);
        switch (handlerType) {
          case ControlHandlerType.ZOOM:
            this._zoom(delta);
            break;
          case ControlHandlerType.PAN:
            this._pan(delta);
            break;
        }
      }
    }
  }
  _zoom(delta) {
    if (delta.y > 0) {
      this._scale /= Math.pow(0.95, this.zoomSpeed);
    } else if (delta.y < 0) {
      this._scale *= Math.pow(0.95, this.zoomSpeed);
    }
  }
  _pan(delta) {
    this._panOffset.copyFrom(delta);
  }
  _updateCamera() {
    const {
      cameraTransform,
      camera,
      _panOffset
    } = this;

    // Update Zoom
    const sizeDiff = this._zoomScaleUnit * (this._scale - 1);
    const size = camera.orthographicSize + sizeDiff;
    camera.orthographicSize = Math.max(this.minZoom, Math.min(this.maxZoom, size));

    // Update X and Y
    const {
      width,
      height
    } = this.canvas;
    const {
      x,
      y
    } = _panOffset;
    const doubleOrthographicSize = camera.orthographicSize * 2;
    const width3D = doubleOrthographicSize * camera.aspectRatio;
    const height3D = doubleOrthographicSize;
    const cameraPosition = cameraTransform.position;
    const curPosition = this._tempVec3;
    curPosition.x = cameraPosition.x - x * width3D / width;
    curPosition.y = cameraPosition.y + y * height3D / height;
    curPosition.z = cameraPosition.z;

    // Update camera transform
    cameraTransform.position = curPosition;
    /** Reset cache value. */
    this._scale = 1;
    _panOffset.set(0, 0, 0);
  }
}

export { ControlFreeKeyboard, ControlFreePointer, ControlHandlerType, ControlKeyboard, ControlPointer, ControlWheel, FreeControl, OrbitControl, OrthoControl, StaticInterfaceImplement };
//# sourceMappingURL=module.js.map

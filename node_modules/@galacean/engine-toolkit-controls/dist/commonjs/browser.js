'use strict';

var engine = require('@galacean/engine');

function _assert_this_initialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");

    return self;
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

exports.ControlHandlerType = void 0;
(function(ControlHandlerType) {
    ControlHandlerType[ControlHandlerType["None"] = 0] = "None";
    ControlHandlerType[ControlHandlerType["ROTATE"] = 1] = "ROTATE";
    ControlHandlerType[ControlHandlerType["ZOOM"] = 2] = "ZOOM";
    ControlHandlerType[ControlHandlerType["PAN"] = 4] = "PAN";
    ControlHandlerType[ControlHandlerType["All"] = 7] = "All";
})(exports.ControlHandlerType || (exports.ControlHandlerType = {}));

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

/**
 *  Static interface implement decorator.
 *  https://stackoverflow.com/questions/13955157/how-to-define-static-property-in-typescript-interface
 */ function StaticInterfaceImplement() {
    return function(constructor) {
    };
}

exports.ControlFreeKeyboard = /*#__PURE__*/ function() {
    function ControlFreeKeyboard() {}
    ControlFreeKeyboard.onUpdateHandler = function onUpdateHandler(input) {
        if (input.isKeyHeldDown(engine.Keys.ArrowLeft) || input.isKeyHeldDown(engine.Keys.KeyA) || input.isKeyHeldDown(engine.Keys.ArrowUp) || input.isKeyHeldDown(engine.Keys.KeyW) || input.isKeyHeldDown(engine.Keys.ArrowDown) || input.isKeyHeldDown(engine.Keys.KeyS) || input.isKeyHeldDown(engine.Keys.ArrowRight) || input.isKeyHeldDown(engine.Keys.KeyD)) {
            return exports.ControlHandlerType.PAN;
        } else {
            return exports.ControlHandlerType.None;
        }
    };
    ControlFreeKeyboard.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var movementSpeed = control.movementSpeed, input = control.input;
        outDelta.x = outDelta.y = outDelta.z = 0;
        if (input.isKeyHeldDown(engine.Keys.ArrowLeft) || input.isKeyHeldDown(engine.Keys.KeyA)) {
            outDelta.x -= movementSpeed;
        }
        if (input.isKeyHeldDown(engine.Keys.ArrowRight) || input.isKeyHeldDown(engine.Keys.KeyD)) {
            outDelta.x += movementSpeed;
        }
        if (input.isKeyHeldDown(engine.Keys.ArrowUp) || input.isKeyHeldDown(engine.Keys.KeyW)) {
            outDelta.z -= movementSpeed;
        }
        if (input.isKeyHeldDown(engine.Keys.ArrowDown) || input.isKeyHeldDown(engine.Keys.KeyS)) {
            outDelta.z += movementSpeed;
        }
    };
    return ControlFreeKeyboard;
}();
exports.ControlFreeKeyboard = __decorate([
    StaticInterfaceImplement()
], exports.ControlFreeKeyboard);

var _ControlFreePointer;
var DeltaType$1;
(function(DeltaType) {
    DeltaType[DeltaType["Moving"] = 0] = "Moving";
    DeltaType[DeltaType["Distance"] = 1] = "Distance";
    DeltaType[DeltaType["None"] = 2] = "None";
})(DeltaType$1 || (DeltaType$1 = {}));
exports.ControlFreePointer = (_ControlFreePointer = /*#__PURE__*/ function() {
    function ControlFreePointer() {}
    ControlFreePointer.onUpdateHandler = function onUpdateHandler(input) {
        ++this._frameIndex;
        if (input.pointers.length === 1) {
            if (input.isPointerHeldDown(engine.PointerButton.Primary)) {
                this._updateType(exports.ControlHandlerType.ROTATE, 0);
            } else {
                var deltaPosition = input.pointers[0].deltaPosition;
                if ((deltaPosition.x !== 0 || deltaPosition.y !== 0) && input.isPointerUp(engine.PointerButton.Primary)) {
                    this._updateType(exports.ControlHandlerType.ROTATE, 0);
                } else {
                    this._updateType(exports.ControlHandlerType.None, 2);
                }
            }
        } else {
            this._updateType(exports.ControlHandlerType.None, 2);
        }
        return this._handlerType;
    };
    ControlFreePointer.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var _this = this, frameIndex = _this._frameIndex;
        switch(this._deltaType){
            case 0:
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    var deltaPosition = control.input.pointers[0].deltaPosition;
                    outDelta.x = deltaPosition.x;
                    outDelta.y = deltaPosition.y;
                } else {
                    outDelta.x = 0;
                    outDelta.y = 0;
                }
                break;
        }
        this._lastUsefulFrameIndex = frameIndex;
    };
    ControlFreePointer._updateType = function _updateType(handlerType, deltaType) {
        if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
            this._handlerType = handlerType;
            this._deltaType = deltaType;
            this._lastUsefulFrameIndex = -1;
        }
    };
    return ControlFreePointer;
}(), function() {
    _ControlFreePointer._deltaType = 0;
}(), function() {
    _ControlFreePointer._handlerType = exports.ControlHandlerType.None;
}(), function() {
    _ControlFreePointer._frameIndex = 0;
}(), function() {
    _ControlFreePointer._lastUsefulFrameIndex = -1;
}(), _ControlFreePointer);
exports.ControlFreePointer = __decorate([
    StaticInterfaceImplement()
], exports.ControlFreePointer);

// Prevent gimbal lock.
var ESP = engine.MathUtil.zeroTolerance;
// Spherical.
var Spherical = /*#__PURE__*/ function() {
    function Spherical(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        this._matrix = new engine.Matrix();
        this._matrixInv = new engine.Matrix();
        this.radius = radius !== undefined ? radius : 1.0;
        this.phi = phi !== undefined ? phi : 0;
        this.theta = theta !== undefined ? theta : 0;
    }
    var _proto = Spherical.prototype;
    _proto.makeSafe = function makeSafe() {
        var count = Math.floor(this.phi / Math.PI);
        this.phi = engine.MathUtil.clamp(this.phi, count * Math.PI + ESP, (count + 1) * Math.PI - ESP);
        return this;
    };
    _proto.set = function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
    };
    _proto.setYAxis = function setYAxis(up) {
        var xAxis = Spherical._xAxis, yAxis = Spherical._yAxis, zAxis = Spherical._zAxis;
        if (engine.Vector3.equals(xAxis.set(1, 0, 0), yAxis.copyFrom(up).normalize())) {
            xAxis.set(0, 1, 0);
        }
        engine.Vector3.cross(xAxis, yAxis, zAxis);
        zAxis.normalize();
        engine.Vector3.cross(yAxis, zAxis, xAxis);
        var _this__matrix = this._matrix, es = _this__matrix.elements;
        es[0] = xAxis.x, es[1] = xAxis.y, es[2] = xAxis.z;
        es[4] = yAxis.x, es[5] = yAxis.y, es[6] = yAxis.z;
        es[8] = zAxis.x, es[9] = zAxis.y, es[10] = zAxis.z;
        var _this__matrixInv = this._matrixInv, eInv = _this__matrixInv.elements;
        eInv[0] = xAxis.x, eInv[4] = xAxis.y, eInv[8] = xAxis.z;
        eInv[1] = yAxis.x, eInv[5] = yAxis.y, eInv[9] = yAxis.z;
        eInv[2] = zAxis.x, eInv[6] = zAxis.y, eInv[10] = zAxis.z;
    };
    _proto.setFromVec3 = function setFromVec3(value, atTheBack) {
        if (atTheBack === void 0) atTheBack = false;
        value.transformNormal(this._matrixInv);
        this.radius = value.length();
        if (this.radius === 0) {
            this.theta = 0;
            this.phi = 0;
        } else {
            if (atTheBack) {
                this.phi = 2 * Math.PI - Math.acos(engine.MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(-value.x, -value.z);
            } else {
                this.phi = Math.acos(engine.MathUtil.clamp(value.y / this.radius, -1, 1));
                this.theta = Math.atan2(value.x, value.z);
            }
        }
        return this;
    };
    _proto.setToVec3 = function setToVec3(value) {
        var _this = this, radius = _this.radius, phi = _this.phi, theta = _this.theta;
        var sinPhiRadius = Math.sin(phi) * radius;
        this.phi -= Math.floor(this.phi / Math.PI / 2) * Math.PI * 2;
        value.set(sinPhiRadius * Math.sin(theta), radius * Math.cos(phi), sinPhiRadius * Math.cos(theta));
        value.transformNormal(this._matrix);
        return this.phi > Math.PI;
    };
    return Spherical;
}();
(function() {
    Spherical._xAxis = new engine.Vector3();
})();
(function() {
    Spherical._yAxis = new engine.Vector3();
})();
(function() {
    Spherical._zAxis = new engine.Vector3();
})();

/**
 * The camera's roaming controller, can move up and down, left and right, and rotate the viewing angle.
 */ var FreeControl = /*#__PURE__*/ function(Script) {
    _inherits(FreeControl, Script);
    function FreeControl(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this.inputDevices = [
            exports.ControlFreeKeyboard,
            exports.ControlFreePointer
        ];
        /** Movement distance per second, the unit is the unit before MVP conversion. */ _this.movementSpeed = 1.0;
        /** Rotate speed. */ _this.rotateSpeed = 1.0;
        /** Simulate a ground. */ _this.floorMock = true;
        /** Simulated ground height. */ _this.floorY = 0;
        _this._spherical = new Spherical();
        _this._tempVec = new engine.Vector3();
        _this._atTheBack = false;
        _this._topVec = new engine.Vector3(0, 1, 0);
        _this._bottomVec = new engine.Vector3(0, -1, 0);
        _this.input = _this.engine.inputManager;
        var transform = _this._cameraTransform = entity.transform;
        /** Init spherical. */ var _$_assert_this_initialized = _assert_this_initialized(_this), tempVec = _$_assert_this_initialized._tempVec, spherical = _$_assert_this_initialized._spherical;
        engine.Vector3.transformByQuat(tempVec.set(0, 0, -1), transform.rotationQuaternion, tempVec);
        spherical.setFromVec3(tempVec, _this._atTheBack);
        return _this;
    }
    var _proto = FreeControl.prototype;
    _proto.onUpdate = function onUpdate(deltaTime) {
        if (this.enabled === false) return;
        exports.ControlHandlerType.None;
        var _this = this, delta = _this._tempVec;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType) {
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case exports.ControlHandlerType.ROTATE:
                        this._rotate(delta);
                        break;
                    case exports.ControlHandlerType.PAN:
                        this._pan(delta, deltaTime);
                        break;
                }
            }
        }
        if (this.floorMock) {
            var position = this._cameraTransform.position;
            if (position.y !== this.floorY) {
                this._cameraTransform.setPosition(position.x, this.floorY, position.z);
            }
        }
    };
    _proto._pan = function _pan(moveDelta, delta) {
        var actualMoveSpeed = delta / 1000 * this.movementSpeed;
        moveDelta.normalize().scale(actualMoveSpeed);
        this._cameraTransform.translate(moveDelta, true);
    };
    _proto._rotate = function _rotate(moveDelta) {
        if (moveDelta.x !== 0 || moveDelta.y !== 0) {
            var canvas = this.engine.canvas;
            var deltaAlpha = -moveDelta.x * 180 / canvas.width;
            var deltaPhi = moveDelta.y * 180 / canvas.height;
            this._spherical.theta += engine.MathUtil.degreeToRadian(deltaAlpha);
            this._spherical.phi += engine.MathUtil.degreeToRadian(deltaPhi);
            this._spherical.makeSafe();
            this._atTheBack = this._spherical.setToVec3(this._tempVec);
            engine.Vector3.add(this._cameraTransform.position, this._tempVec, this._tempVec);
            this._atTheBack ? this._cameraTransform.lookAt(this._tempVec, this._bottomVec) : this._cameraTransform.lookAt(this._tempVec, this._topVec);
        }
    };
    return FreeControl;
}(engine.Script);

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

exports.ControlKeyboard = /*#__PURE__*/ function() {
    function ControlKeyboard() {}
    ControlKeyboard.onUpdateHandler = function onUpdateHandler(input) {
        if (input.isKeyHeldDown(engine.Keys.ArrowLeft) || input.isKeyHeldDown(engine.Keys.ArrowRight) || input.isKeyHeldDown(engine.Keys.ArrowUp) || input.isKeyHeldDown(engine.Keys.ArrowDown)) {
            return exports.ControlHandlerType.PAN;
        } else {
            return exports.ControlHandlerType.None;
        }
    };
    ControlKeyboard.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var keyPanSpeed = control.keyPanSpeed, input = control.input;
        outDelta.x = outDelta.y = 0;
        if (input.isKeyHeldDown(engine.Keys.ArrowLeft)) {
            outDelta.x += keyPanSpeed;
        }
        if (input.isKeyHeldDown(engine.Keys.ArrowRight)) {
            outDelta.x -= keyPanSpeed;
        }
        if (input.isKeyHeldDown(engine.Keys.ArrowUp)) {
            outDelta.y += keyPanSpeed;
        }
        if (input.isKeyHeldDown(engine.Keys.ArrowDown)) {
            outDelta.y -= keyPanSpeed;
        }
    };
    return ControlKeyboard;
}();
exports.ControlKeyboard = __decorate([
    StaticInterfaceImplement()
], exports.ControlKeyboard);

var _ControlPointer;
var DeltaType;
(function(DeltaType) {
    DeltaType[DeltaType["Moving"] = 0] = "Moving";
    DeltaType[DeltaType["Distance"] = 1] = "Distance";
    DeltaType[DeltaType["None"] = 2] = "None";
})(DeltaType || (DeltaType = {}));
exports.ControlPointer = (_ControlPointer = /*#__PURE__*/ function() {
    function ControlPointer() {}
    ControlPointer.onUpdateHandler = function onUpdateHandler(input) {
        ++this._frameIndex;
        var pointers = input.pointers;
        switch(pointers.length){
            case 1:
                if (input.isPointerHeldDown(engine.PointerButton.Secondary)) {
                    this._updateType(exports.ControlHandlerType.PAN, 0);
                } else if (input.isPointerHeldDown(engine.PointerButton.Auxiliary)) {
                    this._updateType(exports.ControlHandlerType.ZOOM, 0);
                } else if (input.isPointerHeldDown(engine.PointerButton.Primary)) {
                    this._updateType(exports.ControlHandlerType.ROTATE, 0);
                } else {
                    // When `onPointerMove` happens on the same frame as `onPointerUp`
                    // Need to record the movement of this frame
                    var deltaPosition = input.pointers[0].deltaPosition;
                    if (deltaPosition.x !== 0 && deltaPosition.y !== 0) {
                        if (input.isPointerUp(engine.PointerButton.Secondary)) {
                            this._updateType(exports.ControlHandlerType.PAN, 0);
                        } else if (input.isPointerUp(engine.PointerButton.Auxiliary)) {
                            this._updateType(exports.ControlHandlerType.ZOOM, 0);
                        } else if (input.isPointerUp(engine.PointerButton.Primary)) {
                            this._updateType(exports.ControlHandlerType.ROTATE, 0);
                        } else {
                            this._updateType(exports.ControlHandlerType.None, 2);
                        }
                    } else {
                        this._updateType(exports.ControlHandlerType.None, 2);
                    }
                }
                break;
            case 2:
                this._updateType(exports.ControlHandlerType.ZOOM, 1);
                break;
            case 3:
                this._updateType(exports.ControlHandlerType.PAN, 0);
                break;
            default:
                this._updateType(exports.ControlHandlerType.None, 2);
                break;
        }
        return this._handlerType;
    };
    ControlPointer.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        var _this = this, frameIndex = _this._frameIndex;
        switch(this._deltaType){
            case 0:
                outDelta.x = 0;
                outDelta.y = 0;
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    var pointers = control.input.pointers;
                    var length = pointers.length;
                    for(var i = length - 1; i >= 0; i--){
                        var deltaPosition = pointers[i].deltaPosition;
                        outDelta.x += deltaPosition.x;
                        outDelta.y += deltaPosition.y;
                    }
                    outDelta.x /= length;
                    outDelta.y /= length;
                }
                break;
            case 1:
                var pointers1 = control.input.pointers;
                var pointer1 = pointers1[0];
                var pointer2 = pointers1[1];
                var curDistance = engine.Vector2.distance(pointer1.position, pointer2.position);
                if (this._lastUsefulFrameIndex === frameIndex - 1) {
                    outDelta.set(0, this._distanceOfPointers - curDistance, 0);
                } else {
                    outDelta.set(0, 0, 0);
                }
                this._distanceOfPointers = curDistance;
                break;
        }
        this._lastUsefulFrameIndex = frameIndex;
    };
    ControlPointer._updateType = function _updateType(handlerType, deltaType) {
        if (this._handlerType !== handlerType || this._deltaType !== deltaType) {
            this._handlerType = handlerType;
            this._deltaType = deltaType;
            this._lastUsefulFrameIndex = -1;
        }
    };
    return ControlPointer;
}(), function() {
    _ControlPointer._deltaType = 2;
}(), function() {
    _ControlPointer._handlerType = exports.ControlHandlerType.None;
}(), function() {
    _ControlPointer._frameIndex = 0;
}(), function() {
    _ControlPointer._lastUsefulFrameIndex = -1;
}(), function() {
    _ControlPointer._distanceOfPointers = 0;
}(), _ControlPointer);
exports.ControlPointer = __decorate([
    StaticInterfaceImplement()
], exports.ControlPointer);

exports.ControlWheel = /*#__PURE__*/ function() {
    function ControlWheel() {}
    ControlWheel.onUpdateHandler = function onUpdateHandler(input) {
        var wheelDelta = input.wheelDelta;
        if (wheelDelta.x === 0 && wheelDelta.y === 0 && wheelDelta.z === 0) {
            return exports.ControlHandlerType.None;
        } else {
            return exports.ControlHandlerType.ZOOM;
        }
    };
    ControlWheel.onUpdateDelta = function onUpdateDelta(control, outDelta) {
        outDelta.copyFrom(control.input.wheelDelta);
    };
    return ControlWheel;
}();
exports.ControlWheel = __decorate([
    StaticInterfaceImplement()
], exports.ControlWheel);

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */ var OrbitControl = /*#__PURE__*/ function(Script) {
    _inherits(OrbitControl, Script);
    function OrbitControl() {
        var _this;
        _this = Script.apply(this, arguments) || this;
        _this.inputDevices = [
            exports.ControlKeyboard,
            exports.ControlPointer,
            exports.ControlWheel
        ];
        /** Whether to automatically rotate the camera, the default is false. */ _this.autoRotate = false;
        /** The radian of automatic rotation per second. */ _this.autoRotateSpeed = Math.PI;
        /** Whether to enable camera damping, the default is true. */ _this.enableDamping = true;
        /** Rotation speed, default is 1.0 . */ _this.rotateSpeed = 1.0;
        /** Camera zoom speed, the default is 1.0. */ _this.zoomSpeed = 1.0;
        /** Keyboard translation speed, the default is 7.0 . */ _this.keyPanSpeed = 7.0;
        /** Rotation damping parameter, default is 0.1 . */ _this.dampingFactor = 0.1;
        /** Zoom damping parameter, default is 0.2 . */ _this.zoomFactor = 0.2;
        /**  The minimum distance, the default is 0.1, should be greater than 0. */ _this.minDistance = 0.1;
        /** The maximum distance, the default is infinite, should be greater than the minimum distance. */ _this.maxDistance = Infinity;
        /** Minimum zoom speed, the default is 0.0. */ _this.minZoom = 0.0;
        /** Maximum zoom speed, the default is positive infinity. */ _this.maxZoom = Infinity;
        /** The minimum radian in the vertical direction, the default is 1 degree. */ _this.minPolarAngle = 1;
        /** The maximum radian in the vertical direction,  the default is 179 degree.  */ _this.maxPolarAngle = 179 / 180 * Math.PI;
        /** The minimum radian in the horizontal direction, the default is negative infinity. */ _this.minAzimuthAngle = -Infinity;
        /** The maximum radian in the horizontal direction, the default is positive infinity.  */ _this.maxAzimuthAngle = Infinity;
        _this._enableKeys = true;
        _this._up = new engine.Vector3(0, 1, 0);
        _this._target = new engine.Vector3();
        _this._atTheBack = false;
        _this._spherical = new Spherical();
        _this._sphericalDelta = new Spherical();
        _this._sphericalDump = new Spherical();
        _this._zoomFrag = 0;
        _this._scale = 1;
        _this._panOffset = new engine.Vector3();
        _this._tempVec3 = new engine.Vector3();
        _this._enableHandler = exports.ControlHandlerType.All;
        return _this;
    }
    var _proto = OrbitControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine$1 = _this.engine, entity = _this.entity;
        this.canvas = engine$1.canvas;
        this.input = engine$1.inputManager;
        this.camera = entity.getComponent(engine.Camera);
        this.cameraTransform = entity.transform;
        this._spherical.setYAxis(this._up);
        this._atTheBack = false;
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
        /** Update this._sphericalDelta, this._scale and this._panOffset. */ this._updateInputDelta(deltaTime);
        /** Update camera's transform. */ this._updateTransform();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
        var curHandlerType = exports.ControlHandlerType.None;
        var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType & enableHandler) {
                curHandlerType |= handlerType;
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case exports.ControlHandlerType.ROTATE:
                        this._rotate(delta);
                        break;
                    case exports.ControlHandlerType.ZOOM:
                        this._zoom(delta);
                        break;
                    case exports.ControlHandlerType.PAN:
                        this._pan(delta);
                        break;
                }
            }
        }
        var _this2 = this, _sphericalDump = _this2._sphericalDump, _sphericalDelta = _this2._sphericalDelta;
        if (this.enableDamping) {
            if (enableHandler & exports.ControlHandlerType.ZOOM && curHandlerType ^ exports.ControlHandlerType.ZOOM) {
                this._zoomFrag *= 1 - this.zoomFactor;
            }
            if (enableHandler & exports.ControlHandlerType.ROTATE && curHandlerType ^ exports.ControlHandlerType.ROTATE) {
                _sphericalDelta.theta = _sphericalDump.theta *= 1 - this.dampingFactor;
                _sphericalDelta.phi = _sphericalDump.phi *= 1 - this.dampingFactor;
            }
        }
        if (curHandlerType === exports.ControlHandlerType.None && this.autoRotate) {
            var rotateAngle = this.autoRotateSpeed / 1000 * deltaTime;
            _sphericalDelta.theta -= rotateAngle;
        }
    };
    _proto._rotate = function _rotate(delta) {
        var radianLeft = 2 * Math.PI * delta.x / this.canvas.width * this.rotateSpeed;
        this._sphericalDelta.theta -= radianLeft;
        var radianUp = 2 * Math.PI * delta.y / this.canvas.height * this.rotateSpeed;
        this._sphericalDelta.phi -= radianUp;
        if (this.enableDamping) {
            this._sphericalDump.theta = -radianLeft;
            this._sphericalDump.phi = -radianUp;
        }
    };
    _proto._zoom = function _zoom(delta) {
        if (delta.y > 0) {
            this._scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (delta.y < 0) {
            this._scale *= Math.pow(0.95, this.zoomSpeed);
        }
    };
    _proto._pan = function _pan(delta) {
        var cameraTransform = this.cameraTransform;
        var elements = cameraTransform.worldMatrix.elements;
        var height = this.canvas.height;
        var targetDistance = engine.Vector3.distance(cameraTransform.position, this.target) * (this.camera.fieldOfView / 2) * (Math.PI / 180);
        var distanceLeft = -2 * delta.x * (targetDistance / height);
        var distanceUp = 2 * delta.y * (targetDistance / height);
        this._panOffset.x += elements[0] * distanceLeft + elements[4] * distanceUp;
        this._panOffset.y += elements[1] * distanceLeft + elements[5] * distanceUp;
        this._panOffset.z += elements[2] * distanceLeft + elements[6] * distanceUp;
    };
    _proto._updateTransform = function _updateTransform() {
        var _this = this, cameraTransform = _this.cameraTransform, target = _this.target, _tempVec3 = _this._tempVec3, _spherical = _this._spherical, _sphericalDelta = _this._sphericalDelta, _panOffset = _this._panOffset;
        _tempVec3.copyFrom(cameraTransform.worldUp);
        this._atTheBack = _tempVec3.y <= 0;
        engine.Vector3.subtract(cameraTransform.position, target, _tempVec3);
        _spherical.setFromVec3(_tempVec3, this._atTheBack);
        _spherical.theta += _sphericalDelta.theta;
        _spherical.phi += _sphericalDelta.phi;
        _spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, _spherical.theta));
        _spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, _spherical.phi));
        _spherical.makeSafe();
        if (this._scale !== 1) {
            this._zoomFrag = _spherical.radius * (this._scale - 1);
        }
        _spherical.radius += this._zoomFrag;
        _spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, _spherical.radius));
        this._atTheBack = _spherical.setToVec3(_tempVec3);
        engine.Vector3.add(target.add(_panOffset), _tempVec3, cameraTransform.worldPosition);
        cameraTransform.lookAt(target, _tempVec3.copyFrom(this.up).scale(this._atTheBack ? -1 : 1));
        /** Reset cache value. */ this._zoomFrag = 0;
        this._scale = 1;
        _sphericalDelta.set(0, 0, 0);
        _panOffset.set(0, 0, 0);
    };
    _create_class(OrbitControl, [
        {
            key: "enableKeys",
            get: /**
   * Return whether to enable keyboard.
   */ function get() {
                return this._enableKeys;
            },
            set: function set(value) {
                if (this._enableKeys !== value) {
                    this._enableKeys = value;
                    var inputDevices = this.inputDevices;
                    if (value) {
                        inputDevices.push(exports.ControlKeyboard);
                    } else {
                        for(var i = inputDevices.length - 1; i >= 0; i--){
                            if (inputDevices[i] === exports.ControlKeyboard) {
                                inputDevices.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
            }
        },
        {
            key: "up",
            get: /*
   * Return up vector.
   */ function get() {
                return this._up;
            },
            set: function set(value) {
                this._up.copyFrom(value);
                this._spherical.setYAxis(value);
                this._atTheBack = false;
            }
        },
        {
            key: "target",
            get: /**
   * Return target position.
   * */ function get() {
                return this._target;
            },
            set: function set(value) {
                this._target.copyFrom(value);
                this._atTheBack = false;
            }
        },
        {
            key: "enableRotate",
            get: /**
   *  Return Whether to enable rotation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ROTATE) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ROTATE;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ROTATE;
                }
            }
        },
        {
            key: "enableZoom",
            get: /**
   *  Whether to enable camera damping, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ZOOM) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ZOOM;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ZOOM;
                }
            }
        },
        {
            key: "enablePan",
            get: /**
   *  Whether to enable translation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.PAN) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.PAN;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.PAN;
                }
            }
        }
    ]);
    return OrbitControl;
}(engine.Script);

/**
 * The camera's track controller, can rotate, zoom, pan, support mouse and touch events.
 */ var OrthoControl = /*#__PURE__*/ function(Script) {
    _inherits(OrthoControl, Script);
    function OrthoControl(entity) {
        var _this;
        _this = Script.call(this, entity) || this;
        _this.inputDevices = [
            exports.ControlKeyboard,
            exports.ControlPointer,
            exports.ControlWheel
        ];
        /** Target position. */ _this.target = new engine.Vector3();
        /** Up vector */ _this.up = new engine.Vector3(0, 1, 0);
        /** Whether to automatically rotate the camera, the default is false. */ _this.autoRotate = false;
        /** The radian of automatic rotation per second. */ _this.autoRotateSpeed = Math.PI;
        /** Whether to enable keyboard. */ _this.enableKeys = false;
        /** Whether to enable camera damping, the default is true. */ _this.enableDamping = true;
        /** Rotation speed, default is 1.0 . */ _this.rotateSpeed = 1.0;
        /** Camera zoom speed, the default is 1.0. */ _this.zoomSpeed = 1.0;
        /** Keyboard translation speed, the default is 7.0 . */ _this.keyPanSpeed = 7.0;
        /** Rotation damping parameter, default is 0.1 . */ _this.dampingFactor = 0.1;
        /** Zoom damping parameter, default is 0.2 . */ _this.zoomFactor = 0.2;
        /**  The minimum distance, the default is 0.1, should be greater than 0. */ _this.minDistance = 0.1;
        /** The maximum distance, the default is infinite, should be greater than the minimum distance. */ _this.maxDistance = Infinity;
        /** Minimum zoom speed, the default is 0.0. */ _this.minZoom = 0.0;
        /** Maximum zoom speed, the default is positive infinity. */ _this.maxZoom = Infinity;
        /** The minimum radian in the vertical direction, the default is 0 radian, the value range is 0 - Math.PI. */ _this.minPolarAngle = 0.0;
        /** The maximum radian in the vertical direction, the default is Math.PI, and the value range is 0 - Math.PI. */ _this.maxPolarAngle = Math.PI;
        /** The minimum radian in the horizontal direction, the default is negative infinity. */ _this.minAzimuthAngle = -Infinity;
        /** The maximum radian in the horizontal direction, the default is positive infinity.  */ _this.maxAzimuthAngle = Infinity;
        _this._zoomScaleUnit = 2;
        _this._scale = 1;
        _this._panOffset = new engine.Vector3();
        _this._tempVec3 = new engine.Vector3();
        _this._enableHandler = exports.ControlHandlerType.All;
        _this.enableRotate = false;
        return _this;
    }
    var _proto = OrthoControl.prototype;
    _proto.onAwake = function onAwake() {
        var _this = this, engine$1 = _this.engine, entity = _this.entity;
        this.canvas = engine$1.canvas;
        this.input = engine$1.inputManager;
        this.camera = entity.getComponent(engine.Camera);
        this.cameraTransform = entity.transform;
    };
    _proto.onUpdate = function onUpdate(deltaTime) {
        /** Update this._sphericalDelta, this._scale and this._panOffset. */ this._updateInputDelta(deltaTime);
        /** Update camera's transform. */ this._updateCamera();
    };
    _proto._updateInputDelta = function _updateInputDelta(deltaTime) {
        exports.ControlHandlerType.None;
        var _this = this, delta = _this._tempVec3, enableHandler = _this._enableHandler;
        var _this1 = this, inputDevices = _this1.inputDevices, input = _this1.input;
        for(var i = inputDevices.length - 1; i >= 0; i--){
            var handler = inputDevices[i];
            var handlerType = handler.onUpdateHandler(input);
            if (handlerType & enableHandler) {
                handler.onUpdateDelta(this, delta);
                switch(handlerType){
                    case exports.ControlHandlerType.ZOOM:
                        this._zoom(delta);
                        break;
                    case exports.ControlHandlerType.PAN:
                        this._pan(delta);
                        break;
                }
            }
        }
    };
    _proto._zoom = function _zoom(delta) {
        if (delta.y > 0) {
            this._scale /= Math.pow(0.95, this.zoomSpeed);
        } else if (delta.y < 0) {
            this._scale *= Math.pow(0.95, this.zoomSpeed);
        }
    };
    _proto._pan = function _pan(delta) {
        this._panOffset.copyFrom(delta);
    };
    _proto._updateCamera = function _updateCamera() {
        var _this = this, cameraTransform = _this.cameraTransform, camera = _this.camera, _panOffset = _this._panOffset;
        // Update Zoom
        var sizeDiff = this._zoomScaleUnit * Math.log1p(camera.orthographicSize) * (this._scale - 1);
        var size = camera.orthographicSize + sizeDiff;
        camera.orthographicSize = Math.max(this.minZoom, Math.min(this.maxZoom, size));
        // Update X and Y
        var _this_canvas = this.canvas, width = _this_canvas.width, height = _this_canvas.height;
        var x = _panOffset.x, y = _panOffset.y;
        var doubleOrthographicSize = camera.orthographicSize * 2;
        var width3D = doubleOrthographicSize * camera.aspectRatio;
        var height3D = doubleOrthographicSize;
        var cameraPosition = cameraTransform.position;
        var curPosition = this._tempVec3;
        curPosition.x = cameraPosition.x - x * width3D / width;
        curPosition.y = cameraPosition.y + y * height3D / height;
        curPosition.z = cameraPosition.z;
        // Update camera transform
        cameraTransform.position = curPosition;
        /** Reset cache value. */ this._scale = 1;
        _panOffset.set(0, 0, 0);
    };
    _create_class(OrthoControl, [
        {
            key: "enableRotate",
            get: /**
   *  Return Whether to enable rotation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ROTATE) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ROTATE;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ROTATE;
                }
            }
        },
        {
            key: "enableZoom",
            get: /**
   *  Whether to enable camera damping, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.ZOOM) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.ZOOM;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.ZOOM;
                }
            }
        },
        {
            key: "enablePan",
            get: /**
   *  Whether to enable translation, the default is true.
   */ function get() {
                return (this._enableHandler & exports.ControlHandlerType.PAN) !== 0;
            },
            set: function set(value) {
                if (value) {
                    this._enableHandler |= exports.ControlHandlerType.PAN;
                } else {
                    this._enableHandler &= ~exports.ControlHandlerType.PAN;
                }
            }
        }
    ]);
    return OrthoControl;
}(engine.Script);

exports.FreeControl = FreeControl;
exports.OrbitControl = OrbitControl;
exports.OrthoControl = OrthoControl;
exports.StaticInterfaceImplement = StaticInterfaceImplement;
//# sourceMappingURL=browser.js.map

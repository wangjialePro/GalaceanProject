import { Font } from "./2d/text/Font";
import { ResourceManager } from "./asset/ResourceManager";
import { EventDispatcher, Time } from "./base";
import { Canvas } from "./Canvas";
import { ComponentsManager } from "./ComponentsManager";
import { EngineSettings } from "./EngineSettings";
import { Entity } from "./Entity";
import { InputManager } from "./input";
import { LightManager } from "./lighting/LightManager";
import { Material } from "./material/Material";
import { PhysicsManager } from "./physics";
import { IHardwareRenderer } from "./renderingHardwareInterface";
import { ClassPool } from "./RenderPipeline/ClassPool";
import { MeshRenderElement } from "./RenderPipeline/MeshRenderElement";
import { RenderContext } from "./RenderPipeline/RenderContext";
import { SpriteElement } from "./RenderPipeline/SpriteElement";
import { SpriteMaskElement } from "./RenderPipeline/SpriteMaskElement";
import { TextRenderElement } from "./RenderPipeline/TextRenderElement";
import { Scene } from "./Scene";
import { SceneManager } from "./SceneManager";
import { RenderState } from "./shader/state/RenderState";
/**
 * Engine.
 */
export declare class Engine extends EventDispatcher {
    /** Physics manager of Engine. */
    readonly physicsManager: PhysicsManager;
    readonly inputManager: InputManager;
    _lightManager: LightManager;
    _componentsManager: ComponentsManager;
    _hardwareRenderer: IHardwareRenderer;
    _lastRenderState: RenderState;
    _renderElementPool: ClassPool<MeshRenderElement>;
    _spriteElementPool: ClassPool<SpriteElement>;
    _spriteMaskElementPool: ClassPool<SpriteMaskElement>;
    _textElementPool: ClassPool<TextRenderElement>;
    _spriteDefaultMaterial: Material;
    _spriteMaskDefaultMaterial: Material;
    _textDefaultFont: Font;
    _renderContext: RenderContext;
    protected _canvas: Canvas;
    private _settings;
    private _resourceManager;
    private _sceneManager;
    private _vSyncCount;
    private _targetFrameRate;
    private _time;
    private _isPaused;
    private _requestId;
    private _timeoutId;
    private _vSyncCounter;
    private _targetFrameInterval;
    private _destroyed;
    private _frameInProcess;
    private _waittingDestroy;
    private _animate;
    /**
     * Settings of Engine.
     */
    get settings(): EngineSettings;
    /**
     * The canvas to use for rendering.
     */
    get canvas(): Canvas;
    /**
     * Get the resource manager.
     */
    get resourceManager(): ResourceManager;
    /**
     * Get the scene manager.
     */
    get sceneManager(): SceneManager;
    /**
     * Get the Time class.
     */
    get time(): Time;
    /**
     * Whether the engine is paused.
     */
    get isPaused(): boolean;
    /**
     * The number of vertical synchronization means the number of vertical blanking for one frame.
     * @remarks 0 means that the vertical synchronization is turned off.
     */
    get vSyncCount(): number;
    set vSyncCount(value: number);
    /**
     * Set the target frame rate you want to achieve.
     * @remarks
     * It only takes effect when vSyncCount = 0 (ie, vertical synchronization is turned off).
     * The larger the value, the higher the target frame rate, Number.POSITIVE_INFINITY represents the infinite target frame rate.
     */
    get targetFrameRate(): number;
    set targetFrameRate(value: number);
    /**
     * Indicates whether the engine is destroyed.
     */
    get destroyed(): boolean;
    /**
     * Create engine.
     * @param canvas - The canvas to use for rendering
     * @param hardwareRenderer - Graphics API renderer
     * @param settings - Engine Settings
     */
    constructor(canvas: Canvas, hardwareRenderer: IHardwareRenderer, settings?: EngineSettings);
    /**
     * Create an entity.
     * @param name - The name of the entity
     * @returns Entity
     */
    createEntity(name?: string): Entity;
    /**
     * Pause the engine.
     */
    pause(): void;
    /**
     * Resume the engine.
     */
    resume(): void;
    /**
     * Update the engine loop manually. If you call engine.run(), you generally don't need to call this function.
     */
    update(): void;
    /**
     * Execution engine loop.
     */
    run(): void;
    private _destroy;
    /**
     * Destroy engine.
     * @remarks If call during frame execution will delay until the end of the frame
     */
    destroy(): void;
    /**
     * @intenral
     */
    _render(scene: Scene): void;
    private _createSpriteMaterial;
    private _createSpriteMaskMaterial;
}

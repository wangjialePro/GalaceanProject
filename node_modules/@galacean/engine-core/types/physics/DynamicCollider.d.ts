import { Quaternion, Vector3 } from "@galacean/engine-math";
import { Collider } from "./Collider";
/**
 * A dynamic collider can act with self-defined movement or physical force.
 */
export declare class DynamicCollider extends Collider {
    private _linearDamping;
    private _angularDamping;
    private _linearVelocity;
    private _angularVelocity;
    private _mass;
    private _centerOfMass;
    private _inertiaTensor;
    private _maxAngularVelocity;
    private _maxDepenetrationVelocity;
    private _solverIterations;
    private _isKinematic;
    private _constraints;
    private _collisionDetectionMode;
    private _sleepThreshold;
    /**
     * The linear damping of the dynamic collider.
     */
    get linearDamping(): number;
    set linearDamping(value: number);
    /**
     * The angular damping of the dynamic collider.
     */
    get angularDamping(): number;
    set angularDamping(value: number);
    /**
     * The linear velocity vector of the dynamic collider measured in world unit per second.
     */
    get linearVelocity(): Vector3;
    set linearVelocity(value: Vector3);
    /**
     * The angular velocity vector of the dynamic collider measured in radians per second.
     */
    get angularVelocity(): Vector3;
    set angularVelocity(value: Vector3);
    /**
     * The mass of the dynamic collider.
     */
    get mass(): number;
    set mass(value: number);
    /**
     * The center of mass relative to the transform's origin.
     */
    get centerOfMass(): Vector3;
    set centerOfMass(value: Vector3);
    /**
     * The diagonal inertia tensor of mass relative to the center of mass.
     */
    get inertiaTensor(): Vector3;
    set inertiaTensor(value: Vector3);
    /**
     * The maximum angular velocity of the collider measured in radians per second. (Default 7) range { 0, infinity }.
     */
    get maxAngularVelocity(): number;
    set maxAngularVelocity(value: number);
    /**
     * Maximum velocity of a collider when moving out of penetrating state.
     */
    get maxDepenetrationVelocity(): number;
    set maxDepenetrationVelocity(value: number);
    /**
     * The mass-normalized energy threshold, below which objects start going to sleep.
     */
    get sleepThreshold(): number;
    set sleepThreshold(value: number);
    /**
     * The solverIterations determines how accurately collider joints and collision contacts are resolved.
     */
    get solverIterations(): number;
    set solverIterations(value: number);
    /**
     * Controls whether physics affects the dynamic collider.
     */
    get isKinematic(): boolean;
    set isKinematic(value: boolean);
    /**
     * The particular rigid dynamic lock flag.
     */
    get constraints(): DynamicColliderConstraints;
    set constraints(value: DynamicColliderConstraints);
    /**
     * The colliders' collision detection mode.
     */
    get collisionDetectionMode(): CollisionDetectionMode;
    set collisionDetectionMode(value: CollisionDetectionMode);
    /**
     * Apply a force to the DynamicCollider.
     * @param force - The force make the collider move
     */
    applyForce(force: Vector3): void;
    /**
     * Apply a torque to the DynamicCollider.
     * @param torque - The force make the collider rotate
     */
    applyTorque(torque: Vector3): void;
    /**
     * Moves kinematically controlled dynamic actors through the game world.
     * @param position - The desired position for the kinematic actor
     */
    move(position: Vector3): void;
    /**
     * Moves kinematically controlled dynamic actors through the game world.
     * @param rotation - The desired rotation for the kinematic actor
     */
    move(rotation: Quaternion): void;
    /**
     * Moves kinematically controlled dynamic actors through the game world.
     * @param position - The desired position for the kinematic actor
     * @param rotation - The desired rotation for the kinematic actor
     */
    move(position: Vector3, rotation: Quaternion): void;
    /**
     * Forces a collider to sleep at least one frame.
     */
    sleep(): void;
    /**
     * Forces a collider to wake up.
     */
    wakeUp(): void;
    private _setLinearVelocity;
    private _setAngularVelocity;
    private _setCenterOfMass;
    private _setInertiaTensor;
}
/**
 * The collision detection mode constants.
 */
export declare enum CollisionDetectionMode {
    /** Continuous collision detection is off for this dynamic collider. */
    Discrete = 0,
    /** Continuous collision detection is on for colliding with static mesh geometry. */
    Continuous = 1,
    /** Continuous collision detection is on for colliding with static and dynamic geometry. */
    ContinuousDynamic = 2,
    /** Speculative continuous collision detection is on for static and dynamic geometries */
    ContinuousSpeculative = 3
}
/**
 * Use these flags to constrain motion of dynamic collider.
 */
export declare enum DynamicColliderConstraints {
    /** Not Freeze. */
    None = 0,
    /** Freeze motion along the X-axis. */
    FreezePositionX = 1,
    /** Freeze motion along the Y-axis. */
    FreezePositionY = 2,
    /** Freeze motion along the Z-axis. */
    FreezePositionZ = 4,
    /** Freeze rotation along the X-axis. */
    FreezeRotationX = 8,
    /** Freeze rotation along the Y-axis. */
    FreezeRotationY = 16,
    /** Freeze rotation along the Z-axis. */
    FreezeRotationZ = 32
}

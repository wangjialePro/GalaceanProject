'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var engineMiniprogramAdapter = require('@galacean/engine-miniprogram-adapter');
var miniprogram = require('@galacean/engine-core/dist/miniprogram');

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

var DRACOWorker = /*#__PURE__*/ function() {
    function DRACOWorker(workerSourceURL, decoderWASMBinary) {
        var _this = this;
        // Record byteLength of each task.
        this._costs = {};
        // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.
        this._currentLoad = 0;
        this._callbacks = {};
        this._worker = new Worker(workerSourceURL);
        this._worker.onmessage = function(e) {
            var message = e.data;
            switch(message.type){
                case "decode":
                    _this._callbacks[message.id].resolve(message.geometry);
                    break;
                case "error":
                    _this._callbacks[message.id].reject(message);
                    break;
                default:
                    miniprogram.Logger.error('DRACOWorker: Unexpected message, "' + message.type + '"');
            }
        };
        if (decoderWASMBinary) {
            this._worker.postMessage({
                type: "init",
                decoderConfig: {
                    wasmBinary: decoderWASMBinary
                }
            });
        } else {
            this._worker.postMessage({
                type: "init",
                decoderConfig: {}
            });
        }
    }
    var _proto = DRACOWorker.prototype;
    _proto.setCosts = function setCosts(taskId, cost) {
        this._costs[taskId] = cost;
    };
    _proto.addCurrentLoad = function addCurrentLoad(cost) {
        this._currentLoad += cost;
    };
    _proto.setCallback = function setCallback(taskId, resolve, reject) {
        this._callbacks[taskId] = {
            resolve: resolve,
            reject: reject
        };
    };
    _proto.decode = function decode(taskId, taskConfig, buffer) {
        this._worker.postMessage({
            type: "decode",
            id: taskId,
            taskConfig: taskConfig,
            buffer: buffer
        }, [
            buffer
        ]);
    };
    _proto.releaseTask = function releaseTask(taskId) {
        this._currentLoad -= this._costs[taskId];
        delete this._callbacks[taskId];
        delete this._costs[taskId];
    };
    _create_class(DRACOWorker, [
        {
            key: "currentLoad",
            get: function get() {
                return this._currentLoad;
            }
        }
    ]);
    return DRACOWorker;
}();

var workerString = 'let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case "init":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case "decode":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: "decode", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: "error", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error("DRACODecoder worker: Unexpected geometry type.");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error("DRACODecoder worker: Decoding failed: " + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error("DRACODecoder: Unexpected index type.");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error("DRACODecoder: Unexpected attribute type.");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n';

var LIB_PATH = "https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/";
var JS_FILE = "draco_decoder_gltf.js";
var WASM_FILE = "draco_decoder_gltf.r3bin";
var WASM_WRAPPER_FILE = "draco_wasm_wrapper_gltf.js";
var DRACODecoder = /*#__PURE__*/ function() {
    function DRACODecoder(config) {
        if (config === void 0) config = {
            type: "wasm",
            workerLimit: 4
        };
        this.pool = [];
        this.workerLimit = Math.min(engineMiniprogramAdapter.navigator.hardwareConcurrency || 4, 4);
        this.currentTaskId = 1;
        this.taskCache = new WeakMap();
        if (config.workerLimit > this.workerLimit) {
            miniprogram.Logger.warn("DRACOWorkerPool: Can not initialize worker pool with limit:" + config.workerLimit);
        } else {
            var _config_workerLimit;
            this.workerLimit = (_config_workerLimit = config.workerLimit) != null ? _config_workerLimit : 4;
        }
        this.useJS = typeof WebAssembly !== "object" || config.type === "js";
        this.loadLibPromise = this.preloadLib();
    }
    var _proto = DRACODecoder.prototype;
    _proto.preloadLib = function preloadLib() {
        var _this = this;
        if (this.loadLibPromise) {
            return this.loadLibPromise;
        }
        return new Promise(function(resolve, reject) {
            if (_this.useJS) {
                miniprogram.request("" + LIB_PATH + JS_FILE, {
                    type: "text"
                }).then(function(jsSource) {
                    var body = [
                        jsSource,
                        workerString
                    ].join("\n");
                    var workerSourceURL = engineMiniprogramAdapter.URL.createObjectURL(new engineMiniprogramAdapter.Blob([
                        body
                    ]));
                    resolve({
                        workerSourceURL: workerSourceURL,
                        decoderWASMBinary: null
                    });
                }).catch(function(reason) {
                    reject(reason);
                });
            } else {
                Promise.all([
                    miniprogram.request("" + LIB_PATH + WASM_WRAPPER_FILE, {
                        type: "text"
                    }),
                    miniprogram.request("" + LIB_PATH + WASM_FILE, {
                        type: "arraybuffer"
                    })
                ]).then(function(resources) {
                    var wrapperSource = resources[0], decoderWASMBinary = resources[1];
                    var body = [
                        wrapperSource,
                        workerString
                    ].join("\n");
                    var workerSourceURL = engineMiniprogramAdapter.URL.createObjectURL(new engineMiniprogramAdapter.Blob([
                        body
                    ]));
                    resolve({
                        workerSourceURL: workerSourceURL,
                        decoderWASMBinary: decoderWASMBinary
                    });
                }).catch(function(reason) {
                    reject(reason);
                });
            }
        });
    };
    _proto.getWorker = function getWorker() {
        var _this = this;
        return this.preloadLib().then(function(worderResources) {
            if (_this.pool.length < _this.workerLimit) {
                var dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);
                _this.pool.push(dracoWorker);
            } else {
                _this.pool.sort(function(a, b) {
                    return a.currentLoad > b.currentLoad ? -1 : 1;
                });
            }
            return _this.pool[_this.pool.length - 1];
        });
    };
    _proto.decode = function decode(buffer, taskConfig) {
        var _this = this;
        var taskKey = JSON.stringify(taskConfig);
        // Check for an existing task using this buffer. A transferred buffer cannot be transferred.
        // again from this thread.
        if (this.taskCache.has(buffer)) {
            var cachedTask = this.taskCache.get(buffer);
            if (cachedTask.key === taskKey) {
                return cachedTask.promise;
            } else if (buffer.byteLength === 0) {
                // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.
                // Technically, it would be possible to wait for the previous task to complete,
                // transfer the buffer back, and decode again with the second configuration. That
                // is complex, and I don't know of any reason to decode a Draco buffer twice in
                // different ways, so this is left unimplemented.
                throw new Error("DRACODecoder: Unable to re-decode a buffer with different " + "settings. Buffer has already been transferred.");
            }
        }
        var taskId = this.currentTaskId++;
        var cost = buffer.byteLength;
        var taskWorker;
        var task = new Promise(function(resolve, reject) {
            _this.getWorker().then(function(worker) {
                taskWorker = worker;
                worker.setCosts(taskId, cost);
                worker.addCurrentLoad(cost);
                worker.setCallback(taskId, resolve, reject);
                worker.decode(taskId, taskConfig, buffer);
            }).catch(function(e) {
                reject(e);
            });
        });
        task.finally(function() {
            if (taskWorker && taskId) {
                taskWorker.releaseTask(taskId);
            }
        });
        this.taskCache.set(buffer, {
            key: taskKey,
            promise: task
        });
        return task;
    };
    return DRACODecoder;
}();

exports.DRACODecoder = DRACODecoder;

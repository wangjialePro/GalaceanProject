{"version":3,"file":"main.js","sources":["../../../node_modules/.pnpm/@swc+helpers@0.5.0/node_modules/@swc/helpers/esm/_create_class.js","../src/DRACOWorker.ts","../src/worker/worker.js","../src/decoder.ts"],"sourcesContent":["function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n\n        if (\"value\" in descriptor) descriptor.writable = true;\n\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nexport function _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n\n    return Constructor;\n}\nexport { _create_class as _ };\n","import { Logger } from \"@galacean/engine-core\";\n\nexport class DRACOWorker {\n  // Worker instance.\n  private _worker: Worker;\n  // Record byteLength of each task.\n  private _costs: { [taskId: number]: number } = {};\n  // The sum of bytelength that the worker is currently dealing with, in order to sort the workers.\n  private _currentLoad: number = 0;\n  private _callbacks: { [taskId: number]: IResolveReject } = {};\n  get currentLoad(): number {\n    return this._currentLoad;\n  }\n\n  constructor(workerSourceURL: string, decoderWASMBinary?: ArrayBuffer) {\n    this._worker = new Worker(workerSourceURL);\n    this._worker.onmessage = (e) => {\n      const message = e.data;\n      switch (message.type) {\n        case \"decode\":\n          this._callbacks[message.id].resolve(message.geometry);\n          break;\n\n        case \"error\":\n          this._callbacks[message.id].reject(message);\n          break;\n        default:\n          Logger.error('DRACOWorker: Unexpected message, \"' + message.type + '\"');\n      }\n    };\n    if (decoderWASMBinary) {\n      this._worker.postMessage({ type: \"init\", decoderConfig: { wasmBinary: decoderWASMBinary } });\n    } else {\n      this._worker.postMessage({ type: \"init\", decoderConfig: {} });\n    }\n  }\n\n  setCosts(taskId: number, cost: number) {\n    this._costs[taskId] = cost;\n  }\n\n  addCurrentLoad(cost: number) {\n    this._currentLoad += cost;\n  }\n\n  setCallback(taskId: number, resolve: (any) => void, reject: (any) => void) {\n    this._callbacks[taskId] = { resolve, reject };\n  }\n\n  decode(taskId: number, taskConfig: ITaskConfig, buffer: ArrayBuffer) {\n    this._worker.postMessage({ type: \"decode\", id: taskId, taskConfig, buffer }, [buffer]);\n  }\n\n  releaseTask(taskId: number) {\n    this._currentLoad -= this._costs[taskId];\n    delete this._callbacks[taskId];\n    delete this._costs[taskId];\n  }\n}\n\ninterface IResolveReject {\n  resolve: (any) => void;\n  reject: (any) => void;\n}\n\nexport interface ITaskConfig {\n  attributeIDs: { [attribute: string]: number };\n  attributeTypes: { [attribute: string]: string };\n  useUniqueIDs: boolean;\n  indexType: string;\n}\n","export default `let decoderPending;\nlet decoderConfig;\n\nonmessage = function(e) {\n  const message = e.data;\n\n  switch (message.type) {\n    case \"init\":\n      decoderConfig = message.decoderConfig;\n      decoderPending = new Promise(function(resolve /*, reject*/) {\n        decoderConfig.onModuleLoaded = function(draco) {\n          // Module is Promise-like. Wrap before resolving to avoid loop.\n          resolve({ draco: draco });\n        };\n        DracoDecoderModule(decoderConfig);\n      });\n      break;\n\n    case \"decode\":\n      const buffer = message.buffer;\n      const taskConfig = message.taskConfig;\n      decoderPending.then(module => {\n        const draco = module.draco;\n        const decoder = new draco.Decoder();\n        const decoderBuffer = new draco.DecoderBuffer();\n        decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength);\n        try {\n          const geometry = decodeGeometry(draco, decoder, decoderBuffer, taskConfig);\n          const buffers = geometry.attributes.map(attr => attr.array.buffer);\n          if (geometry.index) buffers.push(geometry.index.array.buffer);\n          self.postMessage({ type: \"decode\", id: message.id, geometry }, buffers);\n        } catch (error) {\n          console.error(error);\n          self.postMessage({ type: \"error\", id: message.id, error: error.message });\n        } finally {\n          draco.destroy(decoderBuffer);\n          draco.destroy(decoder);\n        }\n      });\n      break;\n  }\n};\n\nfunction decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {\n  const attributeIDs = taskConfig.attributeIDs;\n  const attributeTypes = taskConfig.attributeTypes;\n\n  let dracoGeometry;\n  let decodingStatus;\n\n  const geometryType = decoder.GetEncodedGeometryType(decoderBuffer);\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    dracoGeometry = new draco.Mesh();\n    decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry);\n  } else {\n    throw new Error(\"DRACODecoder worker: Unexpected geometry type.\");\n  }\n\n  if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n    throw new Error(\"DRACODecoder worker: Decoding failed: \" + decodingStatus.error_msg());\n  }\n\n  const geometry = { index: null, attributes: [] };\n\n  // Gather all vertex attributes.\n  for (let attributeName in attributeIDs) {\n    const attributeType = self[attributeTypes[attributeName]];\n\n    let attribute;\n    let attributeID;\n\n    // A Draco file may be created with default vertex attributes, whose attribute IDs\n    // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n    // a Draco file may contain a custom set of attributes, identified by known unique\n    // IDs. glTF files always do the latter, and .drc files typically do the former.\n    if (taskConfig.useUniqueIDs) {\n      attributeID = attributeIDs[attributeName];\n      attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n    } else {\n      attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n      if (attributeID === -1) continue;\n      attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n    }\n    geometry.attributes.push(decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute));\n  }\n  // Add index.\n  if (geometryType === draco.TRIANGULAR_MESH) {\n    // Generate mesh faces.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    let dataSize;\n    let ptr;\n    let index;\n    const indexType = self[taskConfig.indexType];\n\n    switch (indexType) {\n      case Uint16Array:\n        dataSize = numIndices * 2;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt16Array(dracoGeometry, dataSize, ptr);\n        index = new Uint16Array(draco.HEAPU16.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      case Uint32Array:\n        dataSize = numIndices * 4;\n        ptr = draco._malloc(dataSize);\n        decoder.GetTrianglesUInt32Array(dracoGeometry, dataSize, ptr);\n        index = new Uint32Array(draco.HEAPU32.buffer, ptr, numIndices).slice();\n        draco._free(ptr);\n        break;\n      default:\n        throw new Error(\"DRACODecoder: Unexpected index type.\");\n    }\n    geometry.index = { array: index, itemSize: 1 };\n  }\n  draco.destroy(dracoGeometry);\n  return geometry;\n}\n\nfunction decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n  const numComponents = attribute.num_components();\n  const numPoints = dracoGeometry.num_points();\n  const numValues = numPoints * numComponents;\n  let ptr;\n  let array;\n  let dataSize;\n  switch (attributeType) {\n    case Float32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_FLOAT32, dataSize, ptr);\n      array = new Float32Array(draco.HEAPF32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT8, numValues, ptr);\n      array = new Int8Array(draco.HEAP8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT16, dataSize, ptr);\n      array = new Int16Array(draco.HEAP16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Int32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_INT32, dataSize, ptr);\n      array = new Int32Array(draco.HEAP32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint8Array:\n      ptr = draco._malloc(numValues);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT8, numValues, ptr);\n      array = new Uint8Array(draco.HEAPU8.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint16Array:\n      dataSize = numValues * 2;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT16, dataSize, ptr);\n      array = new Uint16Array(draco.HEAPU16.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    case Uint32Array:\n      dataSize = numValues * 4;\n      ptr = draco._malloc(dataSize);\n      decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, draco.DT_UINT32, dataSize, ptr);\n      array = new Uint32Array(draco.HEAPU32.buffer, ptr, numValues).slice();\n      draco._free(ptr);\n      break;\n\n    default:\n      throw new Error(\"DRACODecoder: Unexpected attribute type.\");\n  }\n\n  return {\n    name: attributeName,\n    array: array,\n    itemSize: numComponents\n  };\n}\n`;","import { Logger, request } from \"@galacean/engine-core\";\n\nimport { DRACOWorker, ITaskConfig } from \"./DRACOWorker\";\n\nimport workerString from \"./worker/worker.js\";\n\nconst LIB_PATH = \"https://gw.alipayobjects.com/os/lib/alipay/draco-javascript/1.3.6/lib/\";\nconst JS_FILE = \"draco_decoder_gltf.js\";\n\nconst WASM_FILE = \"draco_decoder_gltf.r3bin\";\nconst WASM_WRAPPER_FILE = \"draco_wasm_wrapper_gltf.js\";\n\nexport class DRACODecoder {\n  private pool: DRACOWorker[] = [];\n  private workerLimit = Math.min(navigator.hardwareConcurrency || 4, 4);\n  private useJS: boolean;\n  private currentTaskId: number = 1;\n  private taskCache = new WeakMap();\n  private loadLibPromise: Promise<any>;\n\n  constructor(config: IDecoderConfig = { type: \"wasm\", workerLimit: 4 }) {\n    if (config.workerLimit > this.workerLimit) {\n      Logger.warn(\"DRACOWorkerPool: Can not initialize worker pool with limit:\" + config.workerLimit);\n    } else {\n      this.workerLimit = config.workerLimit ?? 4;\n    }\n    this.useJS = typeof WebAssembly !== \"object\" || config.type === \"js\";\n    this.loadLibPromise = this.preloadLib();\n  }\n\n  private preloadLib(): Promise<any> {\n    if (this.loadLibPromise) {\n      return this.loadLibPromise;\n    }\n\n    return new Promise((resolve, reject) => {\n      if (this.useJS) {\n        request(`${LIB_PATH}${JS_FILE}`, { type: \"text\" })\n          .then((jsSource) => {\n            const body = [jsSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary: null });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      } else {\n        Promise.all([\n          request(`${LIB_PATH}${WASM_WRAPPER_FILE}`, { type: \"text\" }),\n          request(`${LIB_PATH}${WASM_FILE}`, { type: \"arraybuffer\" })\n        ])\n          .then((resources) => {\n            const [wrapperSource, decoderWASMBinary] = resources;\n            const body = [wrapperSource, workerString].join(\"\\n\");\n            const workerSourceURL = URL.createObjectURL(new Blob([body]));\n            resolve({ workerSourceURL, decoderWASMBinary });\n          })\n          .catch((reason) => {\n            reject(reason);\n          });\n      }\n    });\n  }\n\n  private getWorker(): Promise<DRACOWorker> {\n    return this.preloadLib().then((worderResources) => {\n      if (this.pool.length < this.workerLimit) {\n        const dracoWorker = new DRACOWorker(worderResources.workerSourceURL, worderResources.decoderWASMBinary);\n        this.pool.push(dracoWorker);\n      } else {\n        this.pool.sort(function (a, b) {\n          return a.currentLoad > b.currentLoad ? -1 : 1;\n        });\n      }\n      return this.pool[this.pool.length - 1];\n    });\n  }\n\n  decode(buffer: ArrayBuffer, taskConfig: ITaskConfig): Promise<any> {\n    const taskKey = JSON.stringify(taskConfig);\n\n    // Check for an existing task using this buffer. A transferred buffer cannot be transferred.\n    // again from this thread.\n    if (this.taskCache.has(buffer)) {\n      const cachedTask = this.taskCache.get(buffer);\n      if (cachedTask.key === taskKey) {\n        return cachedTask.promise;\n      } else if (buffer.byteLength === 0) {\n        // After using transferable to transfer data, the data in the original environment will be cleared, so it is judged that byteLength is 0, which means it has been transferred.\n        // Technically, it would be possible to wait for the previous task to complete,\n        // transfer the buffer back, and decode again with the second configuration. That\n        // is complex, and I don't know of any reason to decode a Draco buffer twice in\n        // different ways, so this is left unimplemented.\n        throw new Error(\n          \"DRACODecoder: Unable to re-decode a buffer with different \" +\n            \"settings. Buffer has already been transferred.\"\n        );\n      }\n    }\n\n    const taskId = this.currentTaskId++;\n    const cost = buffer.byteLength;\n    let taskWorker;\n    const task = new Promise((resolve, reject) => {\n      this.getWorker()\n        .then((worker) => {\n          taskWorker = worker;\n          worker.setCosts(taskId, cost);\n          worker.addCurrentLoad(cost);\n\n          worker.setCallback(taskId, resolve, reject);\n          worker.decode(taskId, taskConfig, buffer);\n        })\n        .catch((e) => {\n          reject(e);\n        });\n    });\n    task.finally(() => {\n      if (taskWorker && taskId) {\n        taskWorker.releaseTask(taskId);\n      }\n    });\n\n    this.taskCache.set(buffer, {\n      key: taskKey,\n      promise: task\n    });\n    return task;\n  }\n}\n\ninterface IDecoderConfig {\n  type?: \"js\" | \"wasm\";\n  workerLimit?: number;\n}\n"],"names":["DRACOWorker","workerSourceURL","decoderWASMBinary","_costs","_currentLoad","_callbacks","_worker","Worker","onmessage","e","message","data","type","id","resolve","geometry","reject","Logger","error","postMessage","decoderConfig","wasmBinary","setCosts","taskId","cost","addCurrentLoad","setCallback","decode","taskConfig","buffer","releaseTask","currentLoad","LIB_PATH","JS_FILE","WASM_FILE","WASM_WRAPPER_FILE","DRACODecoder","config","workerLimit","pool","Math","min","navigator","hardwareConcurrency","currentTaskId","taskCache","WeakMap","warn","useJS","WebAssembly","loadLibPromise","preloadLib","Promise","request","then","jsSource","body","workerString","join","URL","createObjectURL","Blob","catch","reason","all","resources","wrapperSource","getWorker","worderResources","length","dracoWorker","push","sort","a","b","taskKey","JSON","stringify","has","cachedTask","get","key","promise","byteLength","Error","taskWorker","task","worker","finally","set"],"mappings":"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"}
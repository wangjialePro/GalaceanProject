import { resourceLoader, AssetType, AssetPromise, AnimatorController, AnimatorControllerLayer, AnimatorStateMachine, AnimatorStateTransition, Loader, TextureCube, TextureFilterMode, TextureCubeFace, AmbientLight, DiffuseMode, Font, IndexFormat, VertexElementFormat, DirectLight, PointLight, SpotLight, PBRMaterial, TextureCoordinate, Logger, RenderFace, PBRSpecularMaterial, UnlitMaterial, AnimationClip, InterpolationType, AnimationFloatArrayCurve, Keyframe, AnimationQuaternionCurve, AnimationVector3Curve, SkinnedMeshRenderer, Transform, request, Entity, VertexElement, Buffer, BufferBindFlag, BufferUsage, BlendShape, ModelMesh, Camera, Animator, BlinnPhongMaterial, MeshRenderer, Skin, TextureWrapMode as TextureWrapMode$1, Texture2D, EngineObject, TextureFormat, PBRBaseMaterial, Shader, ParticleRenderer, Script, SpriteMask, SpriteRenderer, TextRenderer, AnimationEvent, AnimationColorCurve, AnimationVector4Curve, AnimationVector2Curve, AnimationArrayCurve, AnimationFloatCurve, Scene, SpriteAtlas, Sprite, BackgroundMode, SkyBoxMaterial, PrimitiveMesh } from '@galacean/engine-core';
import { SphericalHarmonics3, Vector2, Vector3, Vector4, Color, Quaternion, Matrix, Rect } from '@galacean/engine-math';
import { DRACODecoder } from '@galacean/engine-draco';
import { GLCompressedTextureInternalFormat } from '@galacean/engine-rhi-webgl';

function _extends() {
    _extends = Object.assign || function assign(target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }

        return target;
    };

    return _extends.apply(this, arguments);
}

function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;

        return o;
    };

    return _set_prototype_of(o, p);
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });

    if (superClass) _set_prototype_of(subClass, superClass);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var AnimatorControllerLoader = /*#__PURE__*/ function(Loader) {
    _inherits(AnimatorControllerLoader, Loader);
    function AnimatorControllerLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = AnimatorControllerLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                var animatorController = new AnimatorController();
                var layers = data.layers;
                var promises = [];
                layers.forEach(function(layerData, layerIndex) {
                    var name = layerData.name, blendingMode = layerData.blendingMode, weight = layerData.weight, stateMachineData = layerData.stateMachine;
                    var layer = new AnimatorControllerLayer(name);
                    layer.blendingMode = blendingMode;
                    layer.weight = weight;
                    if (stateMachineData) {
                        var states = stateMachineData.states;
                        var stateMachine = layer.stateMachine = new AnimatorStateMachine();
                        states.forEach(function(stateData, stateIndex) {
                            var name = stateData.name, speed = stateData.speed, wrapMode = stateData.wrapMode, clipStartNormalizedTime = stateData.clipStartNormalizedTime, clipEndNormalizedTime = stateData.clipEndNormalizedTime, isDefaultState = stateData.isDefaultState, clipData = stateData.clip;
                            var state = stateMachine.addState(name);
                            isDefaultState && (stateMachine.defaultState = state);
                            state.speed = speed;
                            state.wrapMode = wrapMode;
                            state.clipStartTime = clipStartNormalizedTime;
                            state.clipEndTime = clipEndNormalizedTime;
                            if (clipData) {
                                promises.push(new Promise(function(resolve) {
                                    //@ts-ignore
                                    resourceManager.getResourceByRef(clipData).then(function(clip) {
                                        resolve({
                                            layerIndex: layerIndex,
                                            stateIndex: stateIndex,
                                            clip: clip
                                        });
                                    });
                                }));
                            }
                        });
                        states.forEach(function(stateData) {
                            var name = stateData.name, transitions = stateData.transitions;
                            transitions.forEach(function(transitionData) {
                                var targetStateName = transitionData.targetStateName, duration = transitionData.duration, offset = transitionData.offset, exitTime = transitionData.exitTime;
                                var sourceState = stateMachine.findStateByName(name);
                                var destState = stateMachine.findStateByName(targetStateName);
                                var transition = new AnimatorStateTransition();
                                transition.destinationState = destState;
                                transition.duration = duration;
                                transition.exitTime = exitTime;
                                transition.offset = offset;
                                sourceState.addTransition(transition);
                            });
                        });
                    }
                    animatorController.addLayer(layer);
                });
                Promise.all(promises).then(function(clipData) {
                    clipData.forEach(function(data) {
                        var layerIndex = data.layerIndex, stateIndex = data.stateIndex, clip = data.clip;
                        animatorController.layers[layerIndex].stateMachine.states[stateIndex].clip = clip;
                    });
                    resolve(animatorController);
                });
            }).catch(reject);
        });
    };
    return AnimatorControllerLoader;
}(Loader);
AnimatorControllerLoader = __decorate([
    resourceLoader(AssetType.AnimatorController, [
        "json"
    ], false)
], AnimatorControllerLoader);

function isBase64(url) {
    return /^data:(.+?);base64,/.test(url);
}
var BufferLoader = /*#__PURE__*/ function(Loader) {
    _inherits(BufferLoader, Loader);
    function BufferLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = BufferLoader.prototype;
    _proto.load = function load(item) {
        var url = item.url;
        if (isBase64(url)) {
            return new AssetPromise(function(resolve) {
                var base64Str = url.slice(13 + RegExp.$1.length);
                var result = Uint8Array.from(atob(base64Str), function(c) {
                    return c.charCodeAt(0);
                });
                resolve(result.buffer);
            });
        }
        return this.request(url, _extends({}, item, {
            type: "arraybuffer"
        }));
    };
    return BufferLoader;
}(Loader);
BufferLoader = __decorate([
    resourceLoader(AssetType.Buffer, [
        "bin",
        "r3bin"
    ], false)
], BufferLoader);

var EnvLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EnvLoader, Loader);
    function EnvLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = EnvLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(arraybuffer) {
                var _ref;
                var shArray = new Float32Array(arraybuffer, 0, 27);
                var shByteLength = 27 * 4;
                var size = (_ref = new Uint16Array(arraybuffer, shByteLength, 1)) == null ? void 0 : _ref[0];
                var texture = new TextureCube(resourceManager.engine, size);
                texture.filterMode = TextureFilterMode.Trilinear;
                var mipmapCount = texture.mipmapCount;
                var offset = shByteLength + 2;
                for(var mipLevel = 0; mipLevel < mipmapCount; mipLevel++){
                    var mipSize = size >> mipLevel;
                    for(var face = 0; face < 6; face++){
                        var dataSize = mipSize * mipSize * 4;
                        var data = new Uint8Array(arraybuffer, offset, dataSize);
                        offset += dataSize;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, data, mipLevel);
                    }
                }
                var ambientLight = new AmbientLight();
                var sh = new SphericalHarmonics3();
                ambientLight.diffuseMode = DiffuseMode.SphericalHarmonics;
                sh.copyFromArray(shArray);
                ambientLight.diffuseSphericalHarmonics = sh;
                ambientLight.specularTexture = texture;
                ambientLight.specularTextureDecodeRGBM = true;
                resolve(ambientLight);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return EnvLoader;
}(Loader);
EnvLoader = __decorate([
    resourceLoader(AssetType.Env, [
        "env"
    ])
], EnvLoader);

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) resolve(value);
    else Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;

        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
        });
    };
}

var FontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(FontLoader, Loader);
    function FontLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = FontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "json"
            }).then(function(data) {
                var fontName = data.fontName, fontUrl = data.fontUrl;
                if (fontUrl) {
                    _this._registerFont(fontName, fontUrl).then(function() {
                        var font = new Font(resourceManager.engine, fontName);
                        resolve(font);
                    }).catch(function(e) {
                        reject("load font " + fontUrl + " fail");
                    });
                } else {
                    var font = new Font(resourceManager.engine, fontName);
                    resolve(font);
                }
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return FontLoader;
}(Loader);
FontLoader = __decorate([
    resourceLoader(AssetType.Font, [
        "font"
    ], false)
], FontLoader);

/**
 * @internal
 */ var ParserContext = /*#__PURE__*/ function() {
    function ParserContext(url) {
        this.hasSkinned = false;
        /** chain asset promise */ this.chainPromises = [];
        this.accessorBufferCache = {};
        this.texturesPromiseInfo = new PromiseInfo();
        this.materialsPromiseInfo = new PromiseInfo();
        this.meshesPromiseInfo = new PromiseInfo();
        this.animationClipsPromiseInfo = new PromiseInfo();
        this.defaultSceneRootPromiseInfo = new PromiseInfo();
        this.masterPromiseInfo = new PromiseInfo();
        this.promiseMap = {};
        var promiseMap = this.promiseMap;
        promiseMap["" + url + "?q=textures"] = this._initPromiseInfo(this.texturesPromiseInfo);
        promiseMap["" + url + "?q=materials"] = this._initPromiseInfo(this.materialsPromiseInfo);
        promiseMap["" + url + "?q=meshes"] = this._initPromiseInfo(this.meshesPromiseInfo);
        promiseMap["" + url + "?q=animations"] = this._initPromiseInfo(this.animationClipsPromiseInfo);
        promiseMap["" + url + "?q=defaultSceneRoot"] = this._initPromiseInfo(this.defaultSceneRootPromiseInfo);
        promiseMap["" + url] = this._initPromiseInfo(this.masterPromiseInfo);
    }
    var _proto = ParserContext.prototype;
    _proto._initPromiseInfo = function _initPromiseInfo(promiseInfo) {
        var promise = new AssetPromise(function(resolve, reject, setProgress, onCancel) {
            promiseInfo.resolve = resolve;
            promiseInfo.reject = reject;
            promiseInfo.setProgress = setProgress;
            promiseInfo.onCancel = onCancel;
        });
        promiseInfo.promise = promise;
        return promise;
    };
    return ParserContext;
}();
/**
 * @internal
 */ var BufferInfo = function BufferInfo(data, interleaved, stride) {
    this.data = data;
    this.interleaved = interleaved;
    this.stride = stride;
    this.vertexBindingInfos = {};
};
/**
 * @internal
 */ var PromiseInfo = function PromiseInfo() {
};

/**
 * Module for glTF 2.0 Interface
 */ var AccessorComponentType;
(function(AccessorComponentType) {
    AccessorComponentType[AccessorComponentType[/**
   * Byte
   */ "BYTE"] = 5120] = "BYTE";
    AccessorComponentType[AccessorComponentType[/**
   * Unsigned Byte
   */ "UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
    AccessorComponentType[AccessorComponentType[/**
   * Short
   */ "SHORT"] = 5122] = "SHORT";
    AccessorComponentType[AccessorComponentType[/**
   * Unsigned Short
   */ "UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
    AccessorComponentType[AccessorComponentType[/**
   * Unsigned Int
   */ "UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
    AccessorComponentType[AccessorComponentType[/**
   * Float
   */ "FLOAT"] = 5126] = "FLOAT";
})(AccessorComponentType || (AccessorComponentType = {}));
var AccessorType;
(function(AccessorType) {
    AccessorType[/**
   * Scalar
   */ "SCALAR"] = "SCALAR";
    AccessorType[/**
   * Vector2
   */ "VEC2"] = "VEC2";
    AccessorType[/**
   * Vector3
   */ "VEC3"] = "VEC3";
    AccessorType[/**
   * Vector4
   */ "VEC4"] = "VEC4";
    AccessorType[/**
   * Matrix2x2
   */ "MAT2"] = "MAT2";
    AccessorType[/**
   * Matrix3x3
   */ "MAT3"] = "MAT3";
    AccessorType[/**
   * Matrix4x4
   */ "MAT4"] = "MAT4";
})(AccessorType || (AccessorType = {}));
var AnimationChannelTargetPath;
(function(AnimationChannelTargetPath) {
    AnimationChannelTargetPath[/**
   * Translation
   */ "TRANSLATION"] = "translation";
    AnimationChannelTargetPath[/**
   * Rotation
   */ "ROTATION"] = "rotation";
    AnimationChannelTargetPath[/**
   * Scale
   */ "SCALE"] = "scale";
    AnimationChannelTargetPath[/**
   * Weights
   */ "WEIGHTS"] = "weights";
})(AnimationChannelTargetPath || (AnimationChannelTargetPath = {}));
var AnimationSamplerInterpolation;
(function(AnimationSamplerInterpolation) {
    AnimationSamplerInterpolation[/**
   * The animated values are linearly interpolated between keyframes
   */ "Linear"] = "LINEAR";
    AnimationSamplerInterpolation[/**
   * The animated values remain constant to the output of the first keyframe, until the next keyframe
   */ "Step"] = "STEP";
    AnimationSamplerInterpolation[/**
   * The animation's interpolation is computed using a cubic spline with specified tangents
   */ "CubicSpine"] = "CUBICSPLINE";
})(AnimationSamplerInterpolation || (AnimationSamplerInterpolation = {}));
var CameraType;
(function(CameraType) {
    CameraType[/**
   * A perspective camera containing properties to create a perspective projection matrix
   */ "PERSPECTIVE"] = "perspective";
    CameraType[/**
   * An orthographic camera containing properties to create an orthographic projection matrix
   */ "ORTHOGRAPHIC"] = "orthographic";
})(CameraType || (CameraType = {}));
var ImageMimeType;
(function(ImageMimeType) {
    ImageMimeType[/**
   * JPEG Mime-type
   */ "JPEG"] = "image/jpeg";
    ImageMimeType[/**
   * PNG Mime-type
   */ "PNG"] = "image/png";
})(ImageMimeType || (ImageMimeType = {}));
var MaterialAlphaMode;
(function(MaterialAlphaMode) {
    MaterialAlphaMode[/**
   * The alpha value is ignored and the rendered output is fully opaque
   */ "OPAQUE"] = "OPAQUE";
    MaterialAlphaMode[/**
   * The rendered output is either fully opaque or fully transparent depending on the alpha value and the specified alpha cutoff value
   */ "MASK"] = "MASK";
    MaterialAlphaMode[/**
   * The alpha value is used to composite the source and destination areas. The rendered output is combined with the background using the normal painting operation (i.e. the Porter and Duff over operator)
   */ "BLEND"] = "BLEND";
})(MaterialAlphaMode || (MaterialAlphaMode = {}));
var TextureMagFilter;
(function(TextureMagFilter) {
    TextureMagFilter[TextureMagFilter[/**
   * Nearest
   */ "NEAREST"] = 9728] = "NEAREST";
    TextureMagFilter[TextureMagFilter[/**
   * Linear
   */ "LINEAR"] = 9729] = "LINEAR";
})(TextureMagFilter || (TextureMagFilter = {}));
var TextureMinFilter;
(function(TextureMinFilter) {
    TextureMinFilter[TextureMinFilter[/**
   * Nearest
   */ "NEAREST"] = 9728] = "NEAREST";
    TextureMinFilter[TextureMinFilter[/**
   * Linear
   */ "LINEAR"] = 9729] = "LINEAR";
    TextureMinFilter[TextureMinFilter[/**
   * Nearest Mip-Map Nearest
   */ "NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter[/**
   * Linear Mipmap Nearest
   */ "LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
    TextureMinFilter[TextureMinFilter[/**
   * Nearest Mipmap Linear
   */ "NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
    TextureMinFilter[TextureMinFilter[/**
   * Linear Mipmap Linear
   */ "LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
})(TextureMinFilter || (TextureMinFilter = {}));
var TextureWrapMode;
(function(TextureWrapMode) {
    TextureWrapMode[TextureWrapMode[/**
   * Clamp to Edge
   */ "CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
    TextureWrapMode[TextureWrapMode[/**
   * Mirrored Repeat
   */ "MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
    TextureWrapMode[TextureWrapMode[/**
   * Repeat
   */ "REPEAT"] = 10497] = "REPEAT";
})(TextureWrapMode || (TextureWrapMode = {}));

/**
 * @internal
 */ var GLTFUtil = /*#__PURE__*/ function() {
    function GLTFUtil() {}
    GLTFUtil.floatBufferToVector2Array = function floatBufferToVector2Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 2);
        for(var i = 0; i < bufferLen; i += 2){
            array[i / 2] = new Vector2(buffer[i], buffer[i + 1]);
        }
        return array;
    };
    GLTFUtil.floatBufferToVector3Array = function floatBufferToVector3Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 3);
        for(var i = 0; i < bufferLen; i += 3){
            array[i / 3] = new Vector3(buffer[i], buffer[i + 1], buffer[i + 2]);
        }
        return array;
    };
    GLTFUtil.floatBufferToVector4Array = function floatBufferToVector4Array(buffer) {
        var bufferLen = buffer.length;
        var array = new Array(bufferLen / 4);
        for(var i = 0; i < bufferLen; i += 4){
            array[i / 4] = new Vector4(buffer[i], buffer[i + 1], buffer[i + 2], buffer[i + 3]);
        }
        return array;
    };
    GLTFUtil.floatBufferToColorArray = function floatBufferToColorArray(buffer, isColor3) {
        var bufferLen = buffer.length;
        var colors = new Array(bufferLen / (isColor3 ? 3 : 4));
        if (isColor3) {
            for(var i = 0; i < bufferLen; i += 3){
                colors[i / 3] = new Color(buffer[i], buffer[i + 1], buffer[i + 2], 1.0);
            }
        } else {
            for(var i1 = 0; i1 < bufferLen; i1 += 4){
                colors[i1 / 4] = new Color(buffer[i1], buffer[i1 + 1], buffer[i1 + 2], buffer[i1 + 3]);
            }
        }
        return colors;
    };
    /**
   * Parse binary text for glb loader.
   */ GLTFUtil.decodeText = function decodeText(array) {
        if (typeof TextDecoder !== "undefined") {
            return new TextDecoder().decode(array);
        }
        // TextDecoder polyfill
        var s = "";
        for(var i = 0, il = array.length; i < il; i++){
            s += String.fromCharCode(array[i]);
        }
        return decodeURIComponent(encodeURIComponent(s));
    };
    /**
   * Get the number of bytes occupied by accessor type.
   */ GLTFUtil.getAccessorTypeSize = function getAccessorTypeSize(accessorType) {
        switch(accessorType){
            case AccessorType.SCALAR:
                return 1;
            case AccessorType.VEC2:
                return 2;
            case AccessorType.VEC3:
                return 3;
            case AccessorType.VEC4:
                return 4;
            case AccessorType.MAT2:
                return 4;
            case AccessorType.MAT3:
                return 9;
            case AccessorType.MAT4:
                return 16;
        }
    };
    /**
   * Get the TypedArray corresponding to the component type.
   */ GLTFUtil.getComponentType = function getComponentType(componentType) {
        switch(componentType){
            case AccessorComponentType.BYTE:
                return Int8Array;
            case AccessorComponentType.UNSIGNED_BYTE:
                return Uint8Array;
            case AccessorComponentType.SHORT:
                return Int16Array;
            case AccessorComponentType.UNSIGNED_SHORT:
                return Uint16Array;
            case AccessorComponentType.UNSIGNED_INT:
                return Uint32Array;
            case AccessorComponentType.FLOAT:
                return Float32Array;
        }
    };
    GLTFUtil.getNormalizedComponentScale = function getNormalizedComponentScale(componentType) {
        // Reference: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data
        switch(componentType){
            case AccessorComponentType.BYTE:
                return 1 / 127;
            case AccessorComponentType.UNSIGNED_BYTE:
                return 1 / 255;
            case AccessorComponentType.SHORT:
                return 1 / 32767;
            case AccessorComponentType.UNSIGNED_SHORT:
                return 1 / 65535;
            default:
                throw new Error("Galacean.GLTFLoader: Unsupported normalized accessor component type.");
        }
    };
    GLTFUtil.getAccessorBuffer = function getAccessorBuffer(context, gltf, accessor) {
        var buffers = context.buffers;
        var bufferViews = gltf.bufferViews;
        var componentType = accessor.componentType;
        var bufferView = bufferViews[accessor.bufferView];
        var buffer = buffers[bufferView.buffer];
        var bufferByteOffset = bufferView.byteOffset || 0;
        var byteOffset = accessor.byteOffset || 0;
        var TypedArray = GLTFUtil.getComponentType(componentType);
        var dataElmentSize = GLTFUtil.getAccessorTypeSize(accessor.type);
        var dataElementBytes = TypedArray.BYTES_PER_ELEMENT;
        var elementStride = dataElmentSize * dataElementBytes;
        var accessorCount = accessor.count;
        var bufferStride = bufferView.byteStride;
        var bufferInfo;
        // According to the glTF official documentation only byteStride not undefined is allowed
        if (bufferStride !== undefined && bufferStride !== elementStride) {
            var bufferSlice = Math.floor(byteOffset / bufferStride);
            var bufferCacheKey = accessor.bufferView + ":" + componentType + ":" + bufferSlice + ":" + accessorCount;
            var accessorBufferCache = context.accessorBufferCache;
            bufferInfo = accessorBufferCache[bufferCacheKey];
            if (!bufferInfo) {
                var offset = bufferByteOffset + bufferSlice * bufferStride;
                var count = accessorCount * (bufferStride / dataElementBytes);
                var data = new TypedArray(buffer, offset, count);
                accessorBufferCache[bufferCacheKey] = bufferInfo = new BufferInfo(data, true, bufferStride);
            }
        } else {
            var offset1 = bufferByteOffset + byteOffset;
            var count1 = accessorCount * dataElmentSize;
            var data1 = new TypedArray(buffer, offset1, count1);
            bufferInfo = new BufferInfo(data1, false, elementStride);
        }
        if (accessor.sparse) {
            var data2 = GLTFUtil.processingSparseData(gltf, accessor, buffers, bufferInfo.data);
            bufferInfo = new BufferInfo(data2, false, bufferInfo.stride);
        }
        return bufferInfo;
    };
    /**
   * @deprecated
   * Get accessor data.
   */ GLTFUtil.getAccessorData = function getAccessorData(gltf, accessor, buffers) {
        var bufferViews = gltf.bufferViews;
        var bufferView = bufferViews[accessor.bufferView];
        var arrayBuffer = buffers[bufferView.buffer];
        var accessorByteOffset = accessor.hasOwnProperty("byteOffset") ? accessor.byteOffset : 0;
        var bufferViewByteOffset = bufferView.hasOwnProperty("byteOffset") ? bufferView.byteOffset : 0;
        var byteOffset = accessorByteOffset + bufferViewByteOffset;
        var accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);
        var length = accessorTypeSize * accessor.count;
        var _bufferView_byteStride;
        var byteStride = (_bufferView_byteStride = bufferView.byteStride) != null ? _bufferView_byteStride : 0;
        var arrayType = GLTFUtil.getComponentType(accessor.componentType);
        var uint8Array;
        if (byteStride) {
            var accessorByteSize = accessorTypeSize * arrayType.BYTES_PER_ELEMENT;
            uint8Array = new Uint8Array(accessor.count * accessorByteSize);
            var originalBufferView = new Uint8Array(arrayBuffer, bufferViewByteOffset, bufferView.byteLength);
            for(var i = 0; i < accessor.count; i++){
                for(var j = 0; j < accessorByteSize; j++){
                    uint8Array[i * accessorByteSize + j] = originalBufferView[i * byteStride + accessorByteOffset + j];
                }
            }
        } else {
            uint8Array = new Uint8Array(arrayBuffer.slice(byteOffset, byteOffset + length * arrayType.BYTES_PER_ELEMENT));
        }
        var typedArray = new arrayType(uint8Array.buffer);
        if (accessor.sparse) {
            var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
            var indicesBufferView = bufferViews[indices.bufferView];
            var valuesBufferView = bufferViews[values.bufferView];
            var indicesArrayBuffer = buffers[indicesBufferView.buffer];
            var valuesArrayBuffer = buffers[valuesBufferView.buffer];
            var _indices_byteOffset, _indicesBufferView_byteOffset;
            var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesBufferView_byteOffset = indicesBufferView.byteOffset) != null ? _indicesBufferView_byteOffset : 0);
            var indicesByteLength = indicesBufferView.byteLength;
            var _values_byteOffset, _valuesBufferView_byteOffset;
            var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesBufferView_byteOffset = valuesBufferView.byteOffset) != null ? _valuesBufferView_byteOffset : 0);
            var valuesByteLength = valuesBufferView.byteLength;
            var indicesType = GLTFUtil.getComponentType(indices.componentType);
            var indicesArray = new indicesType(indicesArrayBuffer, indicesByteOffset, indicesByteLength / indicesType.BYTES_PER_ELEMENT);
            var valuesArray = new arrayType(valuesArrayBuffer, valuesByteOffset, valuesByteLength / arrayType.BYTES_PER_ELEMENT);
            for(var i1 = 0; i1 < count; i1++){
                var replaceIndex = indicesArray[i1];
                for(var j1 = 0; j1 < accessorTypeSize; j1++){
                    typedArray[replaceIndex * accessorTypeSize + j1] = valuesArray[i1 * accessorTypeSize + j1];
                }
            }
        }
        return typedArray;
    };
    GLTFUtil.getBufferViewData = function getBufferViewData(bufferView, buffers) {
        var buffer = bufferView.buffer, _bufferView_byteOffset = bufferView.byteOffset, byteOffset = _bufferView_byteOffset === void 0 ? 0 : _bufferView_byteOffset, byteLength = bufferView.byteLength;
        var arrayBuffer = buffers[buffer];
        return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    };
    /**
   * Get accessor data.
   */ GLTFUtil.processingSparseData = function processingSparseData(gltf, accessor, buffers, originData) {
        var bufferViews = gltf.bufferViews;
        var accessorTypeSize = GLTFUtil.getAccessorTypeSize(accessor.type);
        var TypedArray = GLTFUtil.getComponentType(accessor.componentType);
        var data = originData.slice();
        var _accessor_sparse = accessor.sparse, count = _accessor_sparse.count, indices = _accessor_sparse.indices, values = _accessor_sparse.values;
        var indicesBufferView = bufferViews[indices.bufferView];
        var valuesBufferView = bufferViews[values.bufferView];
        var indicesArrayBuffer = buffers[indicesBufferView.buffer];
        var valuesArrayBuffer = buffers[valuesBufferView.buffer];
        var _indices_byteOffset, _indicesBufferView_byteOffset;
        var indicesByteOffset = ((_indices_byteOffset = indices.byteOffset) != null ? _indices_byteOffset : 0) + ((_indicesBufferView_byteOffset = indicesBufferView.byteOffset) != null ? _indicesBufferView_byteOffset : 0);
        var indicesByteLength = indicesBufferView.byteLength;
        var _values_byteOffset, _valuesBufferView_byteOffset;
        var valuesByteOffset = ((_values_byteOffset = values.byteOffset) != null ? _values_byteOffset : 0) + ((_valuesBufferView_byteOffset = valuesBufferView.byteOffset) != null ? _valuesBufferView_byteOffset : 0);
        var valuesByteLength = valuesBufferView.byteLength;
        var IndexTypeArray = GLTFUtil.getComponentType(indices.componentType);
        var indicesArray = new IndexTypeArray(indicesArrayBuffer, indicesByteOffset, indicesByteLength / IndexTypeArray.BYTES_PER_ELEMENT);
        var valuesArray = new TypedArray(valuesArrayBuffer, valuesByteOffset, valuesByteLength / TypedArray.BYTES_PER_ELEMENT);
        for(var i = 0; i < count; i++){
            var replaceIndex = indicesArray[i];
            for(var j = 0; j < accessorTypeSize; j++){
                data[replaceIndex * accessorTypeSize + j] = valuesArray[i * accessorTypeSize + j];
            }
        }
        return data;
    };
    GLTFUtil.getIndexFormat = function getIndexFormat(type) {
        switch(type){
            case AccessorComponentType.UNSIGNED_BYTE:
                return IndexFormat.UInt8;
            case AccessorComponentType.UNSIGNED_SHORT:
                return IndexFormat.UInt16;
            case AccessorComponentType.UNSIGNED_INT:
                return IndexFormat.UInt32;
        }
    };
    GLTFUtil.getElementFormat = function getElementFormat(type, size, normalized) {
        if (normalized === void 0) normalized = false;
        if (type == AccessorComponentType.FLOAT) {
            switch(size){
                case 1:
                    return VertexElementFormat.Float;
                case 2:
                    return VertexElementFormat.Vector2;
                case 3:
                    return VertexElementFormat.Vector3;
                case 4:
                    return VertexElementFormat.Vector4;
            }
        }
        if (type == AccessorComponentType.SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedShort2 : VertexElementFormat.Short2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedShort4 : VertexElementFormat.Short4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_SHORT) {
            switch(size){
                case 2:
                    return normalized ? VertexElementFormat.NormalizedUShort2 : VertexElementFormat.UShort2;
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUShort4 : VertexElementFormat.UShort4;
            }
        }
        if (type == AccessorComponentType.BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedByte4 : VertexElementFormat.Byte4;
            }
        }
        if (type == AccessorComponentType.UNSIGNED_BYTE) {
            switch(size){
                case 2:
                case 3:
                case 4:
                    return normalized ? VertexElementFormat.NormalizedUByte4 : VertexElementFormat.UByte4;
            }
        }
    };
    /**
   * Load image buffer
   */ GLTFUtil.loadImageBuffer = function loadImageBuffer(imageBuffer, type) {
        return new Promise(function(resolve, reject) {
            var blob = new window.Blob([
                imageBuffer
            ], {
                type: type
            });
            var img = new Image();
            img.onerror = function() {
                reject(new Error("Failed to load image buffer"));
            };
            img.onload = function() {
                // Call requestAnimationFrame to avoid iOS's bug.
                requestAnimationFrame(function() {
                    resolve(img);
                    img.onload = null;
                    img.onerror = null;
                    img.onabort = null;
                });
            };
            img.crossOrigin = "anonymous";
            img.src = URL.createObjectURL(blob);
        });
    };
    GLTFUtil.isAbsoluteUrl = function isAbsoluteUrl(url) {
        return /^(?:http|blob|data:|\/)/.test(url);
    };
    GLTFUtil.parseRelativeUrl = function parseRelativeUrl(baseUrl, relativeUrl) {
        if (GLTFUtil.isAbsoluteUrl(relativeUrl)) {
            return relativeUrl;
        }
        return baseUrl.substring(0, baseUrl.lastIndexOf("/") + 1) + GLTFUtil._formatRelativePath(relativeUrl);
    };
    /**
   * Parse the glb format.
   */ GLTFUtil.parseGLB = function parseGLB(glb) {
        var UINT32_LENGTH = 4;
        var GLB_HEADER_MAGIC = 0x46546c67; // 'glTF'
        var GLB_HEADER_LENGTH = 12;
        var GLB_CHUNK_TYPES = {
            JSON: 0x4e4f534a,
            BIN: 0x004e4942
        };
        var dataView = new DataView(glb);
        // read header
        var header = {
            magic: dataView.getUint32(0, true),
            version: dataView.getUint32(UINT32_LENGTH, true),
            length: dataView.getUint32(2 * UINT32_LENGTH, true)
        };
        if (header.magic !== GLB_HEADER_MAGIC) {
            console.error("Invalid glb magic number. Expected 0x46546C67, found 0x" + header.magic.toString(16));
            return null;
        }
        // read main data
        var chunkLength = dataView.getUint32(GLB_HEADER_LENGTH, true);
        var chunkType = dataView.getUint32(GLB_HEADER_LENGTH + UINT32_LENGTH, true);
        // read glTF json
        if (chunkType !== GLB_CHUNK_TYPES.JSON) {
            console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x" + chunkType.toString(16));
            return null;
        }
        var glTFData = new Uint8Array(glb, GLB_HEADER_LENGTH + 2 * UINT32_LENGTH, chunkLength);
        var gltf = JSON.parse(GLTFUtil.decodeText(glTFData));
        // read all buffers
        var buffers = [];
        var byteOffset = GLB_HEADER_LENGTH + 2 * UINT32_LENGTH + chunkLength;
        while(byteOffset < header.length){
            chunkLength = dataView.getUint32(byteOffset, true);
            chunkType = dataView.getUint32(byteOffset + UINT32_LENGTH, true);
            if (chunkType !== GLB_CHUNK_TYPES.BIN) {
                console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x" + chunkType.toString(16));
                return null;
            }
            var currentOffset = byteOffset + 2 * UINT32_LENGTH;
            var buffer = glb.slice(currentOffset, currentOffset + chunkLength);
            buffers.push(buffer);
            byteOffset += chunkLength + 2 * UINT32_LENGTH;
        }
        return {
            gltf: gltf,
            buffers: buffers
        };
    };
    GLTFUtil._formatRelativePath = function _formatRelativePath(path) {
        // For example input is "a/b", "/a/b", "./a/b", "./a/./b", "./a/../a/b", output is "a/b"
        return path.split("/").filter(Boolean).reduce(function(acc, cur) {
            if (cur === "..") acc.pop();
            else if (cur !== ".") acc.push(cur);
            return acc;
        }, []).join("/");
    };
    return GLTFUtil;
}();

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
}

function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}

function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
        return Array.from(iter);
    }
}

function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);

    var n = Object.prototype.toString.call(o).slice(8, -1);

    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}

function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}

var Parser = /*#__PURE__*/ function() {
    function Parser() {}
    Parser.parseEngineResource = function parseEngineResource(extensionName, extensionSchema, parseResource, context) {
        for(var _len = arguments.length, extra = new Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++){
            extra[_key - 4] = arguments[_key];
        }
        var parsers = Parser._extensionParsers[extensionName];
        if (parsers == null ? void 0 : parsers.length) {
            for(var i = 0; i < parsers.length; i++){
                var _parsers_i;
                (_parsers_i = parsers[i]).parseEngineResource.apply(_parsers_i, [
                    extensionSchema,
                    parseResource,
                    context
                ].concat(_to_consumable_array(extra)));
            }
        }
    };
    Parser.createEngineResource = function createEngineResource(extensionName, extensionSchema, context) {
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
        var parsers = Parser._extensionParsers[extensionName];
        if (parsers == null ? void 0 : parsers.length) {
            var _parsers_;
            return (_parsers_ = parsers[0]).createEngineResource.apply(_parsers_, [
                extensionSchema,
                context
            ].concat(_to_consumable_array(extra)));
        }
    };
    Parser.hasExtensionParser = function hasExtensionParser(extensionName) {
        var parsers = Parser._extensionParsers[extensionName];
        return !!(parsers == null ? void 0 : parsers.length);
    };
    Parser.initialize = function initialize(extensionName) {
        var parsers = Parser._extensionParsers[extensionName];
        if (parsers == null ? void 0 : parsers.length) {
            for(var i = 0; i < parsers.length; i++){
                parsers[i].initialize();
            }
        }
    };
    /**
   * @internal
   */ Parser._addExtensionParser = function _addExtensionParser(extensionName, extensionParser) {
        if (!Parser._extensionParsers[extensionName]) {
            Parser._extensionParsers[extensionName] = [];
        }
        Parser._extensionParsers[extensionName].push(extensionParser);
    };
    return Parser;
}();
(function() {
    Parser._extensionParsers = {};
})();
/**
 * Declare ExtensionParser's decorator.
 * @param extensionName - Extension name
 */ function registerExtension(extensionName) {
    return function(parser) {
        var extensionParser = new parser();
        Parser._addExtensionParser(extensionName, extensionParser);
    };
}

var ExtensionParser = /*#__PURE__*/ function() {
    function ExtensionParser() {}
    var _proto = ExtensionParser.prototype;
    _proto.initialize = function initialize() {};
    _proto.parseEngineResource = function parseEngineResource(schema, parseResource, context) {
        for(var _len = arguments.length, extra = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++){
            extra[_key - 3] = arguments[_key];
        }
    };
    _proto.createEngineResource = function createEngineResource(schema, context) {
        for(var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){
            extra[_key - 2] = arguments[_key];
        }
        return null;
    };
    return ExtensionParser;
}();

var KHR_draco_mesh_compression = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_draco_mesh_compression1, ExtensionParser);
    function KHR_draco_mesh_compression1() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_draco_mesh_compression1.prototype;
    _proto.initialize = function initialize() {
        if (!KHR_draco_mesh_compression._decoder) {
            KHR_draco_mesh_compression._decoder = new DRACODecoder();
        }
    };
    _proto.createEngineResource = function createEngineResource(schema, context, gltfPrimitive) {
        var gltf = context.gltf, buffers = context.buffers;
        var bufferViews = gltf.bufferViews, accessors = gltf.accessors;
        var bufferViewIndex = schema.bufferView, gltfAttributeMap = schema.attributes;
        var attributeMap = {};
        var attributeTypeMap = {};
        for(var attributeName in gltfAttributeMap){
            attributeMap[attributeName] = gltfAttributeMap[attributeName];
        }
        for(var attributeName1 in gltfPrimitive.attributes){
            if (gltfAttributeMap[attributeName1] !== undefined) {
                var accessorDef = accessors[gltfPrimitive.attributes[attributeName1]];
                attributeTypeMap[attributeName1] = GLTFUtil.getComponentType(accessorDef.componentType).name;
            }
        }
        var indexAccessor = accessors[gltfPrimitive.indices];
        var indexType = GLTFUtil.getComponentType(indexAccessor.componentType).name;
        var taskConfig = {
            attributeIDs: attributeMap,
            attributeTypes: attributeTypeMap,
            useUniqueIDs: true,
            indexType: indexType
        };
        var buffer = GLTFUtil.getBufferViewData(bufferViews[bufferViewIndex], buffers);
        return KHR_draco_mesh_compression._decoder.decode(buffer, taskConfig).then(function(parsedGeometry) {
            return parsedGeometry;
        });
    };
    return KHR_draco_mesh_compression1;
}(ExtensionParser);
KHR_draco_mesh_compression = __decorate([
    registerExtension("KHR_draco_mesh_compression")
], KHR_draco_mesh_compression);

function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else return left instanceof right;
}

var KHR_lights_punctual = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_lights_punctual, ExtensionParser);
    function KHR_lights_punctual() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_lights_punctual.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, entity, context) {
        var color = schema.color, _schema_intensity = schema.intensity, intensity = _schema_intensity === void 0 ? 1 : _schema_intensity, type = schema.type, range = schema.range, spot = schema.spot;
        var glTFResource = context.glTFResource;
        var light;
        if (type === "directional") {
            light = entity.addComponent(DirectLight);
        } else if (type === "point") {
            light = entity.addComponent(PointLight);
        } else if (type === "spot") {
            light = entity.addComponent(SpotLight);
        }
        if (color) {
            light.color.set(color[0], color[1], color[2], 1);
        }
        light.intensity = intensity;
        if (range && !_instanceof(light, DirectLight)) {
            light.distance = range;
        }
        if (spot && _instanceof(light, SpotLight)) {
            var _spot_innerConeAngle = spot.innerConeAngle, innerConeAngle = _spot_innerConeAngle === void 0 ? 0 : _spot_innerConeAngle, _spot_outerConeAngle = spot.outerConeAngle, outerConeAngle = _spot_outerConeAngle === void 0 ? Math.PI / 4 : _spot_outerConeAngle;
            light.angle = innerConeAngle;
            light.penumbra = outerConeAngle - innerConeAngle;
        }
        if (!glTFResource.lights) glTFResource.lights = [];
        glTFResource.lights.push(light);
    };
    return KHR_lights_punctual;
}(ExtensionParser);
KHR_lights_punctual = __decorate([
    registerExtension("KHR_lights_punctual")
], KHR_lights_punctual);

var MaterialParser = /*#__PURE__*/ function(Parser1) {
    _inherits(MaterialParser, Parser1);
    function MaterialParser() {
        return Parser1.apply(this, arguments);
    }
    var _proto = MaterialParser.prototype;
    _proto.parse = function parse(context) {
        var gltf = context.gltf, glTFResource = context.glTFResource;
        var engine = glTFResource.engine, textures = glTFResource.textures;
        if (!gltf.materials) return;
        var materialsPromiseInfo = context.materialsPromiseInfo;
        var materials = [];
        for(var i = 0; i < gltf.materials.length; i++){
            var _gltf_materials_i = gltf.materials[i], _gltf_materials_i_extensions = _gltf_materials_i.extensions, extensions = _gltf_materials_i_extensions === void 0 ? {} : _gltf_materials_i_extensions, pbrMetallicRoughness = _gltf_materials_i.pbrMetallicRoughness, normalTexture = _gltf_materials_i.normalTexture, occlusionTexture = _gltf_materials_i.occlusionTexture, emissiveTexture = _gltf_materials_i.emissiveTexture, emissiveFactor = _gltf_materials_i.emissiveFactor, alphaMode = _gltf_materials_i.alphaMode, alphaCutoff = _gltf_materials_i.alphaCutoff, doubleSided = _gltf_materials_i.doubleSided, _gltf_materials_i_name = _gltf_materials_i.name, name = _gltf_materials_i_name === void 0 ? "" : _gltf_materials_i_name;
            var KHR_materials_unlit = extensions.KHR_materials_unlit, KHR_materials_pbrSpecularGlossiness = extensions.KHR_materials_pbrSpecularGlossiness, KHR_materials_clearcoat = extensions.KHR_materials_clearcoat, KHR_materials_ior = extensions.KHR_materials_ior, OASIS_materials_remap = extensions.OASIS_materials_remap;
            var material = null;
            if (KHR_materials_unlit) {
                material = Parser.createEngineResource("KHR_materials_unlit", KHR_materials_unlit, context);
            } else if (KHR_materials_pbrSpecularGlossiness) {
                material = Parser.createEngineResource("KHR_materials_pbrSpecularGlossiness", KHR_materials_pbrSpecularGlossiness, context);
            } else {
                material = new PBRMaterial(engine);
            }
            material.name = name;
            if (KHR_materials_clearcoat) {
                Parser.parseEngineResource("KHR_materials_clearcoat", KHR_materials_clearcoat, material, context);
            }
            if (KHR_materials_ior) {
                Parser.parseEngineResource("KHR_materials_ior", KHR_materials_ior, material, context);
            }
            if (pbrMetallicRoughness) {
                var baseColorFactor = pbrMetallicRoughness.baseColorFactor, baseColorTexture = pbrMetallicRoughness.baseColorTexture, metallicFactor = pbrMetallicRoughness.metallicFactor, roughnessFactor = pbrMetallicRoughness.roughnessFactor, metallicRoughnessTexture = pbrMetallicRoughness.metallicRoughnessTexture;
                if (baseColorFactor) {
                    material.baseColor = new Color(Color.linearToGammaSpace(baseColorFactor[0]), Color.linearToGammaSpace(baseColorFactor[1]), Color.linearToGammaSpace(baseColorFactor[2]), baseColorFactor[3]);
                }
                if (baseColorTexture) {
                    material.baseTexture = textures[baseColorTexture.index];
                    MaterialParser._parseTextureTransform(material, baseColorTexture.extensions, context);
                }
                if (!KHR_materials_unlit && !KHR_materials_pbrSpecularGlossiness) {
                    var m = material;
                    m.metallic = metallicFactor != null ? metallicFactor : 1;
                    m.roughness = roughnessFactor != null ? roughnessFactor : 1;
                    if (metallicRoughnessTexture) {
                        m.roughnessMetallicTexture = textures[metallicRoughnessTexture.index];
                        MaterialParser._parseTextureTransform(material, metallicRoughnessTexture.extensions, context);
                    }
                }
            }
            if (!KHR_materials_unlit) {
                var m1 = material;
                if (emissiveTexture) {
                    m1.emissiveTexture = textures[emissiveTexture.index];
                    MaterialParser._parseTextureTransform(material, emissiveTexture.extensions, context);
                }
                if (emissiveFactor) {
                    m1.emissiveColor = new Color(Color.linearToGammaSpace(emissiveFactor[0]), Color.linearToGammaSpace(emissiveFactor[1]), Color.linearToGammaSpace(emissiveFactor[2]));
                }
                if (normalTexture) {
                    var index = normalTexture.index, scale = normalTexture.scale;
                    m1.normalTexture = textures[index];
                    MaterialParser._parseTextureTransform(material, normalTexture.extensions, context);
                    if (scale !== undefined) {
                        m1.normalTextureIntensity = scale;
                    }
                }
                if (occlusionTexture) {
                    var index1 = occlusionTexture.index, strength = occlusionTexture.strength, texCoord = occlusionTexture.texCoord;
                    m1.occlusionTexture = textures[index1];
                    MaterialParser._parseTextureTransform(material, occlusionTexture.extensions, context);
                    if (strength !== undefined) {
                        m1.occlusionTextureIntensity = strength;
                    }
                    if (texCoord === TextureCoordinate.UV1) {
                        m1.occlusionTextureCoord = TextureCoordinate.UV1;
                    } else if (texCoord > TextureCoordinate.UV1) {
                        Logger.warn("Occlusion texture uv coordinate must be UV0 or UV1.");
                    }
                }
            }
            if (OASIS_materials_remap) {
                var _gltf_extensions;
                gltf.extensions = (_gltf_extensions = gltf.extensions) != null ? _gltf_extensions : {};
                var _gltf_extensions_OASIS_materials_remap;
                gltf.extensions["OASIS_materials_remap"] = (_gltf_extensions_OASIS_materials_remap = gltf.extensions["OASIS_materials_remap"]) != null ? _gltf_extensions_OASIS_materials_remap : {};
                gltf.extensions["OASIS_materials_remap"][i] = Parser.createEngineResource("OASIS_materials_remap", OASIS_materials_remap, context);
            }
            if (doubleSided) {
                material.renderFace = RenderFace.Double;
            } else {
                material.renderFace = RenderFace.Front;
            }
            switch(alphaMode){
                case MaterialAlphaMode.OPAQUE:
                    material.isTransparent = false;
                    break;
                case MaterialAlphaMode.BLEND:
                    material.isTransparent = true;
                    break;
                case MaterialAlphaMode.MASK:
                    material.alphaCutoff = alphaCutoff != null ? alphaCutoff : 0.5;
                    break;
            }
            materials[i] = material;
        }
        glTFResource.materials = materials;
        materialsPromiseInfo.resolve(materials);
        return materialsPromiseInfo.promise;
    };
    /** @internal */ MaterialParser._parseTextureTransform = function _parseTextureTransform(material, extensions, context) {
        if (extensions === void 0) extensions = {};
        var schema = extensions.KHR_texture_transform;
        if (schema) {
            Parser.parseEngineResource("KHR_texture_transform", schema, material, context);
        }
    };
    return MaterialParser;
}(Parser);

var KHR_materials_clearcoat = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_materials_clearcoat, ExtensionParser);
    function KHR_materials_clearcoat() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_clearcoat.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
        var textures = context.glTFResource.textures;
        var _schema_clearcoatFactor = schema.clearcoatFactor, clearcoatFactor = _schema_clearcoatFactor === void 0 ? 0 : _schema_clearcoatFactor, clearcoatTexture = schema.clearcoatTexture, _schema_clearcoatRoughnessFactor = schema.clearcoatRoughnessFactor, clearcoatRoughnessFactor = _schema_clearcoatRoughnessFactor === void 0 ? 0 : _schema_clearcoatRoughnessFactor, clearcoatRoughnessTexture = schema.clearcoatRoughnessTexture, clearcoatNormalTexture = schema.clearcoatNormalTexture;
        material.clearCoat = clearcoatFactor;
        material.clearCoatRoughness = clearcoatRoughnessFactor;
        if (clearcoatTexture) {
            material.clearCoatTexture = textures[clearcoatTexture.index];
            MaterialParser._parseTextureTransform(material, clearcoatTexture.extensions, context);
        }
        if (clearcoatRoughnessTexture) {
            material.clearCoatRoughnessTexture = textures[clearcoatRoughnessTexture.index];
            MaterialParser._parseTextureTransform(material, clearcoatRoughnessTexture.extensions, context);
        }
        if (clearcoatNormalTexture) {
            material.clearCoatNormalTexture = textures[clearcoatNormalTexture.index];
            MaterialParser._parseTextureTransform(material, clearcoatNormalTexture.extensions, context);
        }
    };
    return KHR_materials_clearcoat;
}(ExtensionParser);
KHR_materials_clearcoat = __decorate([
    registerExtension("KHR_materials_clearcoat")
], KHR_materials_clearcoat);

var KHR_materials_ior = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_materials_ior, ExtensionParser);
    function KHR_materials_ior() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_ior.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
        var _schema_ior = schema.ior, ior = _schema_ior === void 0 ? 1.5 : _schema_ior;
        material.ior = ior;
    };
    return KHR_materials_ior;
}(ExtensionParser);
KHR_materials_ior = __decorate([
    registerExtension("KHR_materials_ior")
], KHR_materials_ior);

var KHR_materials_pbrSpecularGlossiness = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_materials_pbrSpecularGlossiness, ExtensionParser);
    function KHR_materials_pbrSpecularGlossiness() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_pbrSpecularGlossiness.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
        var _context_glTFResource = context.glTFResource, engine = _context_glTFResource.engine, textures = _context_glTFResource.textures;
        var material = new PBRSpecularMaterial(engine);
        var diffuseFactor = schema.diffuseFactor, diffuseTexture = schema.diffuseTexture, specularFactor = schema.specularFactor, glossinessFactor = schema.glossinessFactor, specularGlossinessTexture = schema.specularGlossinessTexture;
        if (diffuseFactor) {
            material.baseColor = new Color(Color.linearToGammaSpace(diffuseFactor[0]), Color.linearToGammaSpace(diffuseFactor[1]), Color.linearToGammaSpace(diffuseFactor[2]), diffuseFactor[3]);
        }
        if (diffuseTexture) {
            material.baseTexture = textures[diffuseTexture.index];
            MaterialParser._parseTextureTransform(material, diffuseTexture.extensions, context);
        }
        if (specularFactor) {
            material.specularColor = new Color(Color.linearToGammaSpace(specularFactor[0]), Color.linearToGammaSpace(specularFactor[1]), Color.linearToGammaSpace(specularFactor[2]));
        }
        if (glossinessFactor !== undefined) {
            material.glossiness = glossinessFactor;
        }
        if (specularGlossinessTexture) {
            material.specularGlossinessTexture = textures[specularGlossinessTexture.index];
            MaterialParser._parseTextureTransform(material, specularGlossinessTexture.extensions, context);
        }
        return material;
    };
    return KHR_materials_pbrSpecularGlossiness;
}(ExtensionParser);
KHR_materials_pbrSpecularGlossiness = __decorate([
    registerExtension("KHR_materials_pbrSpecularGlossiness")
], KHR_materials_pbrSpecularGlossiness);

var KHR_materials_unlit = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_materials_unlit, ExtensionParser);
    function KHR_materials_unlit() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_unlit.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
        var engine = context.glTFResource.engine;
        var material = new UnlitMaterial(engine);
        return material;
    };
    return KHR_materials_unlit;
}(ExtensionParser);
KHR_materials_unlit = __decorate([
    registerExtension("KHR_materials_unlit")
], KHR_materials_unlit);

var KHR_materials_variants = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_materials_variants, ExtensionParser);
    function KHR_materials_variants() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_materials_variants.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, renderer, context) {
        var _context_gltf = context.gltf, _context_gltf_extensions = _context_gltf.extensions, _context_gltf_extensions_KHR_materials_variants = _context_gltf_extensions.KHR_materials_variants, variantNames = _context_gltf_extensions_KHR_materials_variants.variants, glTFResource = context.glTFResource;
        var mappings = schema.mappings;
        for(var i = 0; i < mappings.length; i++){
            var _mappings_i = mappings[i], material = _mappings_i.material, variants = _mappings_i.variants;
            if (!glTFResource.variants) glTFResource.variants = [];
            glTFResource.variants.push({
                renderer: renderer,
                material: glTFResource.materials[material],
                variants: variants.map(function(index) {
                    return variantNames[index].name;
                })
            });
        }
    };
    return KHR_materials_variants;
}(ExtensionParser);
KHR_materials_variants = __decorate([
    registerExtension("KHR_materials_variants")
], KHR_materials_variants);

var KHR_mesh_quantization = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_mesh_quantization, ExtensionParser);
    function KHR_mesh_quantization() {
        return ExtensionParser.apply(this, arguments);
    }
    return KHR_mesh_quantization;
}(ExtensionParser);
KHR_mesh_quantization = __decorate([
    registerExtension("KHR_mesh_quantization")
], KHR_mesh_quantization);

var KHR_texture_transform = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(KHR_texture_transform, ExtensionParser);
    function KHR_texture_transform() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = KHR_texture_transform.prototype;
    _proto.parseEngineResource = function parseEngineResource(schema, material, context) {
        var offset = schema.offset, rotation = schema.rotation, scale = schema.scale, texCoord = schema.texCoord;
        if (offset) {
            material.tilingOffset.z = offset[0];
            material.tilingOffset.w = offset[1];
        }
        if (scale) {
            material.tilingOffset.x = scale[0];
            material.tilingOffset.y = scale[1];
        }
        if (rotation) {
            Logger.warn("rotation in KHR_texture_transform is not supported now");
        }
        if (texCoord) {
            Logger.warn("texCoord in KHR_texture_transform is not supported now");
        }
    };
    return KHR_texture_transform;
}(ExtensionParser);
KHR_texture_transform = __decorate([
    registerExtension("KHR_texture_transform")
], KHR_texture_transform);

var GalaceanMaterialsRemap = /*#__PURE__*/ function(ExtensionParser) {
    _inherits(GalaceanMaterialsRemap, ExtensionParser);
    function GalaceanMaterialsRemap() {
        return ExtensionParser.apply(this, arguments);
    }
    var _proto = GalaceanMaterialsRemap.prototype;
    _proto.createEngineResource = function createEngineResource(schema, context) {
        var engine = context.glTFResource.engine;
        // @ts-ignore
        return engine.resourceManager.getResourceByRef(schema);
    };
    return GalaceanMaterialsRemap;
}(ExtensionParser);
GalaceanMaterialsRemap = __decorate([
    registerExtension("OASIS_materials_remap")
], GalaceanMaterialsRemap);

function _create_for_of_iterator_helper_loose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);
    // Fallback for engines without symbol support
    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;

        var i = 0;

        return function() {
            if (i >= o.length) return { done: true };

            return { done: false, value: o[i++] };
        };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var AnimationParser = /*#__PURE__*/ function(Parser) {
    _inherits(AnimationParser, Parser);
    function AnimationParser() {
        return Parser.apply(this, arguments);
    }
    var _proto = AnimationParser.prototype;
    _proto.parse = function parse(context) {
        var gltf = context.gltf; context.buffers; var glTFResource = context.glTFResource;
        var entities = glTFResource.entities;
        var animations = gltf.animations, accessors = gltf.accessors;
        if (!animations) {
            return;
        }
        var animationClipsPromiseInfo = context.animationClipsPromiseInfo;
        var animationClipCount = animations.length;
        var animationClips = new Array(animationClipCount);
        var animationsIndices = new Array(animationClipCount);
        for(var i = 0; i < animationClipCount; i++){
            var gltfAnimation = animations[i];
            var channels = gltfAnimation.channels, samplers = gltfAnimation.samplers, _gltfAnimation_name = gltfAnimation.name, name = _gltfAnimation_name === void 0 ? "AnimationClip" + i : _gltfAnimation_name;
            var animationClip = new AnimationClip(name);
            var sampleDataCollection = new Array();
            // parse samplers
            for(var j = 0, m = samplers.length; j < m; j++){
                var gltfSampler = samplers[j];
                var inputAccessor = accessors[gltfSampler.input];
                var outputAccessor = accessors[gltfSampler.output];
                var input = GLTFUtil.getAccessorBuffer(context, gltf, inputAccessor).data;
                var output = GLTFUtil.getAccessorBuffer(context, gltf, outputAccessor).data;
                if (outputAccessor.normalized) {
                    var scale = GLTFUtil.getNormalizedComponentScale(outputAccessor.componentType);
                    var scaled = new Float32Array(output.length);
                    for(var k = 0, v = output.length; k < v; k++){
                        scaled[k] = output[k] * scale;
                    }
                    output = scaled;
                }
                var outputStride = output.length / input.length;
                var _gltfSampler_interpolation;
                var interpolation = (_gltfSampler_interpolation = gltfSampler.interpolation) != null ? _gltfSampler_interpolation : AnimationSamplerInterpolation.Linear;
                var samplerInterpolation = void 0;
                switch(interpolation){
                    case AnimationSamplerInterpolation.CubicSpine:
                        samplerInterpolation = InterpolationType.CubicSpine;
                        break;
                    case AnimationSamplerInterpolation.Step:
                        samplerInterpolation = InterpolationType.Step;
                        break;
                    case AnimationSamplerInterpolation.Linear:
                        samplerInterpolation = InterpolationType.Linear;
                        break;
                }
                input[input.length - 1];
                sampleDataCollection.push({
                    type: outputAccessor.type,
                    interpolation: samplerInterpolation,
                    input: input,
                    output: output,
                    outputSize: outputStride
                });
            }
            for(var j1 = 0, m1 = channels.length; j1 < m1; j1++){
                var gltfChannel = channels[j1];
                var target = gltfChannel.target;
                var channelTargetEntity = entities[target.node];
                var relativePath = "";
                var entity = channelTargetEntity;
                while(entity.parent){
                    relativePath = relativePath === "" ? "" + entity.name : entity.name + "/" + relativePath;
                    entity = entity.parent;
                }
                var ComponentType = void 0;
                var propertyName = void 0;
                switch(target.path){
                    case AnimationChannelTargetPath.TRANSLATION:
                        ComponentType = Transform;
                        propertyName = "position";
                        break;
                    case AnimationChannelTargetPath.ROTATION:
                        ComponentType = Transform;
                        propertyName = "rotationQuaternion";
                        break;
                    case AnimationChannelTargetPath.SCALE:
                        ComponentType = Transform;
                        propertyName = "scale";
                        break;
                    case AnimationChannelTargetPath.WEIGHTS:
                        ComponentType = SkinnedMeshRenderer;
                        propertyName = "blendShapeWeights";
                        break;
                }
                var curve = this._addCurve(target.path, gltfChannel, sampleDataCollection);
                animationClip.addCurveBinding(relativePath, ComponentType, propertyName, curve);
            }
            animationClips[i] = animationClip;
            animationsIndices[i] = {
                name: name,
                index: i
            };
        }
        glTFResource.animations = animationClips;
        // @ts-ignore for editor
        glTFResource._animationsIndices = animationsIndices;
        animationClipsPromiseInfo.resolve(animationClips);
        return animationClipsPromiseInfo.promise;
    };
    _proto._addCurve = function _addCurve(animationchannelTargetPath, gltfChannel, sampleDataCollection) {
        var sampleData = sampleDataCollection[gltfChannel.sampler];
        var input = sampleData.input, output = sampleData.output, outputSize = sampleData.outputSize;
        switch(animationchannelTargetPath){
            case AnimationChannelTargetPath.TRANSLATION:
            case AnimationChannelTargetPath.SCALE:
                {
                    var curve = new AnimationVector3Curve();
                    var interpolation = curve.interpolation = sampleData.interpolation;
                    var offset = 0;
                    for(var i = 0, n = input.length; i < n; i++){
                        var keyframe = new Keyframe();
                        keyframe.time = input[i];
                        if (interpolation === InterpolationType.CubicSpine) {
                            keyframe.inTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                            keyframe.outTangent = new Vector3(output[offset++], output[offset++], output[offset++]);
                        } else {
                            keyframe.value = new Vector3(output[offset++], output[offset++], output[offset++]);
                        }
                        curve.addKey(keyframe);
                    }
                    return curve;
                }
            case AnimationChannelTargetPath.ROTATION:
                {
                    var curve1 = new AnimationQuaternionCurve();
                    var interpolation1 = curve1.interpolation = sampleData.interpolation;
                    var offset1 = 0;
                    for(var i1 = 0, n1 = input.length; i1 < n1; i1++){
                        var keyframe1 = new Keyframe();
                        keyframe1.time = input[i1];
                        if (interpolation1 === InterpolationType.CubicSpine) {
                            keyframe1.inTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                            keyframe1.outTangent = new Vector4(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        } else {
                            keyframe1.value = new Quaternion(output[offset1++], output[offset1++], output[offset1++], output[offset1++]);
                        }
                        curve1.addKey(keyframe1);
                    }
                    return curve1;
                }
            case AnimationChannelTargetPath.WEIGHTS:
                {
                    var curve2 = new AnimationFloatArrayCurve();
                    curve2.interpolation = sampleData.interpolation;
                    var offset2 = 0;
                    for(var i2 = 0, n2 = input.length; i2 < n2; i2++){
                        var keyframe2 = new Keyframe();
                        keyframe2.time = input[i2];
                        if (curve2.interpolation === InterpolationType.CubicSpine) {
                            keyframe2.inTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                            keyframe2.value = output.subarray(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                            keyframe2.outTangent = Array.from(output.subarray(offset2, offset2 + outputSize));
                            offset2 += outputSize;
                        } else {
                            keyframe2.value = output.subarray(offset2, offset2 + outputSize);
                            offset2 += outputSize;
                        }
                        curve2.addKey(keyframe2);
                    }
                    return curve2;
                }
        }
    };
    return AnimationParser;
}(Parser);

var BufferParser = /*#__PURE__*/ function(Parser) {
    _inherits(BufferParser, Parser);
    function BufferParser() {
        return Parser.apply(this, arguments);
    }
    var _proto = BufferParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource;
        var url = glTFResource.url;
        if (this._isGLB(url)) {
            return request(url, {
                type: "arraybuffer"
            }).then(GLTFUtil.parseGLB).then(function(param) {
                var gltf = param.gltf, buffers = param.buffers;
                context.gltf = gltf;
                context.buffers = buffers;
            });
        } else {
            return request(url, {
                type: "json"
            }).then(function(gltf) {
                context.gltf = gltf;
                return Promise.all(gltf.buffers.map(function(buffer) {
                    return request(GLTFUtil.parseRelativeUrl(url, buffer.uri), {
                        type: "arraybuffer"
                    });
                })).then(function(buffers) {
                    context.buffers = buffers;
                });
            });
        }
    };
    _proto._isGLB = function _isGLB(url) {
        var index = url.lastIndexOf(".");
        return url.substring(index + 1, index + 4) === "glb";
    };
    return BufferParser;
}(Parser);

var EntityParser = /*#__PURE__*/ function(Parser) {
    _inherits(EntityParser, Parser);
    function EntityParser() {
        return Parser.apply(this, arguments);
    }
    var _proto = EntityParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, nodes = context.gltf.nodes;
        var engine = glTFResource.engine;
        if (!nodes) return;
        var entities = [];
        for(var i = 0; i < nodes.length; i++){
            var gltfNode = nodes[i];
            var matrix = gltfNode.matrix, translation = gltfNode.translation, rotation = gltfNode.rotation, scale = gltfNode.scale;
            var entity = new Entity(engine, gltfNode.name || "" + EntityParser._defaultName + i);
            var transform = entity.transform;
            if (matrix) {
                var localMatrix = transform.localMatrix;
                localMatrix.copyFromArray(matrix);
                transform.localMatrix = localMatrix;
            } else {
                if (translation) {
                    transform.setPosition(translation[0], translation[1], translation[2]);
                }
                if (rotation) {
                    transform.setRotationQuaternion(rotation[0], rotation[1], rotation[2], rotation[3]);
                }
                if (scale) {
                    transform.setScale(scale[0], scale[1], scale[2]);
                }
            }
            entities[i] = entity;
        }
        glTFResource.entities = entities;
        this._buildEntityTree(context, glTFResource);
        this._createSceneRoots(context, glTFResource);
    };
    _proto._buildEntityTree = function _buildEntityTree(context, glTFResource) {
        var nodes = context.gltf.nodes;
        var entities = glTFResource.entities;
        for(var i = 0; i < nodes.length; i++){
            var children = nodes[i].children;
            var entity = entities[i];
            if (children) {
                for(var j = 0; j < children.length; j++){
                    var childEntity = entities[children[j]];
                    entity.addChild(childEntity);
                }
            }
        }
    };
    _proto._createSceneRoots = function _createSceneRoots(context, glTFResource) {
        var _context_gltf = context.gltf, tmp = _context_gltf.scene, sceneID = tmp === void 0 ? 0 : tmp, scenes = _context_gltf.scenes;
        var engine = glTFResource.engine, entities = glTFResource.entities;
        if (!scenes) return;
        var sceneRoots = [];
        for(var i = 0; i < scenes.length; i++){
            var nodes = scenes[i].nodes;
            if (!nodes) continue;
            if (nodes.length === 1) {
                sceneRoots[i] = entities[nodes[0]];
            } else {
                var rootEntity = new Entity(engine, "GLTF_ROOT");
                for(var j = 0; j < nodes.length; j++){
                    rootEntity.addChild(entities[nodes[j]]);
                }
                sceneRoots[i] = rootEntity;
            }
        }
        glTFResource.sceneRoots = sceneRoots;
        glTFResource.defaultSceneRoot = sceneRoots[sceneID];
    };
    return EntityParser;
}(Parser);
(function() {
    /** @internal */ EntityParser._defaultName = "_GLTF_ENTITY_";
})();

var MeshParser = /*#__PURE__*/ function(Parser1) {
    _inherits(MeshParser, Parser1);
    function MeshParser() {
        return Parser1.apply(this, arguments);
    }
    var _proto = MeshParser.prototype;
    _proto.parse = function parse(context) {
        var _loop = function(i) {
            var _loop = function(j) {
                var gltfPrimitive = gltfMesh.primitives[j];
                var _gltfPrimitive_extensions = gltfPrimitive.extensions, extensions = _gltfPrimitive_extensions === void 0 ? {} : _gltfPrimitive_extensions;
                var KHR_draco_mesh_compression = extensions.KHR_draco_mesh_compression;
                primitivePromises[j] = new Promise(function(resolve) {
                    var mesh = new ModelMesh(engine, gltfMesh.name || j + "");
                    if (KHR_draco_mesh_compression) {
                        Parser.createEngineResource("KHR_draco_mesh_compression", KHR_draco_mesh_compression, context, gltfPrimitive).then(function(decodedGeometry) {
                            return _this._parseMeshFromGLTFPrimitiveDraco(mesh, gltfMesh, gltfPrimitive, gltf, function(attributeSemantic) {
                                for(var j = 0; j < decodedGeometry.attributes.length; j++){
                                    if (decodedGeometry.attributes[j].name === attributeSemantic) {
                                        return decodedGeometry.attributes[j].array;
                                    }
                                }
                                return null;
                            }, function(attributeSemantic, shapeIndex) {
                                throw "BlendShape animation is not supported when using draco.";
                            }, function() {
                                return decodedGeometry.index.array;
                            }, context.keepMeshData);
                        }).then(resolve);
                    } else {
                        _this._parseMeshFromGLTFPrimitive(context, mesh, gltfMesh, gltfPrimitive, gltf, function(attributeSemantic) {
                            return null;
                        }, function(attributeName, shapeIndex) {
                            var shapeAccessorIdx = gltfPrimitive.targets[shapeIndex];
                            var attributeAccessorIdx = shapeAccessorIdx[attributeName];
                            if (attributeAccessorIdx) {
                                var accessor = gltf.accessors[attributeAccessorIdx];
                                return GLTFUtil.getAccessorData(gltf, accessor, buffers);
                            } else {
                                return null;
                            }
                        }, function() {
                            var indexAccessor = gltf.accessors[gltfPrimitive.indices];
                            return GLTFUtil.getAccessorData(gltf, indexAccessor, buffers);
                        }, context.keepMeshData).then(resolve);
                    }
                });
            };
            var gltfMesh = gltf.meshes[i];
            var primitivePromises = [];
            for(var j = 0; j < gltfMesh.primitives.length; j++)_loop(j);
            meshPromises[i] = Promise.all(primitivePromises);
        };
        var _this = this;
        var gltf = context.gltf, buffers = context.buffers, glTFResource = context.glTFResource;
        var engine = glTFResource.engine;
        if (!gltf.meshes) return;
        var meshesPromiseInfo = context.meshesPromiseInfo;
        var meshPromises = [];
        for(var i = 0; i < gltf.meshes.length; i++)_loop(i);
        AssetPromise.all(meshPromises).then(function(meshes) {
            glTFResource.meshes = meshes;
            meshesPromiseInfo.resolve(meshes);
        }).catch(meshesPromiseInfo.reject);
        return meshesPromiseInfo.promise;
    };
    _proto._parseMeshFromGLTFPrimitive = function _parseMeshFromGLTFPrimitive(context, mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, keepMeshData) {
        var accessors = gltf.accessors;
        context.buffers;
        var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
        var engine = mesh.engine;
        var vertexElements = new Array();
        var vertexCount;
        var bufferBindIndex = 0;
        var positions;
        var boneIndices;
        var boneWeights;
        if (keepMeshData) {
            positions = new Array(vertexCount);
            boneIndices = new Array(vertexCount);
            boneWeights = new Array(vertexCount);
        }
        for(var attribute in attributes){
            var accessor = accessors[attributes[attribute]];
            var accessorBuffer = GLTFUtil.getAccessorBuffer(context, gltf, accessor);
            var dataElementSize = GLTFUtil.getAccessorTypeSize(accessor.type);
            var accessorCount = accessor.count;
            var vertices = accessorBuffer.data;
            var vertexElement = void 0;
            var meshId = mesh.instanceId;
            var vertexBindingInfos = accessorBuffer.vertexBindingInfos;
            var elementNormalized = accessor.normalized;
            var elementFormat = GLTFUtil.getElementFormat(accessor.componentType, dataElementSize, elementNormalized);
            var scaleFactor = void 0;
            elementNormalized && (scaleFactor = GLTFUtil.getNormalizedComponentScale(accessor.componentType));
            var elementOffset = void 0;
            if (accessorBuffer.interleaved) {
                var byteOffset = accessor.byteOffset || 0;
                var stride = accessorBuffer.stride;
                elementOffset = byteOffset % stride;
                if (vertexBindingInfos[meshId] === undefined) {
                    vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                    var vertexBuffer = accessorBuffer.vertexBuffer;
                    if (!vertexBuffer) {
                        vertexBuffer = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices.byteLength, BufferUsage.Static);
                        vertexBuffer.setData(vertices);
                        accessorBuffer.vertexBuffer = vertexBuffer;
                    }
                    mesh.setVertexBufferBinding(vertexBuffer, stride, bufferBindIndex);
                    vertexBindingInfos[meshId] = bufferBindIndex++;
                } else {
                    vertexElement = new VertexElement(attribute, elementOffset, elementFormat, vertexBindingInfos[meshId]);
                }
            } else {
                elementOffset = 0;
                vertexElement = new VertexElement(attribute, elementOffset, elementFormat, bufferBindIndex);
                var vertexBuffer1 = new Buffer(engine, BufferBindFlag.VertexBuffer, vertices.byteLength, BufferUsage.Static);
                vertexBuffer1.setData(vertices);
                mesh.setVertexBufferBinding(vertexBuffer1, accessorBuffer.stride, bufferBindIndex);
                vertexBindingInfos[meshId] = bufferBindIndex++;
            }
            vertexElements.push(vertexElement);
            if (attribute === "POSITION") {
                vertexCount = accessorCount;
                var _mesh_bounds = mesh.bounds, min = _mesh_bounds.min, max = _mesh_bounds.max;
                if (accessor.min && accessor.max) {
                    min.copyFromArray(accessor.min);
                    max.copyFromArray(accessor.max);
                    if (keepMeshData) {
                        var baseOffset = elementOffset / vertices.BYTES_PER_ELEMENT;
                        var stride1 = vertices.length / accessorCount;
                        for(var j = 0; j < accessorCount; j++){
                            var offset = baseOffset + j * stride1;
                            var position = new Vector3(vertices[offset], vertices[offset + 1], vertices[offset + 2]);
                            elementNormalized && position.scale(scaleFactor);
                            positions[j] = position;
                        }
                    }
                } else {
                    var position1 = MeshParser._tempVector3;
                    min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                    max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                    var baseOffset1 = elementOffset / vertices.BYTES_PER_ELEMENT;
                    var stride2 = vertices.length / accessorCount;
                    for(var j1 = 0; j1 < accessorCount; j1++){
                        var offset1 = baseOffset1 + j1 * stride2;
                        position1.copyFromArray(vertices, offset1);
                        Vector3.min(min, position1, min);
                        Vector3.max(max, position1, max);
                        if (keepMeshData) {
                            var clonePosition = position1.clone();
                            elementNormalized && clonePosition.scale(scaleFactor);
                            positions[j1] = clonePosition;
                        }
                    }
                }
                if (elementNormalized) {
                    min.scale(scaleFactor);
                    max.scale(scaleFactor);
                }
            } else if (attribute === "JOINTS_0" && keepMeshData) {
                var baseOffset2 = elementOffset / vertices.BYTES_PER_ELEMENT;
                var stride3 = vertices.length / accessorCount;
                for(var j2 = 0; j2 < accessorCount; j2++){
                    var offset2 = baseOffset2 + j2 * stride3;
                    var boneIndex = new Vector4(vertices[offset2], vertices[offset2 + 1], vertices[offset2 + 2], vertices[offset2 + 3]);
                    elementNormalized && boneIndex.scale(scaleFactor);
                    boneIndices[j2] = boneIndex;
                }
            } else if (attribute === "WEIGHTS_0" && keepMeshData) {
                var baseOffset3 = elementOffset / vertices.BYTES_PER_ELEMENT;
                var stride4 = vertices.length / accessorCount;
                for(var j3 = 0; j3 < accessorCount; j3++){
                    var offset3 = baseOffset3 + j3 * stride4;
                    var boneWeight = new Vector4(vertices[offset3], vertices[offset3 + 1], vertices[offset3 + 2], vertices[offset3 + 3]);
                    elementNormalized && boneWeight.scale(scaleFactor);
                    boneWeights[j3] = boneWeight;
                }
            }
        }
        mesh.setVertexElements(vertexElements);
        // Indices
        if (indices !== undefined) {
            var indexAccessor = gltf.accessors[indices];
            var indexData = getIndexBufferData();
            mesh.setIndices(indexData);
            mesh.addSubMesh(0, indexAccessor.count, mode);
        } else {
            mesh.addSubMesh(0, vertexCount, mode);
        }
        // BlendShapes
        targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
        mesh.uploadData(!keepMeshData);
        //@ts-ignore
        mesh._positions = positions;
        //@ts-ignore
        mesh._boneIndices = boneIndices;
        //@ts-ignore
        mesh._boneWeights = boneWeights;
        return Promise.resolve(mesh);
    };
    _proto._createBlendShape = function _createBlendShape(mesh, glTFMesh, glTFTargets, getBlendShapeData) {
        var blendShapeNames = glTFMesh.extras ? glTFMesh.extras.targetNames : null;
        for(var i = 0, n = glTFTargets.length; i < n; i++){
            var name = blendShapeNames ? blendShapeNames[i] : "blendShape" + i;
            var deltaPosBuffer = getBlendShapeData("POSITION", i);
            var deltaNorBuffer = getBlendShapeData("NORMAL", i);
            var deltaTanBuffer = getBlendShapeData("TANGENT", i);
            var deltaPositions = deltaPosBuffer ? GLTFUtil.floatBufferToVector3Array(deltaPosBuffer) : null;
            var deltaNormals = deltaNorBuffer ? GLTFUtil.floatBufferToVector3Array(deltaNorBuffer) : null;
            var deltaTangents = deltaTanBuffer ? GLTFUtil.floatBufferToVector3Array(deltaTanBuffer) : null;
            var blendShape = new BlendShape(name);
            blendShape.addFrame(1.0, deltaPositions, deltaNormals, deltaTangents);
            mesh.addBlendShape(blendShape);
        }
    };
    /**
   * @deprecated
   */ _proto._parseMeshFromGLTFPrimitiveDraco = function _parseMeshFromGLTFPrimitiveDraco(mesh, gltfMesh, gltfPrimitive, gltf, getVertexBufferData, getBlendShapeData, getIndexBufferData, keepMeshData) {
        var attributes = gltfPrimitive.attributes, targets = gltfPrimitive.targets, indices = gltfPrimitive.indices, mode = gltfPrimitive.mode;
        var vertexCount;
        var accessors = gltf.accessors;
        var accessor = accessors[attributes["POSITION"]];
        var positionBuffer = getVertexBufferData("POSITION");
        var positions = GLTFUtil.floatBufferToVector3Array(positionBuffer);
        mesh.setPositions(positions);
        var bounds = mesh.bounds;
        vertexCount = accessor.count;
        if (accessor.min && accessor.max) {
            bounds.min.copyFromArray(accessor.min);
            bounds.max.copyFromArray(accessor.max);
        } else {
            var position = MeshParser._tempVector3;
            var min = bounds.min, max = bounds.max;
            min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            var stride = positionBuffer.length / vertexCount;
            for(var j = 0; j < vertexCount; j++){
                var offset = j * stride;
                position.copyFromArray(positionBuffer, offset);
                Vector3.min(min, position, min);
                Vector3.max(max, position, max);
            }
        }
        for(var attributeSemantic in attributes){
            if (attributeSemantic === "POSITION") {
                continue;
            }
            var bufferData = getVertexBufferData(attributeSemantic);
            switch(attributeSemantic){
                case "NORMAL":
                    var normals = GLTFUtil.floatBufferToVector3Array(bufferData);
                    mesh.setNormals(normals);
                    break;
                case "TEXCOORD_0":
                    var texturecoords = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords, 0);
                    break;
                case "TEXCOORD_1":
                    var texturecoords1 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords1, 1);
                    break;
                case "TEXCOORD_2":
                    var texturecoords2 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords2, 2);
                    break;
                case "TEXCOORD_3":
                    var texturecoords3 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords3, 3);
                    break;
                case "TEXCOORD_4":
                    var texturecoords4 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords4, 4);
                    break;
                case "TEXCOORD_5":
                    var texturecoords5 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords5, 5);
                    break;
                case "TEXCOORD_6":
                    var texturecoords6 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords6, 6);
                    break;
                case "TEXCOORD_7":
                    var texturecoords7 = GLTFUtil.floatBufferToVector2Array(bufferData);
                    mesh.setUVs(texturecoords7, 7);
                    break;
                case "COLOR_0":
                    var colors = GLTFUtil.floatBufferToColorArray(bufferData, accessors[attributes["COLOR_0"]].type === AccessorType.VEC3);
                    mesh.setColors(colors);
                    break;
                case "TANGENT":
                    var tangents = GLTFUtil.floatBufferToVector4Array(bufferData);
                    mesh.setTangents(tangents);
                    break;
                case "JOINTS_0":
                    var joints = GLTFUtil.floatBufferToVector4Array(bufferData);
                    mesh.setBoneIndices(joints);
                    break;
                case "WEIGHTS_0":
                    var weights = GLTFUtil.floatBufferToVector4Array(bufferData);
                    mesh.setBoneWeights(weights);
                    break;
            }
        }
        // Indices
        if (indices !== undefined) {
            var indexAccessor = gltf.accessors[indices];
            var indexData = getIndexBufferData();
            mesh.setIndices(indexData);
            mesh.addSubMesh(0, indexAccessor.count, mode);
        } else {
            mesh.addSubMesh(0, vertexCount, mode);
        }
        // BlendShapes
        targets && this._createBlendShape(mesh, gltfMesh, targets, getBlendShapeData);
        mesh.uploadData(!keepMeshData);
        return Promise.resolve(mesh);
    };
    return MeshParser;
}(Parser);
(function() {
    MeshParser._tempVector3 = new Vector3();
})();

var SceneParser$1 = /*#__PURE__*/ function(Parser1) {
    _inherits(SceneParser, Parser1);
    function SceneParser() {
        return Parser1.apply(this, arguments);
    }
    var _proto = SceneParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, gltf = context.gltf;
        var entities = glTFResource.entities;
        var nodes = gltf.nodes, gltfCameras = gltf.cameras;
        if (!nodes) return;
        var defaultSceneRootPromiseInfo = context.defaultSceneRootPromiseInfo;
        var promises = [];
        for(var i = 0; i < nodes.length; i++){
            var gltfNode = nodes[i];
            var cameraID = gltfNode.camera, meshID = gltfNode.mesh, _gltfNode_extensions = gltfNode.extensions, extensions = _gltfNode_extensions === void 0 ? {} : _gltfNode_extensions;
            var KHR_lights_punctual = extensions.KHR_lights_punctual;
            var entity = entities[i];
            if (cameraID !== undefined) {
                this._createCamera(glTFResource, gltfCameras[cameraID], entity);
            }
            if (meshID !== undefined) {
                promises.push(this._createRenderer(context, gltfNode, entity));
            }
            if (KHR_lights_punctual) {
                var lightIndex = KHR_lights_punctual.light;
                var lights = gltf.extensions.KHR_lights_punctual.lights;
                Parser.parseEngineResource("KHR_lights_punctual", lights[lightIndex], entity, context);
            }
        }
        if (glTFResource.defaultSceneRoot) {
            this._createAnimator(context);
        }
        gltf.extensions && delete gltf.extensions["OASIS_materials_remap"];
        AssetPromise.all(promises).then(function() {
            return defaultSceneRootPromiseInfo.resolve(glTFResource.defaultSceneRoot);
        }).catch(defaultSceneRootPromiseInfo.reject);
        return defaultSceneRootPromiseInfo.promise;
    };
    _proto._createCamera = function _createCamera(context, cameraSchema, entity) {
        var orthographic = cameraSchema.orthographic, perspective = cameraSchema.perspective, type = cameraSchema.type;
        var camera = entity.addComponent(Camera);
        if (type === CameraType.ORTHOGRAPHIC) {
            var xmag = orthographic.xmag, ymag = orthographic.ymag, zfar = orthographic.zfar, znear = orthographic.znear;
            camera.isOrthographic = true;
            if (znear !== undefined) {
                camera.nearClipPlane = znear;
            }
            if (zfar !== undefined) {
                camera.farClipPlane = zfar;
            }
            camera.orthographicSize = Math.max(ymag != null ? ymag : 0, xmag != null ? xmag : 0) / 2;
        } else if (type === CameraType.PERSPECTIVE) {
            var aspectRatio = perspective.aspectRatio, yfov = perspective.yfov, zfar1 = perspective.zfar, znear1 = perspective.znear;
            if (aspectRatio !== undefined) {
                camera.aspectRatio = aspectRatio;
            }
            if (yfov !== undefined) {
                camera.fieldOfView = yfov * 180 / Math.PI;
            }
            if (zfar1 !== undefined) {
                camera.farClipPlane = zfar1;
            }
            if (znear1 !== undefined) {
                camera.nearClipPlane = znear1;
            }
        }
        if (!context.cameras) context.cameras = [];
        context.cameras.push(camera);
        // @todo: use engine camera by default
        camera.enabled = false;
    };
    _proto._createRenderer = function _createRenderer(context, gltfNode, entity) {
        var _loop = function(i) {
            var mesh = meshes[meshID][i];
            var renderer = void 0;
            if (skinID !== undefined || blendShapeWeights) {
                context.hasSkinned = true;
                var skinRenderer = entity.addComponent(SkinnedMeshRenderer);
                skinRenderer.mesh = mesh;
                if (skinID !== undefined) {
                    skinRenderer.skin = skins[skinID];
                }
                if (blendShapeWeights) {
                    skinRenderer.blendShapeWeights = new Float32Array(blendShapeWeights);
                }
                renderer = skinRenderer;
            } else {
                renderer = entity.addComponent(MeshRenderer);
                renderer.mesh = mesh;
            }
            var materialIndex = gltfMeshPrimitives[i].material;
            var remapMaterials = gltf.extensions && gltf.extensions["OASIS_materials_remap"];
            if (remapMaterials && remapMaterials[materialIndex]) {
                promises.push(remapMaterials[materialIndex].then(function(mtl) {
                    renderer.setMaterial(mtl);
                }));
            } else {
                var material = (materials == null ? void 0 : materials[materialIndex]) || SceneParser._getDefaultMaterial(engine);
                renderer.setMaterial(material);
                // Enable vertex color if mesh has COLOR_0 vertex element
                mesh.vertexElements.forEach(function(element) {
                    if (element.semantic === "COLOR_0") {
                        renderer.enableVertexColor = true;
                    }
                });
            }
            var _gltfMeshPrimitives_i = gltfMeshPrimitives[i], _gltfMeshPrimitives_i_extensions = _gltfMeshPrimitives_i.extensions, extensions = _gltfMeshPrimitives_i_extensions === void 0 ? {} : _gltfMeshPrimitives_i_extensions;
            var KHR_materials_variants = extensions.KHR_materials_variants;
            if (KHR_materials_variants) {
                Parser.parseEngineResource("KHR_materials_variants", KHR_materials_variants, renderer, context);
            }
        };
        var glTFResource = context.glTFResource, gltf = context.gltf;
        var gltfMeshes = gltf.meshes;
        var engine = glTFResource.engine, meshes = glTFResource.meshes, materials = glTFResource.materials, skins = glTFResource.skins;
        var meshID = gltfNode.mesh, skinID = gltfNode.skin;
        var glTFMesh = gltfMeshes[meshID];
        var gltfMeshPrimitives = glTFMesh.primitives;
        var blendShapeWeights = gltfNode.weights || glTFMesh.weights;
        var promises = [];
        for(var i = 0; i < gltfMeshPrimitives.length; i++)_loop(i);
        return Promise.all(promises);
    };
    _proto._createAnimator = function _createAnimator(context) {
        if (!context.hasSkinned && !context.glTFResource.animations) {
            return;
        }
        var _context_glTFResource = context.glTFResource, defaultSceneRoot = _context_glTFResource.defaultSceneRoot, animations = _context_glTFResource.animations;
        var animator = defaultSceneRoot.addComponent(Animator);
        var animatorController = new AnimatorController();
        var layer = new AnimatorControllerLayer("layer");
        var animatorStateMachine = new AnimatorStateMachine();
        animatorController.addLayer(layer);
        animator.animatorController = animatorController;
        layer.stateMachine = animatorStateMachine;
        if (animations) {
            for(var i = 0; i < animations.length; i++){
                var animationClip = animations[i];
                var name = animationClip.name;
                var uniqueName = animatorStateMachine.makeUniqueStateName(name);
                if (uniqueName !== name) {
                    console.warn("AnimatorState name is existed, name: " + name + " reset to " + uniqueName);
                }
                var animatorState = animatorStateMachine.addState(uniqueName);
                animatorState.clip = animationClip;
            }
        }
    };
    SceneParser._getDefaultMaterial = function _getDefaultMaterial(engine) {
        if (!SceneParser._defaultMaterial) {
            SceneParser._defaultMaterial = new BlinnPhongMaterial(engine);
        }
        return SceneParser._defaultMaterial;
    };
    return SceneParser;
}(Parser);

var SkinParser = /*#__PURE__*/ function(Parser) {
    _inherits(SkinParser, Parser);
    function SkinParser() {
        return Parser.apply(this, arguments);
    }
    var _proto = SkinParser.prototype;
    _proto.parse = function parse(context) {
        var glTFResource = context.glTFResource, gltf = context.gltf; context.buffers;
        var entities = glTFResource.entities;
        var gltfSkins = gltf.skins;
        if (!gltfSkins) return;
        var count = gltfSkins.length;
        var skins = new Array(count);
        for(var i = 0; i < count; i++){
            var _gltfSkins_i = gltfSkins[i], inverseBindMatrices = _gltfSkins_i.inverseBindMatrices, skeleton = _gltfSkins_i.skeleton, joints = _gltfSkins_i.joints, _gltfSkins_i_name = _gltfSkins_i.name, name = _gltfSkins_i_name === void 0 ? "SKIN_" + i : _gltfSkins_i_name;
            var jointCount = joints.length;
            var skin = new Skin(name);
            skin.inverseBindMatrices.length = jointCount;
            // parse IBM
            var accessor = gltf.accessors[inverseBindMatrices];
            var buffer = GLTFUtil.getAccessorBuffer(context, gltf, accessor).data;
            for(var i1 = 0; i1 < jointCount; i1++){
                var inverseBindMatrix = new Matrix();
                inverseBindMatrix.copyFromArray(buffer, i1 * 16);
                skin.inverseBindMatrices[i1] = inverseBindMatrix;
            }
            // get joints
            for(var i2 = 0; i2 < jointCount; i2++){
                var jointIndex = joints[i2];
                var jointName = entities[jointIndex].name;
                skin.joints[i2] = jointName;
                // @todo Temporary solution, but it can alleviate the current BUG, and the skinning data mechanism of SkinnedMeshRenderer will be completely refactored in the future
                for(var j = entities.length - 1; j >= 0; j--){
                    if (jointIndex !== j && entities[j].name === jointName) {
                        entities[j].name = jointName + "_" + j;
                    }
                }
            }
            // get skeleton
            if (skeleton !== undefined) {
                skin.skeleton = entities[skeleton].name;
            } else {
                var rootBone = this._findSkeletonRootBone(joints, entities);
                if (rootBone) {
                    skin.skeleton = rootBone.name;
                } else {
                    throw "Failed to find skeleton root bone.";
                }
            }
            skins[i] = skin;
        }
        glTFResource.skins = skins;
    };
    _proto._findSkeletonRootBone = function _findSkeletonRootBone(joints, entities) {
        var paths = {};
        for(var _iterator = _create_for_of_iterator_helper_loose(joints), _step; !(_step = _iterator()).done;){
            var index = _step.value;
            var path = new Array();
            var entity = entities[index];
            while(entity){
                path.unshift(entity);
                entity = entity.parent;
            }
            paths[index] = path;
        }
        var rootNode = null;
        for(var i = 0;; i++){
            var path1 = paths[joints[0]];
            if (i >= path1.length) {
                return rootNode;
            }
            var entity1 = path1[i];
            for(var j = 1, m = joints.length; j < m; j++){
                path1 = paths[joints[j]];
                if (i >= path1.length || entity1 !== path1[i]) {
                    return rootNode;
                }
            }
            rootNode = entity1;
        }
    };
    return SkinParser;
}(Parser);

var TextureParser = /*#__PURE__*/ function(Parser) {
    _inherits(TextureParser, Parser);
    function TextureParser() {
        return Parser.apply(this, arguments);
    }
    var _proto = TextureParser.prototype;
    _proto.parse = function parse(context) {
        var _this = this;
        var glTFResource = context.glTFResource, gltf = context.gltf, buffers = context.buffers;
        var engine = glTFResource.engine, url = glTFResource.url;
        if (gltf.textures) {
            var texturesPromiseInfo = context.texturesPromiseInfo;
            AssetPromise.all(gltf.textures.map(function(param, index) {
                var sampler = param.sampler, _param_source = param.source, source = _param_source === void 0 ? 0 : _param_source, textureName = param.name;
                var _gltf_images_source = gltf.images[source], uri = _gltf_images_source.uri, bufferViewIndex = _gltf_images_source.bufferView, mimeType = _gltf_images_source.mimeType, imageName = _gltf_images_source.name;
                if (uri) {
                    // TODO: support ktx extension https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_basisu/README.md
                    var index1 = uri.lastIndexOf(".");
                    var ext = uri.substring(index1 + 1);
                    var type = ext.startsWith("ktx") ? AssetType.KTX : AssetType.Texture2D;
                    return engine.resourceManager.load({
                        url: GLTFUtil.parseRelativeUrl(url, uri),
                        type: type
                    }).then(function(texture) {
                        if (!texture.name) {
                            texture.name = textureName || imageName || "texture_" + index1;
                        }
                        if (sampler !== undefined) {
                            _this._parseSampler(texture, gltf.samplers[sampler]);
                        }
                        return texture;
                    });
                } else {
                    var bufferView = gltf.bufferViews[bufferViewIndex];
                    var bufferViewData = GLTFUtil.getBufferViewData(bufferView, buffers);
                    return GLTFUtil.loadImageBuffer(bufferViewData, mimeType).then(function(image) {
                        var texture = new Texture2D(engine, image.width, image.height);
                        texture.setImageSource(image);
                        texture.generateMipmaps();
                        texture.name = textureName || imageName || "texture_" + index;
                        if (sampler !== undefined) {
                            _this._parseSampler(texture, gltf.samplers[sampler]);
                        }
                        return texture;
                    });
                }
            })).then(function(textures) {
                glTFResource.textures = textures;
                texturesPromiseInfo.resolve(textures);
            }).catch(texturesPromiseInfo.reject);
            return texturesPromiseInfo.promise;
        }
    };
    _proto._parseSampler = function _parseSampler(texture, sampler) {
        var magFilter = sampler.magFilter, minFilter = sampler.minFilter, wrapS = sampler.wrapS, wrapT = sampler.wrapT;
        if (magFilter || minFilter) {
            if (magFilter === TextureMagFilter.NEAREST) {
                texture.filterMode = TextureFilterMode.Point;
            } else if (minFilter <= TextureMinFilter.LINEAR_MIPMAP_NEAREST) {
                texture.filterMode = TextureFilterMode.Bilinear;
            } else {
                texture.filterMode = TextureFilterMode.Trilinear;
            }
        }
        if (wrapS) {
            texture.wrapModeU = TextureParser._wrapMap[wrapS];
        }
        if (wrapT) {
            texture.wrapModeV = TextureParser._wrapMap[wrapT];
        }
    };
    return TextureParser;
}(Parser);
(function() {
    var _obj;
    TextureParser._wrapMap = (_obj = {}, _obj[TextureWrapMode.CLAMP_TO_EDGE] = TextureWrapMode$1.Clamp, _obj[TextureWrapMode.MIRRORED_REPEAT] = TextureWrapMode$1.Mirror, _obj[TextureWrapMode.REPEAT] = TextureWrapMode$1.Repeat, _obj);
})();

var Validator = /*#__PURE__*/ function(Parser1) {
    _inherits(Validator, Parser1);
    function Validator() {
        return Parser1.apply(this, arguments);
    }
    var _proto = Validator.prototype;
    _proto.parse = function parse(context) {
        var _context_gltf = context.gltf, version = _context_gltf.asset.version, extensionsUsed = _context_gltf.extensionsUsed, extensionsRequired = _context_gltf.extensionsRequired;
        var gltfVersion = Number(version);
        if (!(gltfVersion >= 2 && gltfVersion < 3)) {
            throw "Only support gltf 2.x.";
        }
        if (extensionsUsed) {
            Logger.info("extensionsUsed: ", extensionsUsed);
            for(var i = 0; i < extensionsUsed.length; i++){
                if (!Parser.hasExtensionParser(extensionsUsed[i])) {
                    Logger.warn("Extension " + extensionsUsed[i] + " is not implemented, you can customize this extension in gltf.");
                }
            }
        }
        if (extensionsRequired) {
            Logger.info("extensionsRequired: " + extensionsRequired);
            for(var i1 = 0; i1 < extensionsRequired.length; i1++){
                var extensionRequired = extensionsRequired[i1];
                if (!Parser.hasExtensionParser(extensionRequired)) {
                    Logger.error("GLTF parser has not supported required extension " + extensionRequired + ".");
                } else {
                    Parser.initialize(extensionRequired);
                }
            }
        }
    };
    return Validator;
}(Parser);

var GLTFParser = /*#__PURE__*/ function() {
    function GLTFParser(pipes) {
        var _this = this;
        this._pipes = [];
        pipes.forEach(function(pipe, index) {
            _this._pipes[index] = new pipe();
        });
    }
    var _proto = GLTFParser.prototype;
    _proto.parse = function parse(context) {
        var _this = this;
        var glTFResource = context.glTFResource;
        var lastPipe;
        return new AssetPromise(function(resolve, reject) {
            _this._pipes.forEach(function(parser) {
                if (lastPipe) {
                    lastPipe = lastPipe.then(function() {
                        return parser.parse(context);
                    });
                    if (lastPipe.cancel) {
                        context.chainPromises.push(lastPipe);
                    }
                } else {
                    lastPipe = parser.parse(context);
                }
            });
            if (lastPipe) {
                lastPipe.then(function() {
                    resolve(glTFResource);
                }).catch(reject);
            }
        });
    };
    return GLTFParser;
}();
(function() {
    GLTFParser.defaultPipeline = new GLTFParser([
        BufferParser,
        Validator,
        TextureParser,
        MaterialParser,
        MeshParser,
        EntityParser,
        SkinParser,
        AnimationParser,
        SceneParser$1
    ]);
})();

/**
 * Product after GLTF parser, usually, `defaultSceneRoot` is only needed to use.
 */ var GLTFResource = /*#__PURE__*/ function(EngineObject) {
    _inherits(GLTFResource, EngineObject);
    function GLTFResource(engine, url) {
        var _this;
        _this = EngineObject.call(this, engine) || this;
        _this.url = url;
        return _this;
    }
    var _proto = GLTFResource.prototype;
    /**
   * @override
   */ _proto.destroy = function destroy() {
        if (this._destroyed) {
            return;
        }
        EngineObject.prototype.destroy.call(this);
        this.defaultSceneRoot.destroy();
        this.textures = null;
        this.materials = null;
        this.meshes = null;
        this.skins = null;
        this.animations = null;
        this.entities = null;
        this.cameras = null;
        this.lights = null;
        this.sceneRoots = null;
        this.variants = null;
    };
    return GLTFResource;
}(EngineObject);

var GLTFLoader = /*#__PURE__*/ function(Loader) {
    _inherits(GLTFLoader, Loader);
    function GLTFLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = GLTFLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _item_params;
        var url = item.url;
        var context = new ParserContext(url);
        var glTFResource = new GLTFResource(resourceManager.engine, url);
        var masterPromiseInfo = context.masterPromiseInfo;
        context.glTFResource = glTFResource;
        var _item_params_keepMeshData;
        context.keepMeshData = (_item_params_keepMeshData = (_item_params = item.params) == null ? void 0 : _item_params.keepMeshData) != null ? _item_params_keepMeshData : false;
        masterPromiseInfo.onCancel(function() {
            var chainPromises = context.chainPromises;
            for(var _iterator = _create_for_of_iterator_helper_loose(chainPromises), _step; !(_step = _iterator()).done;){
                var promise = _step.value;
                promise.cancel();
            }
        });
        GLTFParser.defaultPipeline.parse(context).then(masterPromiseInfo.resolve).catch(function(e) {
            console.error(e);
            masterPromiseInfo.reject("Error loading glTF model from " + url + " .");
        });
        return context.promiseMap;
    };
    return GLTFLoader;
}(Loader);
GLTFLoader = __decorate([
    resourceLoader(AssetType.Prefab, [
        "gltf",
        "glb"
    ])
], GLTFLoader);

var _HDRLoader;
var PI = Math.PI;
var HDRLoader = (_HDRLoader = /*#__PURE__*/ function(Loader) {
    _inherits(HDRLoader1, Loader);
    function HDRLoader1() {
        return Loader.apply(this, arguments);
    }
    var _proto = HDRLoader1.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var engine = resourceManager.engine;
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(buffer) {
                var uint8Array = new Uint8Array(buffer);
                var _HDRLoader__parseHeader = HDRLoader._parseHeader(uint8Array), width = _HDRLoader__parseHeader.width, height = _HDRLoader__parseHeader.height, dataPosition = _HDRLoader__parseHeader.dataPosition;
                var pixels = HDRLoader._readPixels(uint8Array.subarray(dataPosition), width, height);
                var cubeSize = height >> 1;
                var cubeMapData = HDRLoader._convertToCubemap(pixels, width, height, cubeSize);
                var texture = new TextureCube(engine, cubeSize);
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    texture.setPixelBuffer(TextureCubeFace.PositiveX + faceIndex, cubeMapData[faceIndex], 0);
                }
                texture.generateMipmaps();
                resolve(texture);
            }).catch(reject);
        });
    };
    HDRLoader1._convertToCubemap = function _convertToCubemap(pixels, inputWidth, inputHeight, size) {
        if (!pixels) {
            throw "ConvertPanoramaToCubemap: input cannot be null";
        }
        if (pixels.length != inputWidth * inputHeight * 4) {
            throw "ConvertPanoramaToCubemap: input size is wrong";
        }
        var textureRight = this._createCubemapData(size, this._faceRight, pixels, inputWidth, inputHeight);
        var textureLeft = this._createCubemapData(size, this._faceLeft, pixels, inputWidth, inputHeight);
        var textureUp = this._createCubemapData(size, this._faceUp, pixels, inputWidth, inputHeight);
        var textureDown = this._createCubemapData(size, this._faceBottom, pixels, inputWidth, inputHeight);
        var textureFront = this._createCubemapData(size, this._faceFront, pixels, inputWidth, inputHeight);
        var textureBack = this._createCubemapData(size, this._faceBack, pixels, inputWidth, inputHeight);
        return [
            textureRight,
            textureLeft,
            textureUp,
            textureDown,
            textureFront,
            textureBack
        ];
    };
    HDRLoader1._createCubemapData = function _createCubemapData(texSize, faceData, pixels, inputWidth, inputHeight) {
        var textureArray = new Uint8ClampedArray(texSize * texSize * 4);
        var rotDX1 = this._tempVector3.set(0, 0, 0).add(faceData[1]).subtract(faceData[0]).scale(1 / texSize);
        var rotDX2 = this._temp2Vector3.set(0, 0, 0).add(faceData[3]).subtract(faceData[2]).scale(1 / texSize);
        var dy = 1 / texSize;
        var fy = 0;
        for(var y = 0; y < texSize; y++){
            var xv1 = this._temp3Vector3.set(0, 0, 0).add(faceData[0]);
            var xv2 = this._temp4Vector3.set(0, 0, 0).add(faceData[2]);
            for(var x = 0; x < texSize; x++){
                var v = this._temp5Vector3.set(0, 0, 0).add(xv2).subtract(xv1).scale(fy).add(xv1);
                v.normalize();
                var color = this._calcProjectionSpherical(v, pixels, inputWidth, inputHeight);
                this._RGBEToLinear(color);
                this._linearToRGBM(color, 5);
                // 4 channels per pixels
                var index = y * texSize * 4 + x * 4;
                textureArray[index] = color.r;
                textureArray[index + 1] = color.g;
                textureArray[index + 2] = color.b;
                textureArray[index + 3] = color.a;
                xv1.add(rotDX1);
                xv2.add(rotDX2);
            }
            fy += dy;
        }
        return textureArray;
    };
    HDRLoader1._calcProjectionSpherical = function _calcProjectionSpherical(vDir, pixels, inputWidth, inputHeight) {
        var theta = Math.atan2(vDir.z, -vDir.x);
        var phi = Math.acos(vDir.y);
        while(theta < -PI){
            theta += 2 * PI;
        }
        while(theta > PI){
            theta -= 2 * PI;
        }
        var dx = theta / PI;
        var dy = phi / PI;
        // recenter.
        dx = dx * 0.5 + 0.5;
        var px = Math.round(dx * inputWidth);
        if (px < 0) {
            px = 0;
        } else if (px >= inputWidth) {
            px = inputWidth - 1;
        }
        var py = Math.round(dy * inputHeight);
        if (py < 0) {
            py = 0;
        } else if (py >= inputHeight) {
            py = inputHeight - 1;
        }
        var inputY = inputHeight - py - 1;
        var index = inputY * inputWidth * 4 + px * 4;
        var r = pixels[index];
        var g = pixels[index + 1];
        var b = pixels[index + 2];
        var a = pixels[index + 3];
        return new Color(r, g, b, a);
    };
    HDRLoader1._readStringLine = function _readStringLine(uint8array, startIndex) {
        var line = "";
        var character = "";
        for(var i = startIndex; i < uint8array.length - startIndex; i++){
            character = String.fromCharCode(uint8array[i]);
            if (character == "\n") {
                break;
            }
            line += character;
        }
        return line;
    };
    HDRLoader1._parseHeader = function _parseHeader(uint8array) {
        var height = 0;
        var width = 0;
        var line = this._readStringLine(uint8array, 0);
        if (line[0] != "#" || line[1] != "?") {
            throw "Bad HDR Format.";
        }
        var endOfHeader = false;
        var findFormat = false;
        var lineIndex = 0;
        do {
            lineIndex += line.length + 1;
            line = this._readStringLine(uint8array, lineIndex);
            if (line == "FORMAT=32-bit_rle_rgbe") {
                findFormat = true;
            } else if (line.length == 0) {
                endOfHeader = true;
            }
        }while (!endOfHeader);
        if (!findFormat) {
            throw "HDR Bad header format, unsupported FORMAT";
        }
        lineIndex += line.length + 1;
        line = this._readStringLine(uint8array, lineIndex);
        var sizeRegexp = /^\-Y (.*) \+X (.*)$/g;
        var match = sizeRegexp.exec(line);
        // TODO. Support +Y and -X if needed.
        if (!match || match.length < 3) {
            throw "HDR Bad header format, no size";
        }
        width = parseInt(match[2]);
        height = parseInt(match[1]);
        if (width < 8 || width > 0x7fff) {
            throw "HDR Bad header format, unsupported size";
        }
        lineIndex += line.length + 1;
        return {
            height: height,
            width: width,
            dataPosition: lineIndex
        };
    };
    HDRLoader1._readPixels = function _readPixels(buffer, width, height) {
        var scanLineWidth = width;
        var byteLength = buffer.byteLength;
        var dataRGBA = new Uint8Array(4 * width * height);
        var offset = 0, pos = 0;
        var ptrEnd = 4 * scanLineWidth;
        var rgbeStart = new Uint8Array(4);
        var scanLineBuffer = new Uint8Array(ptrEnd);
        var numScanLines = height; // read in each successive scanLine
        while(numScanLines > 0 && pos < byteLength){
            rgbeStart[0] = buffer[pos++];
            rgbeStart[1] = buffer[pos++];
            rgbeStart[2] = buffer[pos++];
            rgbeStart[3] = buffer[pos++];
            if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanLineWidth) {
                throw "HDR Bad header format, wrong scan line width";
            }
            // read each of the four channels for the scanline into the buffer
            // first red, then green, then blue, then exponent
            var ptr = 0, count = void 0;
            while(ptr < ptrEnd && pos < byteLength){
                count = buffer[pos++];
                var isEncodedRun = count > 128;
                if (isEncodedRun) count -= 128;
                if (0 === count || ptr + count > ptrEnd) {
                    throw "HDR Bad Format, bad scanline data (run)";
                }
                if (isEncodedRun) {
                    // a (encoded) run of the same value
                    var byteValue = buffer[pos++];
                    for(var i = 0; i < count; i++){
                        scanLineBuffer[ptr++] = byteValue;
                    } //ptr += count;
                } else {
                    // a literal-run
                    scanLineBuffer.set(buffer.subarray(pos, pos + count), ptr);
                    ptr += count;
                    pos += count;
                }
            } // now convert data from buffer into rgba
            // first red, then green, then blue, then exponent (alpha)
            var l = scanLineWidth; //scanLine_buffer.byteLength;
            for(var i1 = 0; i1 < l; i1++){
                var off = 0;
                dataRGBA[offset] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 1] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 2] = scanLineBuffer[i1 + off];
                off += scanLineWidth;
                dataRGBA[offset + 3] = scanLineBuffer[i1 + off];
                offset += 4;
            }
            numScanLines--;
        }
        return dataRGBA;
    };
    HDRLoader1._RGBEToLinear = function _RGBEToLinear(color) {
        var scaleFactor = Math.pow(2, color.a - 128) / 255;
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a = 1;
    };
    HDRLoader1._linearToRGBM = function _linearToRGBM(color, maxRange) {
        var maxRGB = Math.max(color.r, Math.max(color.g, color.b));
        var M = Math.min(maxRGB / maxRange, 1);
        M = Math.ceil(M * 255);
        var scaleFactor = 65025 / (M * maxRange); // 255 * (255 / (M * maxRange) )
        color.r *= scaleFactor;
        color.g *= scaleFactor;
        color.b *= scaleFactor;
        color.a *= M;
    };
    return HDRLoader1;
}(Loader), function() {
    _HDRLoader._rightBottomBack = new Vector3(1.0, -1.0, -1.0);
}(), function() {
    _HDRLoader._rightBottomFront = new Vector3(1.0, -1.0, 1.0);
}(), function() {
    _HDRLoader._rightUpBack = new Vector3(1.0, 1.0, -1.0);
}(), function() {
    _HDRLoader._rightUpFront = new Vector3(1.0, 1.0, 1.0);
}(), function() {
    _HDRLoader._leftBottomBack = new Vector3(-1.0, -1.0, -1.0);
}(), function() {
    _HDRLoader._leftBottomFront = new Vector3(-1.0, -1.0, 1.0);
}(), function() {
    _HDRLoader._leftUpBack = new Vector3(-1.0, 1.0, -1.0);
}(), function() {
    _HDRLoader._leftUpFront = new Vector3(-1.0, 1.0, 1.0);
}(), function() {
    _HDRLoader._faceRight = [
        _HDRLoader._rightBottomBack,
        _HDRLoader._rightBottomFront,
        _HDRLoader._rightUpBack,
        _HDRLoader._rightUpFront
    ];
}(), function() {
    _HDRLoader._faceLeft = [
        _HDRLoader._leftBottomFront,
        _HDRLoader._leftBottomBack,
        _HDRLoader._leftUpFront,
        _HDRLoader._leftUpBack
    ];
}(), function() {
    _HDRLoader._faceUp = [
        _HDRLoader._leftBottomFront,
        _HDRLoader._rightBottomFront,
        _HDRLoader._leftBottomBack,
        _HDRLoader._rightBottomBack
    ];
}(), function() {
    _HDRLoader._faceBottom = [
        _HDRLoader._leftUpBack,
        _HDRLoader._rightUpBack,
        _HDRLoader._leftUpFront,
        _HDRLoader._rightUpFront
    ];
}(), function() {
    _HDRLoader._faceFront = [
        _HDRLoader._leftBottomBack,
        _HDRLoader._rightBottomBack,
        _HDRLoader._leftUpBack,
        _HDRLoader._rightUpBack
    ];
}(), function() {
    _HDRLoader._faceBack = [
        _HDRLoader._rightBottomFront,
        _HDRLoader._leftBottomFront,
        _HDRLoader._rightUpFront,
        _HDRLoader._leftUpFront
    ];
}(), function() {
    _HDRLoader._tempVector3 = new Vector3();
}(), function() {
    _HDRLoader._temp2Vector3 = new Vector3();
}(), function() {
    _HDRLoader._temp3Vector3 = new Vector3();
}(), function() {
    _HDRLoader._temp4Vector3 = new Vector3();
}(), function() {
    _HDRLoader._temp5Vector3 = new Vector3();
}(), _HDRLoader);
HDRLoader = __decorate([
    resourceLoader(AssetType.HDR, [
        "hdr"
    ])
], HDRLoader);

var JSONLoader = /*#__PURE__*/ function(Loader) {
    _inherits(JSONLoader, Loader);
    function JSONLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = JSONLoader.prototype;
    _proto.load = function load(item) {
        return this.request(item.url, _extends({}, item, {
            type: "json"
        }));
    };
    return JSONLoader;
}(Loader);
JSONLoader = __decorate([
    resourceLoader(AssetType.JSON, [
        "json"
    ], false)
], JSONLoader);

var HEADER_LEN = 12 + 13 * 4; // identifier + header elements (not including key value meta-data pairs)
// load types
var COMPRESSED_2D = 0; // uses a gl.compressedTexImage2D()
function getMipmaps(ktxContainer, loadMipmaps) {
    var mipmaps = [];
    // initialize width & height for level 1
    var dataOffset = HEADER_LEN + ktxContainer.bytesOfKeyValueData;
    var width = ktxContainer.pixelWidth;
    var height = ktxContainer.pixelHeight;
    var mipmapCount = loadMipmaps ? ktxContainer.numberOfMipmapLevels : 1;
    for(var level = 0; level < mipmapCount; level++){
        var imageSize = new Int32Array(ktxContainer.buffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
        dataOffset += 4; // size of the image + 4 for the imageSize field
        for(var face = 0; face < ktxContainer.numberOfFaces; face++){
            var byteArray = new Uint8Array(ktxContainer.buffer, dataOffset, imageSize);
            mipmaps.push({
                data: byteArray,
                width: width,
                height: height
            });
            dataOffset += imageSize;
            dataOffset += 3 - (imageSize + 3) % 4; // add padding for odd sized image
        }
        width = Math.max(1.0, width * 0.5);
        height = Math.max(1.0, height * 0.5);
    }
    return mipmaps;
}
/**
 * Checks if the given data starts with a KTX file identifier.
 * @param data the data to check
 * @returns true if the data is a KTX file or false otherwise
 */ function isValid(data) {
    if (data.byteLength >= 12) {
        // '«', 'K', 'T', 'X', ' ', '1', '1', '»', '\r', '\n', '\x1A', '\n'
        var identifier = new Uint8Array(data, 0, 12);
        if (identifier[0] === 0xab && identifier[1] === 0x4b && identifier[2] === 0x54 && identifier[3] === 0x58 && identifier[4] === 0x20 && identifier[5] === 0x31 && identifier[6] === 0x31 && identifier[7] === 0xbb && identifier[8] === 0x0d && identifier[9] === 0x0a && identifier[10] === 0x1a && identifier[11] === 0x0a) {
            return true;
        }
    }
    return false;
}
function getEngineFormat(internalFormat) {
    switch(internalFormat){
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT3_EXT:
        // case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
        // break;
        case GLCompressedTextureInternalFormat.RGB_S3TC_DXT1_EXT:
            return TextureFormat.DXT1;
        case GLCompressedTextureInternalFormat.RGBA_S3TC_DXT5_EXT:
            return TextureFormat.DXT5;
        case GLCompressedTextureInternalFormat.RGB_ETC1_WEBGL:
            return TextureFormat.ETC1_RGB;
        case GLCompressedTextureInternalFormat.RGB8_ETC2:
            return TextureFormat.ETC2_RGB;
        case GLCompressedTextureInternalFormat.RGB8_PUNCHTHROUGH_ALPHA1_ETC2:
            return TextureFormat.ETC2_RGBA5;
        case GLCompressedTextureInternalFormat.RGBA8_ETC2_EAC:
            return TextureFormat.ETC2_RGBA8;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGB2;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_2BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA2;
        case GLCompressedTextureInternalFormat.RGB_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGB4;
        case GLCompressedTextureInternalFormat.RGBA_PVRTC_4BPPV1_IMG:
            return TextureFormat.PVRTC_RGBA4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_4X4_KHR:
            return TextureFormat.ASTC_4x4;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_5X5_KHR:
            return TextureFormat.ASTC_5x5;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_6X6_KHR:
            return TextureFormat.ASTC_6x6;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_8X8_KHR:
            return TextureFormat.ASTC_8x8;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_10X10_KHR:
            return TextureFormat.ASTC_10x10;
        case GLCompressedTextureInternalFormat.RGBA_ASTC_12X12_KHR:
            return TextureFormat.ASTC_12x12;
        default:
            var formatName = GLCompressedTextureInternalFormat[internalFormat];
            throw new Error("this format is not supported in Galacean Engine: " + formatName);
    }
}
/**
 * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
 * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
 */ var khronosTextureContainerParser = {
    /**
   *
   * @param buffer contents of the KTX container file
   * @param facesExpected should be either 1 or 6, based whether a cube texture or or
   * @param threeDExpected provision for indicating that data should be a 3D texture, not implemented
   * @param textureArrayExpected provision for indicating that data should be a texture array, not implemented
   * @param mapEngineFormat get Galacean Engine native TextureFormat?
   */ parse: function parse(buffer, facesExpected, withMipmaps, mapEngineFormat) {
        if (mapEngineFormat === void 0) mapEngineFormat = false;
        if (!isValid(buffer)) {
            throw new Error("khronosTextureContainerParser: invalid KTX file, texture missing KTX identifier");
        }
        // load the reset of the header in native 32 bit uint
        var dataSize = Uint32Array.BYTES_PER_ELEMENT;
        var headerDataView = new DataView(buffer, 12, 13 * dataSize);
        var endianness = headerDataView.getUint32(0, true);
        var littleEndian = endianness === 0x04030201;
        var parsedResult = {
            buffer: buffer,
            glType: headerDataView.getUint32(1 * dataSize, littleEndian),
            glTypeSize: headerDataView.getUint32(2 * dataSize, littleEndian),
            glFormat: headerDataView.getUint32(3 * dataSize, littleEndian),
            glInternalFormat: headerDataView.getUint32(4 * dataSize, littleEndian),
            glBaseInternalFormat: headerDataView.getUint32(5 * dataSize, littleEndian),
            pixelWidth: headerDataView.getUint32(6 * dataSize, littleEndian),
            pixelHeight: headerDataView.getUint32(7 * dataSize, littleEndian),
            pixelDepth: headerDataView.getUint32(8 * dataSize, littleEndian),
            numberOfArrayElements: headerDataView.getUint32(9 * dataSize, littleEndian),
            numberOfFaces: headerDataView.getUint32(10 * dataSize, littleEndian),
            numberOfMipmapLevels: headerDataView.getUint32(11 * dataSize, littleEndian),
            bytesOfKeyValueData: headerDataView.getUint32(12 * dataSize, littleEndian),
            // would need to make this more elaborate & adjust checks above to support more than one load type
            loadType: COMPRESSED_2D
        };
        // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
        if (parsedResult.glType !== 0) {
            throw new Error("only compressed formats currently supported");
        } else {
            // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
            parsedResult.numberOfMipmapLevels = Math.max(1, parsedResult.numberOfMipmapLevels);
        }
        if (parsedResult.pixelHeight === 0 || parsedResult.pixelDepth !== 0) {
            throw new Error("only 2D textures currently supported");
        }
        if (parsedResult.numberOfArrayElements !== 0) {
            throw new Error("texture arrays not currently supported");
        }
        if (parsedResult.numberOfFaces !== facesExpected) {
            throw new Error("number of faces expected" + facesExpected + ", but found " + parsedResult.numberOfFaces);
        }
        if (withMipmaps) {
            parsedResult.mipmaps = getMipmaps(parsedResult, true);
        }
        if (mapEngineFormat) {
            parsedResult.engineFormat = getEngineFormat(parsedResult.glInternalFormat);
        }
        return parsedResult;
    }
};

function parseSingleKTX(data) {
    var ktx = khronosTextureContainerParser.parse(data, 1, true, true);
    return {
        mipmaps: ktx.mipmaps,
        engineFormat: ktx.engineFormat,
        internalFormat: ktx.glInternalFormat,
        width: ktx.pixelWidth,
        height: ktx.pixelHeight
    };
}
function parseCubeKTX(dataArray) {
    var mipmapsFaces = [];
    var internalFormat;
    var engineFormat;
    var width;
    var height;
    for(var i = 0; i < dataArray.length; i++){
        var ktx = khronosTextureContainerParser.parse(dataArray[i], 1, true, true);
        mipmapsFaces.push(ktx.mipmaps);
        if (i === 0) {
            width = ktx.pixelWidth;
            height = ktx.pixelHeight;
            internalFormat = ktx.glInternalFormat;
            engineFormat = ktx.engineFormat;
        }
    }
    return {
        mipmapsFaces: mipmapsFaces,
        engineFormat: engineFormat,
        internalFormat: internalFormat,
        width: width,
        height: height
    };
}

var KTXCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXCubeLoader, Loader);
    function KTXCubeLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = KTXCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(item.urls.map(function(url) {
                return _this.request(url, _extends({}, item, {
                    type: "arraybuffer"
                }));
            })).then(function(data) {
                var parsedData = parseCubeKTX(data);
                var width = parsedData.width, mipmapsFaces = parsedData.mipmapsFaces, engineFormat = parsedData.engineFormat;
                var mipmap = mipmapsFaces[0].length > 1;
                var texture = new TextureCube(resourceManager.engine, width, engineFormat, mipmap);
                for(var face = 0; face < 6; face++){
                    var length = mipmapsFaces[face].length;
                    for(var miplevel = 0; miplevel < length; miplevel++){
                        var _mipmapsFaces_face_miplevel = mipmapsFaces[face][miplevel], _$data = _mipmapsFaces_face_miplevel.data, width1 = _mipmapsFaces_face_miplevel.width, height = _mipmapsFaces_face_miplevel.height;
                        texture.setPixelBuffer(TextureCubeFace.PositiveX + face, _$data, miplevel, 0, 0, width1, height);
                    }
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXCubeLoader;
}(Loader);
KTXCubeLoader = __decorate([
    resourceLoader(AssetType.KTXCube, [])
], KTXCubeLoader);

var KTXLoader = /*#__PURE__*/ function(Loader) {
    _inherits(KTXLoader, Loader);
    function KTXLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = KTXLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(bin) {
                var parsedData = parseSingleKTX(bin);
                var width = parsedData.width, height = parsedData.height, mipmaps = parsedData.mipmaps, engineFormat = parsedData.engineFormat;
                var mipmap = mipmaps.length > 1;
                var texture = new Texture2D(resourceManager.engine, width, height, engineFormat, mipmap);
                for(var miplevel = 0; miplevel < mipmaps.length; miplevel++){
                    var _mipmaps_miplevel = mipmaps[miplevel], width1 = _mipmaps_miplevel.width, height1 = _mipmaps_miplevel.height, data = _mipmaps_miplevel.data;
                    texture.setPixelBuffer(data, miplevel, 0, 0, width1, height1);
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return KTXLoader;
}(Loader);
KTXLoader = __decorate([
    resourceLoader(AssetType.KTX, [
        "ktx"
    ])
], KTXLoader);

var MaterialLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MaterialLoader, Loader);
    function MaterialLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = MaterialLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(json) {
                var _loop = function(key) {
                    var _shaderData_key = shaderData[key], type = _shaderData_key.type, value = _shaderData_key.value;
                    switch(type){
                        case "Vector2":
                            materialShaderData.setVector2(key, new Vector2(value.x, value.y));
                            break;
                        case "Vector3":
                            materialShaderData.setVector3(key, new Vector3(value.x, value.y, value.z));
                            break;
                        case "Vector4":
                            materialShaderData.setVector4(key, new Vector4(value.x, value.y, value.z, value.w));
                            break;
                        case "Color":
                            materialShaderData.setColor(key, new Color(value.r, value.g, value.b, value.a));
                            break;
                        case "Float":
                            materialShaderData.setFloat(key, value);
                            break;
                        case "Texture":
                            texturePromises.push(// @ts-ignore
                            resourceManager.getResourceByRef(value).then(function(texture) {
                                materialShaderData.setTexture(key, texture);
                            }));
                            break;
                    }
                };
                var engine = resourceManager.engine;
                var name = json.name, shader = json.shader, shaderData = json.shaderData, macros = json.macros, renderState = json.renderState;
                var material;
                switch(shader){
                    case "pbr":
                        material = new PBRMaterial(engine);
                        break;
                    case "pbr-specular":
                        material = new PBRSpecularMaterial(engine);
                        break;
                    case "unlit":
                        material = new UnlitMaterial(engine);
                        break;
                    case "blinn-phong":
                        material = new BlinnPhongMaterial(engine);
                        break;
                    case "bake-pbr":
                        // @todo refactor custom shader later
                        // @ts-ignore
                        material = new PBRBaseMaterial(engine, Shader.find("bake-pbr"));
                        break;
                }
                material.name = name;
                var texturePromises = new Array();
                var materialShaderData = material.shaderData;
                for(var key in shaderData)_loop(key);
                for(var i = 0, length = macros.length; i < length; i++){
                    var _macros_i = macros[i], name1 = _macros_i.name, value = _macros_i.value;
                    if (value == undefined) {
                        materialShaderData.enableMacro(name1);
                    } else {
                        materialShaderData.enableMacro(name1, value);
                    }
                }
                for(var key1 in renderState){
                    material[key1] = renderState[key1];
                }
                return Promise.all(texturePromises).then(function() {
                    resolve(material);
                });
            }).catch(reject);
        });
    };
    return MaterialLoader;
}(Loader);
MaterialLoader = __decorate([
    resourceLoader(AssetType.Material, [
        "json"
    ])
], MaterialLoader);

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

var BufferReader = /*#__PURE__*/ function() {
    function BufferReader(buffer, byteOffset, byteLength, littleEndian) {
        if (byteOffset === void 0) byteOffset = 0;
        if (littleEndian === void 0) littleEndian = true;
        this.buffer = buffer;
        // byteLength = byteLength ?? _buffer.byteLength;
        this._dataView = new DataView(buffer);
        this._littleEndian = littleEndian;
        this._offset = byteOffset;
    }
    var _proto = BufferReader.prototype;
    _proto.nextUint8 = function nextUint8() {
        var value = this._dataView.getUint8(this._offset);
        this._offset += 1;
        return value;
    };
    _proto.nextUint16 = function nextUint16() {
        var value = this._dataView.getUint16(this._offset, this._littleEndian);
        this._offset += 2;
        return value;
    };
    _proto.nextUint32 = function nextUint32() {
        var value = this._dataView.getUint32(this._offset, this._littleEndian);
        this._offset += 4;
        return value;
    };
    _proto.nextInt32 = function nextInt32() {
        var value = this._dataView.getInt32(this._offset, this._littleEndian);
        this._offset += 4;
        return value;
    };
    _proto.nextInt32Array = function nextInt32Array(len) {
        var value = new Int32Array(this.buffer, this._offset, len);
        this._offset += 4 * len;
        return value;
    };
    _proto.nextFloat32 = function nextFloat32() {
        var value = this._dataView.getFloat32(this._offset, this._littleEndian);
        this._offset += 4;
        return value;
    };
    _proto.nextFloat32Array = function nextFloat32Array(len) {
        var value = new Float32Array(this.buffer, this._offset, len);
        this._offset += 4 * len;
        return value;
    };
    _proto.nextUint32Array = function nextUint32Array(len) {
        var value = new Uint32Array(this.buffer, this._offset, len);
        this._offset += 4 * len;
        return value;
    };
    _proto.nextUint8Array = function nextUint8Array(len) {
        var value = new Uint8Array(this.buffer, this._offset, len);
        this._offset += len;
        return value;
    };
    _proto.nextUint64 = function nextUint64() {
        var left = this._dataView.getUint32(this._offset, this._littleEndian);
        var right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
        var value = left + Math.pow(2, 32) * right;
        this._offset += 8;
        return value;
    };
    _proto.nextStr = function nextStr() {
        var strByteLength = this.nextUint16();
        var uint8Array = new Uint8Array(this.buffer, this._offset, strByteLength);
        this._offset += strByteLength;
        return GLTFUtil.decodeText(uint8Array);
    };
    /**
   * image data 放在最后
   */ _proto.nextImageData = function nextImageData(count) {
        return this.buffer.slice(this._offset);
    };
    _proto.nextImagesData = function nextImagesData(count) {
        var imagesLen = new Array(count);
        // Start offset of Uint32Array should be a multiple of 4. ref: https://stackoverflow.com/questions/15417310/why-typed-array-constructors-require-offset-to-be-multiple-of-underlying-type-si
        for(var i = 0; i < count; i++){
            var len = this._dataView.getUint32(this._offset, this._littleEndian);
            imagesLen[i] = len;
            this._offset += 4;
        }
        var imagesData = [];
        for(var i1 = 0; i1 < count; i1++){
            var len1 = imagesLen[i1];
            var buffer = this.buffer.slice(this._offset, this._offset + len1);
            this._offset += len1;
            imagesData.push(buffer);
        }
        return imagesData;
    };
    _proto.skip = function skip(bytes) {
        this._offset += bytes;
        return this;
    };
    _proto.scan = function scan(maxByteLength, term) {
        if (term === void 0) term = 0x00;
        var byteOffset = this._offset;
        var byteLength = 0;
        while(this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength){
            byteLength++;
            this._offset++;
        }
        if (byteLength < maxByteLength) this._offset++;
        return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
    };
    _create_class(BufferReader, [
        {
            key: "offset",
            get: function get() {
                return this._offset;
            }
        }
    ]);
    return BufferReader;
}();
(function() {
    BufferReader.imageMapping = {
        0: "image/png",
        1: "image/jpg",
        2: "image/webp",
        3: "ktx"
    };
})();

var decoderMap = {};
/**
 * Decoder decorator generator.
 * @param type - resource file type.
 * @returns Decoder decorator
 */ function decoder(type) {
    return function(target) {
        decoderMap[type] = target;
    };
}

var FileHeader = /*#__PURE__*/ function() {
    function FileHeader() {
        this.totalLength = 0;
        this.version = 0;
        this.type = "";
        this.name = "";
        this.headerLength = 0;
    }
    FileHeader.decode = function decode(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var totalLen = dataView.getUint32(0, true);
        var fileVersion = dataView.getUint8(4);
        var typeLen = dataView.getUint16(5, true);
        var typeUint8Array = new Uint8Array(arrayBuffer, 7, typeLen);
        var nameLen = dataView.getUint16(7 + typeLen, true);
        var nameUint8Array = new Uint8Array(arrayBuffer, 9 + typeLen, nameLen);
        var name = GLTFUtil.decodeText(nameUint8Array);
        var type = GLTFUtil.decodeText(typeUint8Array);
        var header = new FileHeader();
        header.totalLength = totalLen;
        header.name = name;
        header.type = type;
        header.version = fileVersion;
        header.headerLength = nameUint8Array.byteLength + typeUint8Array.byteLength + 9;
        return header;
    };
    _create_class(FileHeader, [
        {
            key: "dataLength",
            get: function get() {
                return this.totalLength - this.headerLength;
            }
        }
    ]);
    return FileHeader;
}();

var MeshDecoder = /*#__PURE__*/ function() {
    function MeshDecoder() {}
    MeshDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve) {
            var modelMesh = new ModelMesh(engine);
            var jsonDataString = bufferReader.nextStr();
            var encodedMeshData = JSON.parse(jsonDataString);
            // @ts-ignore Vector3 is not compatible with {x: number, y: number, z: number}.
            encodedMeshData.bounds && modelMesh.bounds.copyFrom(encodedMeshData.bounds);
            var offset = Math.ceil(bufferReader.offset / 4) * 4;
            var float32Array = new Float32Array(bufferReader.buffer, encodedMeshData.positions.start + offset, (encodedMeshData.positions.end - encodedMeshData.positions.start) / 4);
            var vertexCount = float32Array.length / 3;
            var positions = float32ArrayToVector3(float32Array, vertexCount);
            modelMesh.setPositions(positions);
            if (encodedMeshData.normals) {
                var float32Array1 = new Float32Array(bufferReader.buffer, encodedMeshData.normals.start + offset, (encodedMeshData.normals.end - encodedMeshData.normals.start) / 4);
                var normals = float32ArrayToVector3(float32Array1, vertexCount);
                modelMesh.setNormals(normals);
            }
            if (encodedMeshData.uvs) {
                var float32Array2 = new Float32Array(bufferReader.buffer, encodedMeshData.uvs.start + offset, (encodedMeshData.uvs.end - encodedMeshData.uvs.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array2, vertexCount));
            }
            if (encodedMeshData.uv1) {
                var float32Array3 = new Float32Array(bufferReader.buffer, encodedMeshData.uv1.start + offset, (encodedMeshData.uv1.end - encodedMeshData.uv1.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array3, vertexCount), 1);
            }
            if (encodedMeshData.uv2) {
                var float32Array4 = new Float32Array(bufferReader.buffer, encodedMeshData.uv2.start + offset, (encodedMeshData.uv2.end - encodedMeshData.uv2.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array4, vertexCount), 2);
            }
            if (encodedMeshData.uv3) {
                var float32Array5 = new Float32Array(bufferReader.buffer, encodedMeshData.uv3.start + offset, (encodedMeshData.uv3.end - encodedMeshData.uv3.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array5, vertexCount), 3);
            }
            if (encodedMeshData.uv4) {
                var float32Array6 = new Float32Array(bufferReader.buffer, encodedMeshData.uv4.start + offset, (encodedMeshData.uv4.end - encodedMeshData.uv4.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array6, vertexCount), 4);
            }
            if (encodedMeshData.uv5) {
                var float32Array7 = new Float32Array(bufferReader.buffer, encodedMeshData.uv5.start + offset, (encodedMeshData.uv5.end - encodedMeshData.uv5.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array7, vertexCount), 5);
            }
            if (encodedMeshData.uv6) {
                var float32Array8 = new Float32Array(bufferReader.buffer, encodedMeshData.uv6.start + offset, (encodedMeshData.uv6.end - encodedMeshData.uv6.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array8, vertexCount), 6);
            }
            if (encodedMeshData.uv7) {
                var float32Array9 = new Float32Array(bufferReader.buffer, encodedMeshData.uv7.start + offset, (encodedMeshData.uv7.end - encodedMeshData.uv7.start) / 4);
                modelMesh.setUVs(float32ArrayToVector2(float32Array9, vertexCount), 7);
            }
            if (encodedMeshData.colors) {
                var float32Array10 = new Float32Array(bufferReader.buffer, encodedMeshData.colors.start + offset, (encodedMeshData.colors.end - encodedMeshData.colors.start) / 4);
                modelMesh.setColors(float32ArrayToVColor(float32Array10, vertexCount));
            }
            if (encodedMeshData.boneWeights) {
                var float32Array11 = new Float32Array(bufferReader.buffer, encodedMeshData.boneWeights.start + offset, (encodedMeshData.boneWeights.end - encodedMeshData.boneWeights.start) / 4);
                modelMesh.setBoneWeights(float32ArrayToVector4(float32Array11, vertexCount));
            }
            if (encodedMeshData.boneIndices) {
                var float32Array12 = new Float32Array(bufferReader.buffer, encodedMeshData.boneIndices.start + offset, (encodedMeshData.boneIndices.end - encodedMeshData.boneIndices.start) / 4);
                modelMesh.setBoneIndices(float32ArrayToVector4(float32Array12, vertexCount));
            }
            if (encodedMeshData.blendShapes) {
                encodedMeshData.blendShapes.forEach(function(blendShapeData) {
                    var blendShape = new BlendShape(blendShapeData.name);
                    blendShapeData.frames.forEach(function(frameData) {
                        var positionArray = new Float32Array(bufferReader.buffer, frameData.deltaPosition.start + offset, (frameData.deltaPosition.end - frameData.deltaPosition.start) / 4);
                        var count = positionArray.length / 3;
                        var deltaPosition = float32ArrayToVector3(positionArray, count);
                        if (frameData.deltaNormals) {
                            var normalsArray = new Float32Array(bufferReader.buffer, frameData.deltaNormals.start + offset, (frameData.deltaNormals.end - frameData.deltaNormals.start) / 4);
                            float32ArrayToVector3(normalsArray, count);
                        }
                        if (frameData.deltaTangents) {
                            var tangentsArray = new Float32Array(bufferReader.buffer, frameData.deltaTangents.start + offset, (frameData.deltaTangents.end - frameData.deltaTangents.start) / 4);
                            float32ArrayToVector4(tangentsArray, count);
                        }
                        blendShape.addFrame(frameData.weight, deltaPosition);
                    });
                    modelMesh.addBlendShape(blendShape);
                });
            }
            if (encodedMeshData.indices) {
                var indices = null;
                if (encodedMeshData.indices.type === 0) {
                    indices = new Uint16Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 2);
                } else {
                    indices = new Uint32Array(bufferReader.buffer, encodedMeshData.indices.start + offset, (encodedMeshData.indices.end - encodedMeshData.indices.start) / 4);
                }
                modelMesh.setIndices(indices);
            }
            encodedMeshData.subMeshes.forEach(function(subMesh) {
                return modelMesh.addSubMesh(subMesh);
            });
            modelMesh.uploadData(false);
            resolve(modelMesh);
        });
    };
    return MeshDecoder;
}();
MeshDecoder = __decorate([
    decoder("Mesh")
], MeshDecoder);
function float32ArrayToVColor(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Color(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector4(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector4(float32Array[i * 4], float32Array[i * 4 + 1], float32Array[i * 4 + 2], float32Array[i * 4 + 3]);
    }
    return array;
}
function float32ArrayToVector3(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector3(float32Array[i * 3], float32Array[i * 3 + 1], float32Array[i * 3 + 2]);
    }
    return array;
}
function float32ArrayToVector2(float32Array, vertexCount) {
    var array = new Array(vertexCount);
    for(var i = 0; i < vertexCount; i++){
        array[i] = new Vector2(float32Array[i * 2], float32Array[i * 2 + 1]);
    }
    return array;
}

var Texture2DDecoder = /*#__PURE__*/ function() {
    function Texture2DDecoder() {}
    Texture2DDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve, reject) {
            var objectId = bufferReader.nextStr();
            var mipmap = !!bufferReader.nextUint8();
            var filterMode = bufferReader.nextUint8();
            var anisoLevel = bufferReader.nextUint8();
            var wrapModeU = bufferReader.nextUint8();
            var wrapModeV = bufferReader.nextUint8();
            var format = bufferReader.nextUint8();
            var width = bufferReader.nextUint16();
            var height = bufferReader.nextUint16();
            var isPixelBuffer = bufferReader.nextUint8();
            var mipCount = bufferReader.nextUint8();
            var imagesData = bufferReader.nextImagesData(mipCount);
            var texture2D = new Texture2D(engine, width, height, format, mipmap);
            texture2D.filterMode = filterMode;
            texture2D.anisoLevel = anisoLevel;
            texture2D.wrapModeU = wrapModeU;
            texture2D.wrapModeV = wrapModeV;
            if (isPixelBuffer) {
                var pixelBuffer = new Uint8Array(imagesData[0]);
                texture2D.setPixelBuffer(pixelBuffer);
                if (mipmap) {
                    texture2D.generateMipmaps();
                    for(var i = 1; i < mipCount; i++){
                        var pixelBuffer1 = new Uint8Array(imagesData[i]);
                        texture2D.setPixelBuffer(pixelBuffer1, i);
                    }
                }
                // @ts-ignore
                engine.resourceManager._objectPool[objectId] = texture2D;
                resolve(texture2D);
            } else {
                var blob = new window.Blob([
                    imagesData[0]
                ]);
                var img = new Image();
                img.onload = function() {
                    texture2D.setImageSource(img);
                    var completedCount = 0;
                    var onComplete = function() {
                        completedCount++;
                        if (completedCount >= mipCount) {
                            resolve(texture2D);
                        }
                    };
                    onComplete();
                    if (mipmap) {
                        var _loop = function(i) {
                            var blob = new window.Blob([
                                imagesData[i]
                            ]);
                            var img = new Image();
                            img.onload = function() {
                                texture2D.setImageSource(img, i);
                                onComplete();
                            };
                            img.src = URL.createObjectURL(blob);
                        };
                        texture2D.generateMipmaps();
                        for(var i = 1; i < mipCount; i++)_loop(i);
                    }
                };
                img.src = URL.createObjectURL(blob);
            }
        });
    };
    return Texture2DDecoder;
}();
Texture2DDecoder = __decorate([
    decoder("Texture2D")
], Texture2DDecoder);

function _is_native_reflect_construct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));

        return true;
    } catch (e) {
        return false;
    }
}

function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) _construct = Reflect.construct;
    else {
        _construct = function construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();

            if (Class) _set_prototype_of(instance, Class.prototype);

            return instance;
        };
    }

    return _construct.apply(null, arguments);
}

var ReflectionParser = /*#__PURE__*/ function() {
    function ReflectionParser() {}
    ReflectionParser.registerCustomParseComponent = function registerCustomParseComponent(componentType, handle) {
        this.customParseComponentHandles[componentType] = handle;
    };
    ReflectionParser.parseEntity = function parseEntity(entityConfig, engine) {
        return ReflectionParser.getEntityByConfig(entityConfig, engine).then(function(entity) {
            var _entityConfig_isActive;
            entity.isActive = (_entityConfig_isActive = entityConfig.isActive) != null ? _entityConfig_isActive : true;
            var position = entityConfig.position, rotation = entityConfig.rotation, scale = entityConfig.scale;
            if (position) entity.transform.position.copyFrom(position);
            if (rotation) entity.transform.rotation.copyFrom(rotation);
            if (scale) entity.transform.scale.copyFrom(scale);
            return entity;
        });
    };
    ReflectionParser.getEntityByConfig = function getEntityByConfig(entityConfig, engine) {
        // @ts-ignore
        var assetRefId = entityConfig.assetRefId;
        if (assetRefId) {
            return engine.resourceManager// @ts-ignore
            .getResourceByRef({
                refId: assetRefId,
                key: entityConfig.key,
                isClone: entityConfig.isClone
            }).then(function(entity) {
                entity.name = entityConfig.name;
                return entity;
            });
        } else {
            var entity = new Entity(engine, entityConfig.name);
            return Promise.resolve(entity);
        }
    };
    ReflectionParser.parseClassObject = function parseClassObject(item, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var Class = Loader.getClass(item.class);
        var _item_constructParams;
        var params = (_item_constructParams = item.constructParams) != null ? _item_constructParams : [];
        var instance = _construct(Class, [].concat(params));
        return this.parsePropsAndMethods(instance, item, engine, resourceManager);
    };
    ReflectionParser.parseBasicType = function parseBasicType(value, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var _this = this;
        if (Array.isArray(value)) {
            return Promise.all(value.map(function(item) {
                return _this.parseBasicType(item, engine, resourceManager);
            }));
        } else if (typeof value === "object" && value != null) {
            if (this._isClass(value)) {
                // class object
                return this.parseClassObject(value, engine, resourceManager);
            } else if (this._isRef(value)) {
                // reference object
                return resourceManager.getResourceByRef(value);
            } else {
                // basic type
                return Promise.resolve(value);
            }
        } else {
            return Promise.resolve(value);
        }
    };
    ReflectionParser.parsePropsAndMethods = function parsePropsAndMethods(instance, item, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var _this = this;
        var promises = [];
        if (item.methods) {
            for(var methodName in item.methods){
                var methodParams = item.methods[methodName];
                for(var i = 0, count = methodParams.length; i < count; i++){
                    var params = methodParams[i];
                    var promise = this.parseMethod(instance, methodName, params, engine, resourceManager);
                    promises.push(promise);
                }
            }
        }
        if (item.props) {
            var _this1 = this, _loop = function(key) {
                var value = item.props[key];
                var promise = _this1.parseBasicType(value, engine).then(function(v) {
                    return instance[key] = v;
                });
                promises.push(promise);
            };
            for(var key in item.props)_loop(key);
        }
        return Promise.all(promises).then(function() {
            var handle = _this.customParseComponentHandles[instance.constructor.name];
            if (handle) return handle(instance, item, engine);
            else return instance;
        });
    };
    ReflectionParser.parseMethod = function parseMethod(instance, methodName, methodParams, engine, resourceManager) {
        if (resourceManager === void 0) resourceManager = engine.resourceManager;
        var _this = this;
        return Promise.all(methodParams.map(function(param) {
            return _this.parseBasicType(param, engine, resourceManager);
        })).then(function(result) {
            var _instance;
            return (_instance = instance)[methodName].apply(_instance, result);
        });
    };
    ReflectionParser._isClass = function _isClass(value) {
        return value["class"] != undefined;
    };
    ReflectionParser._isRef = function _isRef(value) {
        return value["refId"] != undefined;
    };
    return ReflectionParser;
}();
(function() {
    ReflectionParser.customParseComponentHandles = new Map();
})();

var PrefabParser = /*#__PURE__*/ function() {
    function PrefabParser() {}
    PrefabParser.parseChildren = function parseChildren(entitiesConfig, entities, parentId) {
        var children = entitiesConfig.get(parentId).children;
        if (children && children.length > 0) {
            var parent = entities.get(parentId);
            for(var i = 0; i < children.length; i++){
                var childId = children[i];
                var entity = entities.get(childId);
                parent.addChild(entity);
                this.parseChildren(entitiesConfig, entities, childId);
            }
        }
    };
    return PrefabParser;
}();

var ComponentMap = {
    Transform: Transform,
    Animator: Animator,
    DirectLight: DirectLight,
    Camera: Camera,
    MeshRenderer: MeshRenderer,
    ParticleRenderer: ParticleRenderer,
    PointLight: PointLight,
    SpotLight: SpotLight,
    Script: Script,
    SpriteMask: SpriteMask,
    SpriteRenderer: SpriteRenderer,
    TextRenderer: TextRenderer
};

var InterpolableValueType;
(function(InterpolableValueType) {
    InterpolableValueType[InterpolableValueType["Float"] = 0] = "Float";
    InterpolableValueType[InterpolableValueType["FloatArray"] = 1] = "FloatArray";
    InterpolableValueType[InterpolableValueType["Vector2"] = 2] = "Vector2";
    InterpolableValueType[InterpolableValueType["Vector3"] = 3] = "Vector3";
    InterpolableValueType[InterpolableValueType["Vector4"] = 4] = "Vector4";
    InterpolableValueType[InterpolableValueType["Quaternion"] = 5] = "Quaternion";
    InterpolableValueType[InterpolableValueType["Color"] = 6] = "Color";
    InterpolableValueType[InterpolableValueType["Array"] = 7] = "Array";
    InterpolableValueType[InterpolableValueType["Boolean"] = 8] = "Boolean";
})(InterpolableValueType || (InterpolableValueType = {}));
var AnimationClipDecoder = /*#__PURE__*/ function() {
    function AnimationClipDecoder() {}
    AnimationClipDecoder.decode = function decode(engine, bufferReader) {
        return new Promise(function(resolve) {
            var name = bufferReader.nextStr();
            var clip = new AnimationClip(name);
            var eventsLen = bufferReader.nextUint16();
            for(var i = 0; i < eventsLen; ++i){
                var event = new AnimationEvent();
                event.time = bufferReader.nextFloat32();
                event.functionName = bufferReader.nextStr();
                event.parameter = JSON.parse(bufferReader.nextStr()).val;
                clip.addEvent(event);
            }
            var curveBindingsLen = bufferReader.nextUint16();
            for(var i1 = 0; i1 < curveBindingsLen; ++i1){
                var relativePath = bufferReader.nextStr();
                var componentStr = bufferReader.nextStr();
                var componentType = ComponentMap[componentStr];
                var property = bufferReader.nextStr();
                var curve = void 0;
                var interpolation = bufferReader.nextUint8();
                var keysLen = bufferReader.nextUint16();
                var curveType = bufferReader.nextStr();
                switch(curveType){
                    case "AnimationFloatCurve":
                        {
                            curve = curve || new AnimationFloatCurve();
                            curve.interpolation = interpolation;
                            for(var j = 0; j < keysLen; ++j){
                                var keyframe = new Keyframe();
                                keyframe.time = bufferReader.nextFloat32();
                                keyframe.value = bufferReader.nextFloat32();
                                keyframe.inTangent = bufferReader.nextFloat32();
                                keyframe.outTangent = bufferReader.nextFloat32();
                                curve.addKey(keyframe);
                            }
                            break;
                        }
                    case "AnimationArrayCurve":
                        {
                            curve = curve || new AnimationArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j1 = 0; j1 < keysLen; ++j1){
                                var keyframe1 = new Keyframe();
                                keyframe1.time = bufferReader.nextFloat32();
                                var len = bufferReader.nextUint16();
                                keyframe1.value = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.inTangent = Array.from(bufferReader.nextFloat32Array(len));
                                keyframe1.outTangent = Array.from(bufferReader.nextFloat32Array(len));
                                curve.addKey(keyframe1);
                            }
                            break;
                        }
                    case "AnimationFloatArrayCurve":
                        {
                            curve = curve || new AnimationFloatArrayCurve();
                            curve.interpolation = interpolation;
                            for(var j2 = 0; j2 < keysLen; ++j2){
                                var keyframe2 = new Keyframe();
                                keyframe2.time = bufferReader.nextFloat32();
                                var len1 = bufferReader.nextUint16();
                                keyframe2.value = bufferReader.nextFloat32Array(len1);
                                keyframe2.inTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                keyframe2.outTangent = Array.from(bufferReader.nextFloat32Array(len1));
                                curve.addKey(keyframe2);
                            }
                            break;
                        }
                    case "AnimationVector2Curve":
                        {
                            curve = curve || new AnimationVector2Curve();
                            curve.interpolation = interpolation;
                            for(var j3 = 0; j3 < keysLen; ++j3){
                                var keyframe3 = new Keyframe();
                                keyframe3.time = bufferReader.nextFloat32();
                                keyframe3.value = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.inTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe3.outTangent = new Vector2(bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe3);
                            }
                            break;
                        }
                    case "AnimationVector3Curve":
                        {
                            curve = curve || new AnimationVector3Curve();
                            curve.interpolation = interpolation;
                            for(var j4 = 0; j4 < keysLen; ++j4){
                                var keyframe4 = new Keyframe();
                                keyframe4.time = bufferReader.nextFloat32();
                                keyframe4.value = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.inTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe4.outTangent = new Vector3(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe4);
                            }
                            break;
                        }
                    case "AnimationVector4Curve":
                        {
                            curve = curve || new AnimationVector4Curve();
                            curve.interpolation = interpolation;
                            var keyframe5 = new Keyframe();
                            keyframe5.time = bufferReader.nextFloat32();
                            keyframe5.value = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            keyframe5.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                            curve.addKey(keyframe5);
                            break;
                        }
                    case "AnimationColorCurve":
                        {
                            curve = curve || new AnimationColorCurve();
                            curve.interpolation = interpolation;
                            for(var j5 = 0; j5 < keysLen; ++j5){
                                var keyframe6 = new Keyframe();
                                keyframe6.time = bufferReader.nextFloat32();
                                keyframe6.value = new Color(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe6.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe6);
                            }
                            break;
                        }
                    case "AnimationQuaternionCurve":
                        {
                            curve = curve || new AnimationQuaternionCurve();
                            curve.interpolation = interpolation;
                            for(var j6 = 0; j6 < keysLen; ++j6){
                                var keyframe7 = new Keyframe();
                                keyframe7.time = bufferReader.nextFloat32();
                                keyframe7.value = new Quaternion(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.inTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                keyframe7.outTangent = new Vector4(bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32(), bufferReader.nextFloat32());
                                curve.addKey(keyframe7);
                            }
                            break;
                        }
                }
                clip.addCurveBinding(relativePath, componentType, property, curve);
            }
            resolve(clip);
        });
    };
    return AnimationClipDecoder;
}();
AnimationClipDecoder = __decorate([
    decoder("AnimationClip")
], AnimationClipDecoder);

var SceneParserContext = /*#__PURE__*/ function() {
    function SceneParserContext(originalData, scene) {
        this.originalData = originalData;
        this.scene = scene;
        this.entityMap = new Map();
        this.components = new Map();
        this.assets = new Map();
        this.entityConfigMap = new Map();
        this.rootIds = [];
    }
    var _proto = SceneParserContext.prototype;
    _proto.destroy = function destroy() {
        this.entityMap.clear();
        this.components.clear();
        this.assets.clear();
        this.entityConfigMap.clear();
        this.rootIds.length = 0;
    };
    return SceneParserContext;
}();

/** @Internal */ var SceneParser = /*#__PURE__*/ function() {
    function SceneParser(context) {
        var _this = this;
        this.context = context;
        this._engine = this.context.scene.engine;
        this._organizeEntities = this._organizeEntities.bind(this);
        this._parseComponents = this._parseComponents.bind(this);
        this._clearAndResolveScene = this._clearAndResolveScene.bind(this);
        this.promise = new Promise(function(resolve, reject) {
            _this._reject = reject;
            _this._resolve = resolve;
        });
    }
    var _proto = SceneParser.prototype;
    /** start parse the scene */ _proto.start = function start() {
        this._parseEntities().then(this._organizeEntities).then(this._parseComponents).then(this._clearAndResolveScene).then(this._resolve).catch(this._reject);
    };
    _proto._parseEntities = function _parseEntities() {
        var entitiesConfig = this.context.originalData.entities;
        var entityConfigMap = this.context.entityConfigMap;
        var entitiesMap = this.context.entityMap;
        var rootIds = this.context.rootIds;
        var engine = this._engine;
        var promises = entitiesConfig.map(function(entityConfig) {
            entityConfigMap.set(entityConfig.id, entityConfig);
            // record root entities
            if (!entityConfig.parent) rootIds.push(entityConfig.id);
            return ReflectionParser.parseEntity(entityConfig, engine);
        });
        return Promise.all(promises).then(function(entities) {
            for(var i = 0, l = entities.length; i < l; i++){
                entitiesMap.set(entitiesConfig[i].id, entities[i]);
            }
            return entities;
        });
    };
    _proto._organizeEntities = function _organizeEntities() {
        var _this_context = this.context, entityConfigMap = _this_context.entityConfigMap, entityMap = _this_context.entityMap, scene = _this_context.scene, rootIds = _this_context.rootIds;
        for(var _iterator = _create_for_of_iterator_helper_loose(rootIds), _step; !(_step = _iterator()).done;){
            var rootId = _step.value;
            PrefabParser.parseChildren(entityConfigMap, entityMap, rootId);
        }
        var rootEntities = rootIds.map(function(id) {
            return entityMap.get(id);
        });
        for(var i = 0; i < rootEntities.length; i++){
            scene.addRootEntity(rootEntities[i]);
        }
    };
    _proto._parseComponents = function _parseComponents() {
        var entitiesConfig = this.context.originalData.entities;
        var entityMap = this.context.entityMap;
        var promises = [];
        for(var i = 0, l = entitiesConfig.length; i < l; i++){
            var entityConfig = entitiesConfig[i];
            var entity = entityMap.get(entityConfig.id);
            for(var i1 = 0; i1 < entityConfig.components.length; i1++){
                var componentConfig = entityConfig.components[i1];
                var key = !componentConfig.refId ? componentConfig.class : componentConfig.refId;
                var component = void 0;
                // TODO: remove hack code when support additional edit
                if (key === "Animator") {
                    component = entity.getComponent(Loader.getClass(key));
                }
                component = component || entity.addComponent(Loader.getClass(key));
                var promise = ReflectionParser.parsePropsAndMethods(component, componentConfig, entity.engine);
                promises.push(promise);
            }
        }
        return Promise.all(promises);
    };
    _proto._clearAndResolveScene = function _clearAndResolveScene() {
        var scene = this.context.scene;
        this.context.destroy();
        return scene;
    };
    /**
   * Parse scene data.
   * @param engine - the engine of the parser context
   * @param sceneData - scene data which is exported by editor
   * @returns a promise of scene
   */ SceneParser.parse = function parse(engine, sceneData) {
        var scene = new Scene(engine);
        var context = new SceneParserContext(sceneData, scene);
        var parser = new SceneParser(context);
        parser.start();
        return parser.promise;
    };
    return SceneParser;
}();

var MeshLoader$1 = /*#__PURE__*/ function(Loader) {
    _inherits(MeshLoader, Loader);
    function MeshLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(data) {
                decode(data, resourceManager.engine).then(function(mesh) {
                    resolve(mesh);
                });
            });
        });
    };
    return MeshLoader;
}(Loader);
MeshLoader$1 = __decorate([
    resourceLoader("Mesh", [
        "prefab"
    ], true)
], MeshLoader$1);

var EditorTextureLoader = /*#__PURE__*/ function(Loader) {
    _inherits(EditorTextureLoader, Loader);
    function EditorTextureLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = EditorTextureLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve) {
            _this.request(item.url, {
                type: "arraybuffer"
            }).then(function(data) {
                decode(data, resourceManager.engine).then(function(texture) {
                    resolve(texture);
                });
            });
        });
    };
    return EditorTextureLoader;
}(Loader);
EditorTextureLoader = __decorate([
    resourceLoader("EditorTexture2D", [
        "prefab"
    ], true)
], EditorTextureLoader);

/**
 * Decode engine binary resource.
 * @param arrayBuffer - array buffer of decode binary file
 * @param engine - engine
 * @returns
 */ function decode(arrayBuffer, engine) {
    var header = FileHeader.decode(arrayBuffer);
    var bufferReader = new BufferReader(arrayBuffer, header.headerLength, header.dataLength);
    return decoderMap[header.type].decode(engine, bufferReader).then(function(object) {
        object.name = header.name;
        return object;
    });
}

var MeshLoader = /*#__PURE__*/ function(Loader) {
    _inherits(MeshLoader, Loader);
    function MeshLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = MeshLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine);
            }).then(function(mesh) {
                resolve(mesh);
            }).catch(reject);
        });
    };
    return MeshLoader;
}(Loader);
MeshLoader = __decorate([
    resourceLoader(AssetType.Mesh, [
        "mesh"
    ])
], MeshLoader);

var SourceFontLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SourceFontLoader, Loader);
    function SourceFontLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = SourceFontLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            var url = item.url;
            _this._registerFont(url, url).then(function() {
                var font = new Font(resourceManager.engine, url);
                resolve(font);
            }).catch(function(e) {
                reject("load font " + url + " fail");
            });
        });
    };
    _proto._registerFont = function _registerFont(fontName, fontUrl) {
        return _async_to_generator(function() {
            var fontFace;
            return __generator(this, function(_state) {
                switch(_state.label){
                    case 0:
                        fontFace = new FontFace(fontName, "url(" + fontUrl + ")");
                        return [
                            4,
                            fontFace.load()
                        ];
                    case 1:
                        _state.sent();
                        document.fonts.add(fontFace);
                        return [
                            2
                        ];
                }
            });
        })();
    };
    return SourceFontLoader;
}(Loader);
SourceFontLoader = __decorate([
    resourceLoader(AssetType.SourceFont, [
        "ttf",
        "otf",
        "woff"
    ], false)
], SourceFontLoader);

var SpriteAtlasLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteAtlasLoader, Loader);
    function SpriteAtlasLoader() {
        var _this;
        _this = Loader.apply(this, arguments) || this;
        _this._tempRect = new Rect();
        _this._tempVec2 = new Vector2();
        _this._tempVec4 = new Vector4();
        return _this;
    }
    var _proto = SpriteAtlasLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject, _, onCancel) {
            var chainPromises = [];
            onCancel(function() {
                for(var i = 0; i < chainPromises.length; i++){
                    chainPromises[i].cancel();
                }
            });
            var configPromise = _this.request(item.url, _extends({}, item, {
                type: "json"
            }));
            chainPromises.push(configPromise);
            configPromise.then(function(atlasData) {
                var _loop = function(i) {
                    var atlasItem = atlasItems[i];
                    if (atlasItem.img) {
                        chainPromises.push(resourceManager.load({
                            url: GLTFUtil.parseRelativeUrl(item.url, atlasItem.img),
                            type: AssetType.Texture2D,
                            params: {
                                format: format,
                                mipmap: mipmap
                            }
                        }).then(function(texture) {
                            anisoLevel && (texture.anisoLevel = anisoLevel);
                            filterMode !== undefined && (texture.filterMode = filterMode);
                            wrapModeU !== undefined && (texture.wrapModeU = wrapModeU);
                            wrapModeV !== undefined && (texture.wrapModeV = wrapModeV);
                            for(var i = 0; i < atlasItem.sprites.length; i++){
                                // @ts-ignore
                                spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i], texture));
                            }
                        }).catch(reject));
                    } else {
                        for(var i1 = 0; i1 < atlasItem.sprites.length; i1++){
                            // @ts-ignore
                            spriteAtlas._addSprite(_this._makeSprite(engine, atlasItem.sprites[i1]));
                        }
                    }
                };
                var atlasItems = atlasData.atlasItems, mipmap = atlasData.mipmap, anisoLevel = atlasData.anisoLevel, filterMode = atlasData.filterMode, wrapModeU = atlasData.wrapModeU, wrapModeV = atlasData.wrapModeV, format = atlasData.format;
                var atlasItemsLen = atlasItems ? atlasItems.length : 0;
                var engine = resourceManager.engine;
                var spriteAtlas = new SpriteAtlas(engine);
                if (atlasItemsLen < 0) {
                    resolve(spriteAtlas);
                    return;
                }
                chainPromises.length = 0;
                for(var i = 0; i < atlasItems.length; i++)_loop(i);
                AssetPromise.all(chainPromises).then(function() {
                    resolve(spriteAtlas);
                }).catch(reject);
            }).catch(reject);
        });
    };
    _proto._makeSprite = function _makeSprite(engine, config, texture) {
        // Generate a SpriteAtlas object.
        var region = config.region, atlasRegionOffset = config.atlasRegionOffset, atlasRegion = config.atlasRegion, pivot = config.pivot, border = config.border;
        var sprite = new Sprite(engine, texture, region ? this._tempRect.set(region.x, region.y, region.w, region.h) : undefined, pivot ? this._tempVec2.set(pivot.x, pivot.y) : undefined, border ? this._tempVec4.set(border.x, border.y, border.z, border.w) : undefined, config.name);
        if (texture) {
            var invW = 1 / texture.width;
            var invH = 1 / texture.height;
            sprite.atlasRegion.set(atlasRegion.x * invW, atlasRegion.y * invH, atlasRegion.w * invW, atlasRegion.h * invH);
            if (atlasRegionOffset) {
                var offsetLeft = atlasRegionOffset.x, offsetTop = atlasRegionOffset.y, offsetRight = atlasRegionOffset.z, offsetBottom = atlasRegionOffset.w;
                sprite.atlasRegionOffset.set(offsetLeft * invW, offsetTop * invH, offsetRight * invW, offsetBottom * invH);
            }
            config.atlasRotated && (sprite.atlasRotated = true);
        }
        return sprite;
    };
    return SpriteAtlasLoader;
}(Loader);
SpriteAtlasLoader = __decorate([
    resourceLoader(AssetType.SpriteAtlas, [
        "atlas"
    ], false)
], SpriteAtlasLoader);

var SpriteLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SpriteLoader, Loader);
    function SpriteLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = SpriteLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "json"
            })).then(function(data) {
                if (data.belongToAtlas) {
                    resourceManager// @ts-ignore
                    .getResourceByRef(data.belongToAtlas).then(function(atlas) {
                        resolve(atlas.getSprite(data.fullPath));
                    }).catch(reject);
                } else if (data.texture) {
                    resourceManager// @ts-ignore
                    .getResourceByRef(data.texture).then(function(texture) {
                        resolve(new Sprite(resourceManager.engine, texture, data.region, data.pivot, data.border));
                    }).catch(reject);
                } else {
                    resolve(new Sprite(resourceManager.engine, null, data.region, data.pivot, data.border));
                }
            }).catch(reject);
        });
    };
    return SpriteLoader;
}(Loader);
SpriteLoader = __decorate([
    resourceLoader(AssetType.Sprite, [
        "sprite"
    ], false)
], SpriteLoader);

var Texture2DLoader = /*#__PURE__*/ function(Loader) {
    _inherits(Texture2DLoader, Loader);
    function Texture2DLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = Texture2DLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "image"
            })).then(function(image) {
                var _item_params;
                var params = (_item_params = item.params) != null ? _item_params : {};
                var texture = new Texture2D(resourceManager.engine, image.width, image.height, params.format, params.mipmap);
                /** @ts-ignore */ if (!texture._platformTexture) return;
                texture.setImageSource(image);
                texture.generateMipmaps();
                if (item.url.indexOf("data:") !== 0) {
                    var splitPath = item.url.split("/");
                    texture.name = splitPath[splitPath.length - 1];
                }
                resolve(texture);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return Texture2DLoader;
}(Loader);
Texture2DLoader = __decorate([
    resourceLoader(AssetType.Texture2D, [
        "png",
        "jpg",
        "webp",
        "jpeg"
    ])
], Texture2DLoader);

var TextureCubeLoader = /*#__PURE__*/ function(Loader) {
    _inherits(TextureCubeLoader, Loader);
    function TextureCubeLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = TextureCubeLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            Promise.all(item.urls.map(function(url) {
                return _this.request(url, _extends({}, item, {
                    type: "image"
                }));
            })).then(function(images) {
                var _images_ = images[0], width = _images_.width, height = _images_.height;
                if (width !== height) {
                    console.error("The cube texture must have the same width and height");
                    return;
                }
                var tex = new TextureCube(resourceManager.engine, width);
                /** @ts-ignore */ if (!tex._platformTexture) return;
                for(var faceIndex = 0; faceIndex < 6; faceIndex++){
                    tex.setImageSource(TextureCubeFace.PositiveX + faceIndex, images[faceIndex], 0);
                }
                tex.generateMipmaps();
                resolve(tex);
            }).catch(function(e) {
                reject(e);
            });
        });
    };
    return TextureCubeLoader;
}(Loader);
TextureCubeLoader = __decorate([
    resourceLoader(AssetType.TextureCube, [
        ""
    ])
], TextureCubeLoader);

var AnimationClipLoader = /*#__PURE__*/ function(Loader) {
    _inherits(AnimationClipLoader, Loader);
    function AnimationClipLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = AnimationClipLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, _extends({}, item, {
                type: "arraybuffer"
            })).then(function(data) {
                return decode(data, resourceManager.engine).then(resolve);
            }).catch(reject);
        });
    };
    return AnimationClipLoader;
}(Loader);
AnimationClipLoader = __decorate([
    resourceLoader(AssetType.AnimationClip, [
        "ani"
    ])
], AnimationClipLoader);

var SceneLoader = /*#__PURE__*/ function(Loader) {
    _inherits(SceneLoader, Loader);
    function SceneLoader() {
        return Loader.apply(this, arguments);
    }
    var _proto = SceneLoader.prototype;
    _proto.load = function load(item, resourceManager) {
        var _this = this;
        var engine = resourceManager.engine;
        return new AssetPromise(function(resolve, reject) {
            _this.request(item.url, {
                type: "json"
            }).then(function(data) {
                // @ts-ignore
                engine.resourceManager.initVirtualResources(data.files);
                return SceneParser.parse(engine, data).then(function(scene) {
                    // parse ambient light
                    var ambient = data.scene.ambient;
                    var ambientLightPromise = Promise.resolve();
                    if (ambient.ambientLight) {
                        ambientLightPromise = resourceManager// @ts-ignore
                        .getResourceByRef(data.scene.ambient.ambientLight).then(function(light) {
                            scene.ambientLight = light;
                            scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                            scene.ambientLight.specularIntensity = ambient.specularIntensity;
                        });
                    } else {
                        scene.ambientLight.diffuseIntensity = ambient.diffuseIntensity;
                        scene.ambientLight.specularIntensity = ambient.specularIntensity;
                        scene.ambientLight.diffuseSolidColor.copyFrom(ambient.diffuseSolidColor);
                    }
                    var background = data.scene.background;
                    scene.background.mode = background.mode;
                    var backgroundPromise = Promise.resolve();
                    switch(scene.background.mode){
                        case BackgroundMode.SolidColor:
                            scene.background.solidColor.copyFrom(background.color);
                            break;
                        case BackgroundMode.Sky:
                            if (background.sky) {
                                // @ts-ignore
                                backgroundPromise = resourceManager.getResourceByRef(background.sky).then(function(light) {
                                    var sky = scene.background.sky;
                                    var skyMaterial = new SkyBoxMaterial(engine);
                                    skyMaterial.textureCubeMap = light.specularTexture;
                                    skyMaterial.textureDecodeRGBM = true;
                                    sky.material = skyMaterial;
                                    sky.mesh = PrimitiveMesh.createCuboid(engine, 1, 1, 1);
                                });
                            }
                            break;
                        case BackgroundMode.Texture:
                            if (background.texture) {
                                // @ts-ignore
                                backgroundPromise = resourceManager.getResourceByRef(background.texture).then(function(texture) {
                                    scene.background.texture = texture;
                                });
                            }
                            break;
                    }
                    // parse shadow
                    var shadow = data.scene.shadow;
                    if (shadow) {
                        if (shadow.castShadows != undefined) scene.castShadows = shadow.castShadows;
                        if (shadow.shadowResolution != undefined) scene.shadowResolution = shadow.shadowResolution;
                        if (shadow.shadowDistance != undefined) scene.shadowDistance = shadow.shadowDistance;
                        if (shadow.shadowCascades != undefined) scene.shadowCascades = shadow.shadowCascades;
                    }
                    var fog = data.scene.fog;
                    if (fog) {
                        if (fog.fogMode != undefined) scene.fogMode = fog.fogMode;
                        if (fog.fogStart != undefined) scene.fogStart = fog.fogStart;
                        if (fog.fogEnd != undefined) scene.fogEnd = fog.fogEnd;
                        if (fog.fogDensity != undefined) scene.fogDensity = fog.fogDensity;
                        if (fog.fogColor != undefined) scene.fogColor.copyFrom(fog.fogColor);
                    }
                    return Promise.all([
                        ambientLightPromise,
                        backgroundPromise
                    ]).then(function() {
                        resolve(scene);
                    });
                });
            }).catch(reject);
        });
    };
    return SceneLoader;
}(Loader);
SceneLoader = __decorate([
    resourceLoader(AssetType.Scene, [
        "prefab"
    ], true)
], SceneLoader);
ReflectionParser.registerCustomParseComponent("TextRenderer", /*#__PURE__*/ _async_to_generator(function(instance, item, engine) {
    var props;
    return __generator(this, function(_state) {
        props = item.props;
        if (!props.font) {
            // @ts-ignore
            instance.font = Font.createFromOS(engine, props.fontFamily || "Arial");
        }
        return [
            2,
            instance
        ];
    });
}));

export { AnimationClipDecoder, ComponentMap, EditorTextureLoader, GLTFResource, InterpolableValueType, MeshDecoder, MeshLoader$1 as MeshLoader, PrefabParser, ReflectionParser, SceneParser, Texture2DDecoder, decode, parseSingleKTX };
//# sourceMappingURL=module.js.map

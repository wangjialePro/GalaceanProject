/**
 * Defines how the bounding volumes intersects or contain one another.
 */ var ContainmentType;
(function(ContainmentType) {
    ContainmentType[ContainmentType[/** Indicates that there is no overlap between two bounding volumes. */ "Disjoint"] = 0] = "Disjoint";
    ContainmentType[ContainmentType[/** Indicates that one bounding volume completely contains another volume. */ "Contains"] = 1] = "Contains";
    ContainmentType[ContainmentType[/** Indicates that bounding volumes partially overlap one another. */ "Intersects"] = 2] = "Intersects";
})(ContainmentType || (ContainmentType = {}));

/**
 * Defines the intersection between a plane and a bounding volume.
 */ var PlaneIntersectionType;
(function(PlaneIntersectionType) {
    PlaneIntersectionType[PlaneIntersectionType[/** There is no intersection, the bounding volume is in the back of the plane. */ "Back"] = 0] = "Back";
    PlaneIntersectionType[PlaneIntersectionType[/** There is no intersection, the bounding volume is in the front of the plane. */ "Front"] = 1] = "Front";
    PlaneIntersectionType[PlaneIntersectionType[/** The plane is intersected. */ "Intersecting"] = 2] = "Intersecting";
})(PlaneIntersectionType || (PlaneIntersectionType = {}));

/**
 * Frustum face
 */ var FrustumFace;
(function(FrustumFace) {
    FrustumFace[FrustumFace[/** Near face */ "Near"] = 0] = "Near";
    FrustumFace[FrustumFace[/** Far face */ "Far"] = 1] = "Far";
    FrustumFace[FrustumFace[/** Left face */ "Left"] = 2] = "Left";
    FrustumFace[FrustumFace[/** Right face */ "Right"] = 3] = "Right";
    FrustumFace[FrustumFace[/** Bottom face */ "Bottom"] = 4] = "Bottom";
    FrustumFace[FrustumFace[/** Top face */ "Top"] = 5] = "Top";
})(FrustumFace || (FrustumFace = {}));

function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;

        if ("value" in descriptor) descriptor.writable = true;

        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);

    return Constructor;
}

/**
 * Common utility methods for math operations.
 */ var MathUtil = /*#__PURE__*/ function() {
    function MathUtil() {}
    /**
   * Clamps the specified value.
   * @param v - The specified value
   * @param min - The min value
   * @param max - The max value
   * @returns The result of clamping a value between min and max
   */ MathUtil.clamp = function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
    };
    /**
   * Checks if a and b are almost equals.
   * The absolute value of the difference between a and b is close to zero.
   * @param a - The left value to compare
   * @param b - The right value to compare
   * @returns True if a almost equal to b, false otherwise
   */ MathUtil.equals = function equals(a, b) {
        return Math.abs(a - b) <= MathUtil.zeroTolerance;
    };
    /**
   * Determines whether the specified v is pow2.
   * @param v - The specified v
   * @returns True if the specified v is pow2, false otherwise
   */ MathUtil.isPowerOf2 = function isPowerOf2(v) {
        return (v & v - 1) === 0;
    };
    /**
   * Modify the specified r from radian to degree.
   * @param r - The specified r
   * @returns The degree value
   */ MathUtil.radianToDegree = function radianToDegree(r) {
        return r * MathUtil.radToDegreeFactor;
    };
    /**
   * Modify the specified d from degree to radian.
   * @param d - The specified d
   * @returns The radian value
   */ MathUtil.degreeToRadian = function degreeToRadian(d) {
        return d * MathUtil.degreeToRadFactor;
    };
    return MathUtil;
}();
(function() {
    /** The value for which all absolute numbers smaller than are considered equal to zero. */ MathUtil.zeroTolerance = 1e-6;
})();
(function() {
    /** The conversion factor that radian to degree. */ MathUtil.radToDegreeFactor = 180 / Math.PI;
})();
(function() {
    /** The conversion factor that degree to radian. */ MathUtil.degreeToRadFactor = Math.PI / 180;
})();

/**
 * Describes a 3D-vector.
 */ var Vector3 = /*#__PURE__*/ function() {
    function Vector3(x, y, z) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
    }
    var _proto = Vector3.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @param z - The z component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        return Math.sqrt(_x * _x + _y * _y + _z * _z);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        return _x * _x + _y * _y + _z * _z;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector3.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * This vector performs a normal transformation using the given 4x4 matrix.
   * @remarks
   * A normal transform performs the transformation with the assumption that the w component
   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
   * end result is a vector that is not translated, but all other transformation properties
   * apply. This is often preferred for normal vectors as normals purely represent direction
   * rather than location because normal vectors should not be translated.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformNormal = function transformNormal(m) {
        Vector3.transformNormal(this, m, this);
        return this;
    };
    /**
   * This vector performs a transformation using the given 4x4 matrix.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformToVec3 = function transformToVec3(m) {
        Vector3.transformToVec3(this, m, this);
        return this;
    };
    /**
   * This vector performs a coordinate transformation using the given 4x4 matrix.
   * @remarks
   * A coordinate transform performs the transformation with the assumption that the w component
   * is one. The four dimensional vector obtained from the transformation operation has each
   * component in the vector divided by the w component. This forces the w-component to be one and
   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
   * with coordinates as the w component can safely be ignored.
   * @param m - The transform matrix
   * @returns This vector
   */ _proto.transformCoordinate = function transformCoordinate(m) {
        Vector3.transformCoordinate(this, m, this);
        return this;
    };
    /**
   * This vector performs a transformation using the given quaternion.
   * @param quaternion - The transform quaternion
   * @returns This vector
   */ _proto.transformByQuat = function transformByQuat(quaternion) {
        Vector3.transformByQuat(this, quaternion, this);
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        return new Vector3(this._x, this._y, this._z);
    };
    /**
   * Copy from vector3 like object.
   * @param source - Vector3 like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector3.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector3.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector3.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector3.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector3.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z;
    };
    /**
   * Determines the cross product of two vectors.
   * @param left - The first vector to cross
   * @param right - The second vector to cross
   * @param out - The cross product of two vectors
   */ Vector3.cross = function cross(left, right, out) {
        var ax = left._x;
        var ay = left._y;
        var az = left._z;
        var bx = right._x;
        var by = right._y;
        var bz = right._z;
        out.set(ay * bz - az * by, az * bx - ax * bz, ax * by - ay * bx);
    };
    /**
   * Determines the distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The distance of two vectors
   */ Vector3.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return Math.sqrt(x * x + y * y + z * z);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The squared distance of two vectors
   */ Vector3.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        return x * x + y * y + z * z;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector3.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param start - The first vector
   * @param end - The second vector
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two vectors
   */ Vector3.lerp = function lerp(start, end, t, out) {
        var _x = start._x, _y = start._y, _z = start._z;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector3.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector3.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Reverses the direction of a given vector.
   * @param a - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector3.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Converts the vector into a unit vector.
   * @param a - The vector to normalize
   * @param out - The normalized vector
   */ Vector3.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out.set(_x * len, _y * len, _z * len);
        }
    };
    /**
   * Scale a vector by the given value.
   * @param a - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector3.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a normal transformation using the given 4x4 matrix.
   * @remarks
   * A normal transform performs the transformation with the assumption that the w component
   * is zero. This causes the fourth row and fourth column of the matrix to be unused. The
   * end result is a vector that is not translated, but all other transformation properties
   * apply. This is often preferred for normal vectors as normals purely represent direction
   * rather than location because normal vectors should not be translated.
   * @param v - The normal vector to transform
   * @param m - The transform matrix
   * @param out - The transformed normal
   */ Vector3.transformNormal = function transformNormal(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8];
        out._y = _x * e[1] + _y * e[5] + _z * e[9];
        out._z = _x * e[2] + _y * e[6] + _z * e[10];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector3
   */ Vector3.transformToVec3 = function transformToVec3(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation from vector3 to vector4 using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector4
   */ Vector3.transformToVec4 = function transformToVec4(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a coordinate transformation using the given 4x4 matrix.
   *
   * @remarks
   * A coordinate transform performs the transformation with the assumption that the w component
   * is one. The four dimensional vector obtained from the transformation operation has each
   * component in the vector divided by the w component. This forces the w-component to be one and
   * therefore makes the vector homogeneous. The homogeneous vector is often preferred when working
   * with coordinates as the w component can safely be ignored.
   * @param v - The coordinate vector to transform
   * @param m - The transform matrix
   * @param out - The transformed coordinates
   */ Vector3.transformCoordinate = function transformCoordinate(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var e = m.elements;
        var w = _x * e[3] + _y * e[7] + _z * e[11] + e[15];
        w = 1.0 / w;
        out._x = (_x * e[0] + _y * e[4] + _z * e[8] + e[12]) * w;
        out._y = (_x * e[1] + _y * e[5] + _z * e[9] + e[13]) * w;
        out._z = (_x * e[2] + _y * e[6] + _z * e[10] + e[14]) * w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given quaternion.
   * @param v - The vector to transform
   * @param quaternion - The transform quaternion
   * @param out - The transformed vector
   */ Vector3.transformByQuat = function transformByQuat(v, quaternion, out) {
        var _x = v._x, _y = v._y, _z = v._z;
        var qx = quaternion._x, qy = quaternion._y, qz = quaternion._z, qw = quaternion._w;
        // calculate quat * vec
        var ix = qw * _x + qy * _z - qz * _y;
        var iy = qw * _y + qz * _x - qx * _z;
        var iz = qw * _z + qx * _y - qy * _x;
        var iw = -qx * _x - qy * _y - qz * _z;
        // calculate result * inverse quat
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class(Vector3, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the vector.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Vector3;
}();
(function() {
    /** @internal */ Vector3._zero = new Vector3(0.0, 0.0, 0.0);
})();
(function() {
    /** @internal */ Vector3._one = new Vector3(1.0, 1.0, 1.0);
})();

/**
 * A bounding sphere.
 * */ var BoundingSphere = /*#__PURE__*/ function() {
    function BoundingSphere(center, radius) {
        if (center === void 0) center = null;
        if (radius === void 0) radius = 0;
        /** The center point of the sphere. */ this.center = new Vector3();
        /** The radius of the sphere. */ this.radius = 0;
        center && this.center.copyFrom(center);
        this.radius = radius;
    }
    var _proto = BoundingSphere.prototype;
    /**
   * Creates a clone of this sphere.
   * @returns A clone of this sphere
   */ _proto.clone = function clone() {
        return new BoundingSphere(this.center, this.radius);
    };
    /**
   * Copy this sphere from the specified sphere.
   * @param source - The specified sphere
   * @returns This sphere
   */ _proto.copyFrom = function copyFrom(source) {
        this.center.copyFrom(source.center);
        this.radius = source.radius;
        return this;
    };
    /**
   * Calculate a bounding sphere that fully contains the given points.
   * @param points - The given points
   * @param out - The calculated bounding sphere
   */ BoundingSphere.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
            throw new Error("points must be array and length must > 0");
        }
        var len = points.length;
        var center = BoundingSphere._tempVec30;
        center.x = center.y = center.z = 0;
        // Calculate the center of the sphere.
        for(var i = 0; i < len; ++i){
            Vector3.add(points[i], center, center);
        }
        // The center of the sphere.
        Vector3.scale(center, 1 / len, out.center);
        // Calculate the radius of the sphere.
        var radius = 0.0;
        for(var i1 = 0; i1 < len; ++i1){
            var distance = Vector3.distanceSquared(center, points[i1]);
            distance > radius && (radius = distance);
        }
        // The radius of the sphere.
        out.radius = Math.sqrt(radius);
    };
    /**
   * Calculate a bounding sphere from a given box.
   * @param box - The given box
   * @param out - The calculated bounding sphere
   */ BoundingSphere.fromBox = function fromBox(box, out) {
        var center = out.center;
        var min = box.min, max = box.max;
        center.x = (min.x + max.x) * 0.5;
        center.y = (min.y + max.y) * 0.5;
        center.z = (min.z + max.z) * 0.5;
        out.radius = Vector3.distance(center, max);
    };
    return BoundingSphere;
}();
(function() {
    BoundingSphere._tempVec30 = new Vector3();
})();

/**
 * Axis Aligned Bound Box (AABB).
 */ var BoundingBox = /*#__PURE__*/ function() {
    function BoundingBox(min, max) {
        if (min === void 0) min = null;
        if (max === void 0) max = null;
        /** The minimum point of the box. */ this.min = new Vector3();
        /** The maximum point of the box. */ this.max = new Vector3();
        min && this.min.copyFrom(min);
        max && this.max.copyFrom(max);
    }
    var _proto = BoundingBox.prototype;
    /**
   * Get the center point of this bounding box.
   * @param out - The center point of this bounding box
   * @returns The center point of this bounding box
   */ _proto.getCenter = function getCenter(out) {
        Vector3.add(this.min, this.max, out);
        Vector3.scale(out, 0.5, out);
        return out;
    };
    /**
   * Get the extent of this bounding box.
   * @param out - The extent of this bounding box
   * @returns The extent of this bounding box
   */ _proto.getExtent = function getExtent(out) {
        Vector3.subtract(this.max, this.min, out);
        Vector3.scale(out, 0.5, out);
        return out;
    };
    /**
   * Get the eight corners of this bounding box.
   * @param out - An array of points representing the eight corners of this bounding box
   * @returns An array of points representing the eight corners of this bounding box
   */ _proto.getCorners = function getCorners(out) {
        if (out === void 0) out = [];
        var _this = this, min = _this.min, max = _this.max;
        var minX = min.x;
        var minY = min.y;
        var minZ = min.z;
        var maxX = max.x;
        var maxY = max.y;
        var maxZ = max.z;
        var len = out.length;
        // The array length is less than 8 to make up
        if (len < 8) {
            for(var i = 0, l = 8 - len; i < l; ++i){
                out[len + i] = new Vector3();
            }
        }
        out[0].set(minX, maxY, maxZ);
        out[1].set(maxX, maxY, maxZ);
        out[2].set(maxX, minY, maxZ);
        out[3].set(minX, minY, maxZ);
        out[4].set(minX, maxY, minZ);
        out[5].set(maxX, maxY, minZ);
        out[6].set(maxX, minY, minZ);
        out[7].set(minX, minY, minZ);
        return out;
    };
    /**
   * Transform a bounding box.
   * @param matrix - The transform to apply to the bounding box
   * @returns The transformed bounding box
   */ _proto.transform = function transform(matrix) {
        BoundingBox.transform(this, matrix, this);
        return this;
    };
    /**
   * Creates a clone of this box.
   * @returns A clone of this box
   */ _proto.clone = function clone() {
        return new BoundingBox(this.min, this.max);
    };
    /**
   * Copy this bounding box from the specified box.
   * @param source - The specified box
   * @returns This bounding box
   */ _proto.copyFrom = function copyFrom(source) {
        this.min.copyFrom(source.min);
        this.max.copyFrom(source.max);
        return this;
    };
    /**
   * Calculate a bounding box from the center point and the extent of the bounding box.
   * @param center - The center point
   * @param extent - The extent of the bounding box
   * @param out - The calculated bounding box
   */ BoundingBox.fromCenterAndExtent = function fromCenterAndExtent(center, extent, out) {
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
    };
    /**
   * Calculate a bounding box that fully contains the given points.
   * @param points - The given points
   * @param out - The calculated bounding box
   */ BoundingBox.fromPoints = function fromPoints(points, out) {
        if (!points || points.length === 0) {
            throw new Error("points must be array and length must > 0");
        }
        var min = out.min, max = out.max;
        min.x = min.y = min.z = Number.MAX_VALUE;
        max.x = max.y = max.z = -Number.MAX_VALUE;
        for(var i = 0, l = points.length; i < l; ++i){
            var point = points[i];
            Vector3.min(min, point, min);
            Vector3.max(max, point, max);
        }
    };
    /**
   * Calculate a bounding box from a given sphere.
   * @param sphere - The given sphere
   * @param out - The calculated bounding box
   */ BoundingBox.fromSphere = function fromSphere(sphere, out) {
        var center = sphere.center, radius = sphere.radius;
        var min = out.min, max = out.max;
        min.x = center.x - radius;
        min.y = center.y - radius;
        min.z = center.z - radius;
        max.x = center.x + radius;
        max.y = center.y + radius;
        max.z = center.z + radius;
    };
    /**
   * Transform a bounding box.
   * @param source - The original bounding box
   * @param matrix - The transform to apply to the bounding box
   * @param out - The transformed bounding box
   */ BoundingBox.transform = function transform(source, matrix, out) {
        // https://zeux.io/2010/10/17/aabb-from-obb-with-component-wise-abs/
        var center = BoundingBox._tempVec30;
        var extent = BoundingBox._tempVec31;
        source.getCenter(center);
        source.getExtent(extent);
        Vector3.transformCoordinate(center, matrix, center);
        var x = extent.x, y = extent.y, z = extent.z;
        var e = matrix.elements;
        extent.x = Math.abs(x * e[0]) + Math.abs(y * e[4]) + Math.abs(z * e[8]);
        extent.y = Math.abs(x * e[1]) + Math.abs(y * e[5]) + Math.abs(z * e[9]);
        extent.z = Math.abs(x * e[2]) + Math.abs(y * e[6]) + Math.abs(z * e[10]);
        // set minã€max
        Vector3.subtract(center, extent, out.min);
        Vector3.add(center, extent, out.max);
    };
    /**
   * Calculate a bounding box that is as large as the total combined area of the two specified boxes.
   * @param box1 - The first box to merge
   * @param box2 - The second box to merge
   * @param out - The merged bounding box
   * @returns The merged bounding box
   */ BoundingBox.merge = function merge(box1, box2, out) {
        Vector3.min(box1.min, box2.min, out.min);
        Vector3.max(box1.max, box2.max, out.max);
        return out;
    };
    return BoundingBox;
}();
(function() {
    BoundingBox._tempVec30 = new Vector3();
})();
(function() {
    BoundingBox._tempVec31 = new Vector3();
})();

/**
 * Contains static methods to help in determining intersections, containment, etc.
 */ var CollisionUtil = /*#__PURE__*/ function() {
    function CollisionUtil() {}
    /**
   * Calculate the intersection point of three plane.
   * @param  p1 - Plane 1
   * @param  p2 - Plane 2
   * @param  p3 - Plane 3
   * @param out - intersection point
   */ CollisionUtil.intersectionPointThreePlanes = function intersectionPointThreePlanes(p1, p2, p3, out) {
        var p1Nor = p1.normal;
        var p2Nor = p2.normal;
        var p3Nor = p3.normal;
        Vector3.cross(p2Nor, p3Nor, CollisionUtil._tempVec30);
        Vector3.cross(p3Nor, p1Nor, CollisionUtil._tempVec31);
        Vector3.cross(p1Nor, p2Nor, CollisionUtil._tempVec32);
        var a = -Vector3.dot(p1Nor, CollisionUtil._tempVec30);
        var b = -Vector3.dot(p2Nor, CollisionUtil._tempVec31);
        var c = -Vector3.dot(p3Nor, CollisionUtil._tempVec32);
        Vector3.scale(CollisionUtil._tempVec30, p1.distance / a, CollisionUtil._tempVec30);
        Vector3.scale(CollisionUtil._tempVec31, p2.distance / b, CollisionUtil._tempVec31);
        Vector3.scale(CollisionUtil._tempVec32, p3.distance / c, CollisionUtil._tempVec32);
        Vector3.add(CollisionUtil._tempVec30, CollisionUtil._tempVec31, out);
        Vector3.add(out, CollisionUtil._tempVec32, out);
    };
    /**
   * Calculate the distance from a point to a plane.
   * @param plane - The plane
   * @param point - The point
   * @returns The distance from a point to a plane
   */ CollisionUtil.distancePlaneAndPoint = function distancePlaneAndPoint(plane, point) {
        return Vector3.dot(plane.normal, point) + plane.distance;
    };
    /**
   * Get the intersection type between a plane and a point.
   * @param plane - The plane
   * @param point - The point
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndPoint = function intersectsPlaneAndPoint(plane, point) {
        var distance = CollisionUtil.distancePlaneAndPoint(plane, point);
        if (distance > 0) {
            return PlaneIntersectionType.Front;
        }
        if (distance < 0) {
            return PlaneIntersectionType.Back;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a plane and a box (AABB).
   * @param plane - The plane
   * @param box - The box
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndBox = function intersectsPlaneAndBox(plane, box) {
        var min = box.min, max = box.max;
        var normal = plane.normal;
        var front = CollisionUtil._tempVec30;
        var back = CollisionUtil._tempVec31;
        if (normal.x >= 0) {
            front.x = max.x;
            back.x = min.x;
        } else {
            front.x = min.x;
            back.x = max.x;
        }
        if (normal.y >= 0) {
            front.y = max.y;
            back.y = min.y;
        } else {
            front.y = min.y;
            back.y = max.y;
        }
        if (normal.z >= 0) {
            front.z = max.z;
            back.z = min.z;
        } else {
            front.z = min.z;
            back.z = max.z;
        }
        if (CollisionUtil.distancePlaneAndPoint(plane, front) < 0) {
            return PlaneIntersectionType.Back;
        }
        if (CollisionUtil.distancePlaneAndPoint(plane, back) > 0) {
            return PlaneIntersectionType.Front;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a plane and a sphere.
   * @param plane - The plane
   * @param sphere - The sphere
   * @returns The intersection type
   */ CollisionUtil.intersectsPlaneAndSphere = function intersectsPlaneAndSphere(plane, sphere) {
        var center = sphere.center, radius = sphere.radius;
        var distance = CollisionUtil.distancePlaneAndPoint(plane, center);
        if (distance > radius) {
            return PlaneIntersectionType.Front;
        }
        if (distance < -radius) {
            return PlaneIntersectionType.Back;
        }
        return PlaneIntersectionType.Intersecting;
    };
    /**
   * Get the intersection type between a ray and a plane.
   * @param ray - The ray
   * @param plane - The plane
   * @returns The distance from ray to plane if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndPlane = function intersectsRayAndPlane(ray, plane) {
        var normal = plane.normal;
        var zeroTolerance = MathUtil.zeroTolerance;
        var dir = Vector3.dot(normal, ray.direction);
        // Parallel
        if (Math.abs(dir) < zeroTolerance) {
            return -1;
        }
        var position = Vector3.dot(normal, ray.origin);
        var distance = (-plane.distance - position) / dir;
        if (distance < 0) {
            if (distance < -zeroTolerance) {
                return -1;
            }
            distance = 0;
        }
        return distance;
    };
    /**
   * Get the intersection type between a ray and a box (AABB).
   * @param ray - The ray
   * @param box - The box
   * @returns The distance from ray to box if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndBox = function intersectsRayAndBox(ray, box) {
        var zeroTolerance = MathUtil.zeroTolerance;
        var origin = ray.origin, direction = ray.direction;
        var min = box.min, max = box.max;
        var dirX = direction.x;
        var dirY = direction.y;
        var dirZ = direction.z;
        var oriX = origin.x;
        var oriY = origin.y;
        var oriZ = origin.z;
        var distance = 0;
        var tmax = Number.MAX_VALUE;
        if (Math.abs(dirX) < zeroTolerance) {
            if (oriX < min.x || oriX > max.x) {
                return -1;
            }
        } else {
            var inverse = 1.0 / dirX;
            var t1 = (min.x - oriX) * inverse;
            var t2 = (max.x - oriX) * inverse;
            if (t1 > t2) {
                var temp = t1;
                t1 = t2;
                t2 = temp;
            }
            distance = Math.max(t1, distance);
            tmax = Math.min(t2, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        if (Math.abs(dirY) < zeroTolerance) {
            if (oriY < min.y || oriY > max.y) {
                return -1;
            }
        } else {
            var inverse1 = 1.0 / dirY;
            var t11 = (min.y - oriY) * inverse1;
            var t21 = (max.y - oriY) * inverse1;
            if (t11 > t21) {
                var temp1 = t11;
                t11 = t21;
                t21 = temp1;
            }
            distance = Math.max(t11, distance);
            tmax = Math.min(t21, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        if (Math.abs(dirZ) < zeroTolerance) {
            if (oriZ < min.z || oriZ > max.z) {
                return -1;
            }
        } else {
            var inverse2 = 1.0 / dirZ;
            var t12 = (min.z - oriZ) * inverse2;
            var t22 = (max.z - oriZ) * inverse2;
            if (t12 > t22) {
                var temp2 = t12;
                t12 = t22;
                t22 = temp2;
            }
            distance = Math.max(t12, distance);
            tmax = Math.min(t22, tmax);
            if (distance > tmax) {
                return -1;
            }
        }
        return distance;
    };
    /**
   * Get the intersection type between a ray and a sphere.
   * @param ray - The ray
   * @param sphere - The sphere
   * @returns The distance from ray to sphere if intersecting, -1 otherwise
   */ CollisionUtil.intersectsRayAndSphere = function intersectsRayAndSphere(ray, sphere) {
        var origin = ray.origin, direction = ray.direction;
        var center = sphere.center, radius = sphere.radius;
        var m = CollisionUtil._tempVec30;
        Vector3.subtract(origin, center, m);
        var b = Vector3.dot(m, direction);
        var c = Vector3.dot(m, m) - radius * radius;
        if (b > 0 && c > 0) {
            return -1;
        }
        var discriminant = b * b - c;
        if (discriminant < 0) {
            return -1;
        }
        var distance = -b - Math.sqrt(discriminant);
        if (distance < 0) {
            distance = 0;
        }
        return distance;
    };
    /**
   * Check whether the boxes intersect.
   * @param boxA - The first box to check
   * @param boxB - The second box to check
   * @returns True if the boxes intersect, false otherwise
   */ CollisionUtil.intersectsBoxAndBox = function intersectsBoxAndBox(boxA, boxB) {
        if (boxA.min.x > boxB.max.x || boxB.min.x > boxA.max.x) {
            return false;
        }
        if (boxA.min.y > boxB.max.y || boxB.min.y > boxA.max.y) {
            return false;
        }
        return !(boxA.min.z > boxB.max.z || boxB.min.z > boxA.max.z);
    };
    /**
   * Check whether the spheres intersect.
   * @param sphereA - The first sphere to check
   * @param sphereB - The second sphere to check
   * @returns True if the spheres intersect, false otherwise
   */ CollisionUtil.intersectsSphereAndSphere = function intersectsSphereAndSphere(sphereA, sphereB) {
        var radiisum = sphereA.radius + sphereB.radius;
        return Vector3.distanceSquared(sphereA.center, sphereB.center) < radiisum * radiisum;
    };
    /**
   * Check whether the sphere and the box intersect.
   * @param sphere - The sphere to check
   * @param box - The box to check
   * @returns True if the sphere and the box intersect, false otherwise
   */ CollisionUtil.intersectsSphereAndBox = function intersectsSphereAndBox(sphere, box) {
        var center = sphere.center;
        var max = box.max;
        var min = box.min;
        var closestPoint = CollisionUtil._tempVec30;
        closestPoint.set(Math.max(min.x, Math.min(center.x, max.x)), Math.max(min.y, Math.min(center.y, max.y)), Math.max(min.z, Math.min(center.z, max.z)));
        var distance = Vector3.distanceSquared(center, closestPoint);
        return distance <= sphere.radius * sphere.radius;
    };
    /**
   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
   * @param frustum - The frustum
   * @param box - The box
   * @returns True if bounding box intersects with this frustum, false otherwise
   */ CollisionUtil.intersectsFrustumAndBox = function intersectsFrustumAndBox(frustum, box) {
        var min = box.min, max = box.max;
        var p = CollisionUtil._tempVec30;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var normal = plane.normal;
            p.set(normal.x >= 0 ? max.x : min.x, normal.y >= 0 ? max.y : min.y, normal.z >= 0 ? max.z : min.z);
            if (Vector3.dot(normal, p) < -plane.distance) {
                return false;
            }
        }
        return true;
    };
    /**
   * Get the containment type between a frustum and a box (AABB).
   * @param frustum - The frustum
   * @param box - The box
   * @returns The containment type
   */ CollisionUtil.frustumContainsBox = function frustumContainsBox(frustum, box) {
        var min = box.min, max = box.max;
        var p = CollisionUtil._tempVec30;
        var n = CollisionUtil._tempVec31;
        var result = ContainmentType.Contains;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var normal = plane.normal;
            if (normal.x >= 0) {
                p.x = max.x;
                n.x = min.x;
            } else {
                p.x = min.x;
                n.x = max.x;
            }
            if (normal.y >= 0) {
                p.y = max.y;
                n.y = min.y;
            } else {
                p.y = min.y;
                n.y = max.y;
            }
            if (normal.z >= 0) {
                p.z = max.z;
                n.z = min.z;
            } else {
                p.z = min.z;
                n.z = max.z;
            }
            if (CollisionUtil.intersectsPlaneAndPoint(plane, p) === PlaneIntersectionType.Back) {
                return ContainmentType.Disjoint;
            }
            if (CollisionUtil.intersectsPlaneAndPoint(plane, n) === PlaneIntersectionType.Back) {
                result = ContainmentType.Intersects;
            }
        }
        return result;
    };
    /**
   * Get the containment type between a frustum and a sphere.
   * @param frustum - The frustum
   * @param sphere - The sphere
   * @returns The containment type
   */ CollisionUtil.frustumContainsSphere = function frustumContainsSphere(frustum, sphere) {
        var result = ContainmentType.Contains;
        for(var i = 0; i < 6; ++i){
            var plane = frustum.getPlane(i);
            var intersectionType = CollisionUtil.intersectsPlaneAndSphere(plane, sphere);
            if (intersectionType === PlaneIntersectionType.Back) {
                return ContainmentType.Disjoint;
            } else if (intersectionType === PlaneIntersectionType.Intersecting) {
                result = ContainmentType.Intersects;
                break;
            }
        }
        return result;
    };
    return CollisionUtil;
}();
(function() {
    CollisionUtil._tempVec30 = new Vector3();
})();
(function() {
    CollisionUtil._tempVec31 = new Vector3();
})();
(function() {
    CollisionUtil._tempVec32 = new Vector3();
})();

/**
 * Represents a plane in three-dimensional space.
 */ var Plane = /*#__PURE__*/ function() {
    function Plane(normal, distance) {
        if (normal === void 0) normal = null;
        if (distance === void 0) distance = 0;
        /** The normal of the plane. */ this.normal = new Vector3();
        /** The distance of the plane along its normal to the origin. */ this.distance = 0;
        normal && this.normal.copyFrom(normal);
        this.distance = distance;
    }
    var _proto = Plane.prototype;
    /**
   * Normalize the normal vector of this plane.
   * @returns The plane after normalize
   */ _proto.normalize = function normalize() {
        Plane.normalize(this, this);
        return this;
    };
    /**
   * Creates a clone of this plane.
   * @returns A clone of this plane
   */ _proto.clone = function clone() {
        var out = new Plane();
        out.copyFrom(this);
        return out;
    };
    /**
   * Copy this plane from the specified plane.
   * @param source - The specified plane
   * @returns This plane
   */ _proto.copyFrom = function copyFrom(source) {
        this.normal.copyFrom(source.normal);
        this.distance = source.distance;
        return this;
    };
    /**
   * Normalize the normal vector of the specified plane.
   * @param p - The specified plane
   * @param out - A normalized version of the specified plane
   */ Plane.normalize = function normalize(p, out) {
        var normal = p.normal;
        var factor = 1.0 / normal.length();
        Vector3.scale(normal, factor, out.normal);
        out.distance = p.distance * factor;
    };
    /**
   * Calculate the plane that contains the three specified points.
   * @param point0 - The first point
   * @param point1 - The second point
   * @param point2 - The third point
   * @param out - The calculated plane
   */ Plane.fromPoints = function fromPoints(point0, point1, point2, out) {
        var x0 = point0.x;
        var y0 = point0.y;
        var z0 = point0.z;
        var x1 = point1.x - x0;
        var y1 = point1.y - y0;
        var z1 = point1.z - z0;
        var x2 = point2.x - x0;
        var y2 = point2.y - y0;
        var z2 = point2.z - z0;
        var yz = y1 * z2 - z1 * y2;
        var xz = z1 * x2 - x1 * z2;
        var xy = x1 * y2 - y1 * x2;
        var invPyth = 1.0 / Math.sqrt(yz * yz + xz * xz + xy * xy);
        var x = yz * invPyth;
        var y = xz * invPyth;
        var z = xy * invPyth;
        var normal = out.normal;
        normal.x = x;
        normal.y = y;
        normal.z = z;
        out.distance = -(x * x0 + y * y0 + z * z0);
    };
    return Plane;
}();

/**
 * A bounding frustum.
 */ var BoundingFrustum = /*#__PURE__*/ function() {
    function BoundingFrustum(matrix) {
        if (matrix === void 0) matrix = null;
        this.near = new Plane();
        this.far = new Plane();
        this.left = new Plane();
        this.right = new Plane();
        this.top = new Plane();
        this.bottom = new Plane();
        matrix && this.calculateFromMatrix(matrix);
    }
    var _proto = BoundingFrustum.prototype;
    /**
   * Get the plane by the given frustum face.
   * @param face - The frustum face
   * @returns The plane get
   */ _proto.getPlane = function getPlane(face) {
        switch(face){
            case FrustumFace.Near:
                return this.near;
            case FrustumFace.Far:
                return this.far;
            case FrustumFace.Left:
                return this.left;
            case FrustumFace.Right:
                return this.right;
            case FrustumFace.Bottom:
                return this.bottom;
            case FrustumFace.Top:
                return this.top;
            default:
                return null;
        }
    };
    /**
   * Update all planes from the given matrix.
   * @param matrix - The given view-projection matrix
   */ _proto.calculateFromMatrix = function calculateFromMatrix(matrix) {
        var me = matrix.elements;
        var m11 = me[0];
        var m12 = me[1];
        var m13 = me[2];
        var m14 = me[3];
        var m21 = me[4];
        var m22 = me[5];
        var m23 = me[6];
        var m24 = me[7];
        var m31 = me[8];
        var m32 = me[9];
        var m33 = me[10];
        var m34 = me[11];
        var m41 = me[12];
        var m42 = me[13];
        var m43 = me[14];
        var m44 = me[15];
        // near
        var nearNormal = this.near.normal;
        nearNormal.set(m14 + m13, m24 + m23, m34 + m33);
        this.near.distance = m44 + m43;
        this.near.normalize();
        // far
        var farNormal = this.far.normal;
        farNormal.set(m14 - m13, m24 - m23, m34 - m33);
        this.far.distance = m44 - m43;
        this.far.normalize();
        // left
        var leftNormal = this.left.normal;
        leftNormal.set(m14 + m11, m24 + m21, m34 + m31);
        this.left.distance = m44 + m41;
        this.left.normalize();
        // right
        var rightNormal = this.right.normal;
        rightNormal.set(m14 - m11, m24 - m21, m34 - m31);
        this.right.distance = m44 - m41;
        this.right.normalize();
        // bottom
        var bottomNormal = this.bottom.normal;
        bottomNormal.set(m14 + m12, m24 + m22, m34 + m32);
        this.bottom.distance = m44 + m42;
        this.bottom.normalize();
        // top
        var topNormal = this.top.normal;
        topNormal.set(m14 - m12, m24 - m22, m34 - m32);
        this.top.distance = m44 - m42;
        this.top.normalize();
    };
    /**
   * Get whether or not a specified bounding box intersects with this frustum (Contains or Intersects).
   * @param box - The box for testing
   * @returns True if bounding box intersects with this frustum, false otherwise
   */ _proto.intersectsBox = function intersectsBox(box) {
        return CollisionUtil.intersectsFrustumAndBox(this, box);
    };
    /**
   * Get whether or not a specified bounding sphere intersects with this frustum (Contains or Intersects).
   * @param sphere - The sphere for testing
   * @returns True if bounding sphere intersects with this frustum, false otherwise
   */ _proto.intersectsSphere = function intersectsSphere(sphere) {
        return CollisionUtil.frustumContainsSphere(this, sphere) !== ContainmentType.Disjoint;
    };
    /**
   * Creates a clone of this frustum.
   * @returns A clone of this frustum
   */ _proto.clone = function clone() {
        var out = new BoundingFrustum();
        out.copyFrom(this);
        return out;
    };
    /**
   * Copy this frustum from the specified frustum.
   * @param source - The specified frustum
   * @returns This frustum
   */ _proto.copyFrom = function copyFrom(source) {
        this.near.copyFrom(source.near);
        this.far.copyFrom(source.far);
        this.left.copyFrom(source.left);
        this.right.copyFrom(source.right);
        this.bottom.copyFrom(source.bottom);
        this.top.copyFrom(source.top);
        return this;
    };
    return BoundingFrustum;
}();

/**
 * Represents a 3x3 mathematical matrix.
 */ var Matrix3x3 = /*#__PURE__*/ function() {
    function Matrix3x3(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        if (m11 === void 0) m11 = 1;
        if (m12 === void 0) m12 = 0;
        if (m13 === void 0) m13 = 0;
        if (m21 === void 0) m21 = 0;
        if (m22 === void 0) m22 = 1;
        if (m23 === void 0) m23 = 0;
        if (m31 === void 0) m31 = 0;
        if (m32 === void 0) m32 = 0;
        if (m33 === void 0) m33 = 1;
        /**
   * An array containing the elements of the matrix (column matrix).
   * @remarks
   * elements[0] first column and first row value m11
   * elements[1] first column and second row value m12
   * elements[2] first column and third row value m13
   * elements[3] second column and first row value m21
   * and so on
   */ this.elements = new Float32Array(9);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
    }
    var _proto = Matrix3x3.prototype;
    /**
   * Set the value of this matrix, and return this matrix.
   * @param m11
   * @param m12
   * @param m13
   * @param m21
   * @param m22
   * @param m23
   * @param m31
   * @param m32
   * @param m33
   * @returns This matrix
   */ _proto.set = function set(m11, m12, m13, m21, m22, m23, m31, m32, m33) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m21;
        e[4] = m22;
        e[5] = m23;
        e[6] = m31;
        e[7] = m32;
        e[8] = m33;
        return this;
    };
    /**
   * Determines the sum of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the sum of the two matrices
   */ _proto.add = function add(right) {
        Matrix3x3.add(this, right, this);
        return this;
    };
    /**
   * Determines the difference between this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the difference between the two matrices
   */ _proto.subtract = function subtract(right) {
        Matrix3x3.subtract(this, right, this);
        return this;
    };
    /**
   * Determines the product of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the product of the two matrices
   */ _proto.multiply = function multiply(right) {
        Matrix3x3.multiply(this, right, this);
        return this;
    };
    /**
   * Calculate a determinant of this matrix.
   * @returns The determinant of this matrix
   */ _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2];
        var a21 = e[3], a22 = e[4], a23 = e[5];
        var a31 = e[6], a32 = e[7], a33 = e[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        return a11 * b12 + a12 * b22 + a13 * b32;
    };
    /**
   * Identity this matrix.
   * @returns This matrix after identity
   */ _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 1;
        e[5] = 0;
        e[6] = 0;
        e[7] = 0;
        e[8] = 1;
        return this;
    };
    /**
   * Invert the matrix.
   * @returns The matrix after invert
   */ _proto.invert = function invert() {
        Matrix3x3.invert(this, this);
        return this;
    };
    /**
   * This matrix rotates around an angle.
   * @param r - The rotation angle in radians
   * @returns This matrix after rotate
   */ _proto.rotate = function rotate(r) {
        Matrix3x3.rotate(this, r, this);
        return this;
    };
    /**
   * Scale this matrix by a given vector.
   * @param s - The given vector
   * @returns This matrix after scale
   */ _proto.scale = function scale(s) {
        Matrix3x3.scale(this, s, this);
        return this;
    };
    /**
   * Translate this matrix by a given vector.
   * @param translation - The given vector
   * @returns This matrix after translate
   */ _proto.translate = function translate(translation) {
        Matrix3x3.translate(this, translation, this);
        return this;
    };
    /**
   * Calculate the transpose of this matrix.
   * @returns This matrix after transpose
   */ _proto.transpose = function transpose() {
        Matrix3x3.transpose(this, this);
        return this;
    };
    /**
   * Creates a clone of this matrix.
   * @returns A clone of this matrix
   */ _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix3x3(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        return ret;
    };
    /**
   * Copy this matrix from the specified matrix.
   * @param source - The specified matrix
   * @returns This matrix
   */ _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        return this;
    };
    /**
   * Copy the value of this matrix from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This matrix
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var srce = this.elements;
        for(var i = 0; i < 12; i++){
            srce[i] = array[i + offset];
        }
        return this;
    };
    /**
   * Copy the value of this matrix to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
    };
    /**
   * Copy the value of this 3x3 matrix from the specified 4x4 matrix.
   * upper-left principle
   * @param source - The specified 4x4 matrix
   * @returns This 3x3 matrix
   */ _proto.copyFromMatrix = function copyFromMatrix(source) {
        var ae = source.elements;
        var e = this.elements;
        e[0] = ae[0];
        e[1] = ae[1];
        e[2] = ae[2];
        e[3] = ae[4];
        e[4] = ae[5];
        e[5] = ae[6];
        e[6] = ae[8];
        e[7] = ae[9];
        e[8] = ae[10];
        return this;
    };
    /**
   * Determines the sum of two matrices.
   * @param left - The first matrix to add
   * @param right - The second matrix to add
   * @param out - The sum of two matrices
   */ Matrix3x3.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
    };
    /**
   * Determines the difference between two matrices.
   * @param left - The first matrix to subtract
   * @param right - The second matrix to subtract
   * @param out - The difference between two matrices
   */ Matrix3x3.subtract = function subtract(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] - re[0];
        oe[1] = le[1] - re[1];
        oe[2] = le[2] - re[2];
        oe[3] = le[3] - re[3];
        oe[4] = le[4] - re[4];
        oe[5] = le[5] - re[5];
        oe[6] = le[6] - re[6];
        oe[7] = le[7] - re[7];
        oe[8] = le[8] - re[8];
    };
    /**
   * Determines the product of two matrices.
   * @param left - The first matrix to multiply
   * @param right - The second matrix to multiply
   * @param out - The product of two matrices
   */ Matrix3x3.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        var l11 = le[0], l12 = le[1], l13 = le[2];
        var l21 = le[3], l22 = le[4], l23 = le[5];
        var l31 = le[6], l32 = le[7], l33 = le[8];
        var r11 = re[0], r12 = re[1], r13 = re[2];
        var r21 = re[3], r22 = re[4], r23 = re[5];
        var r31 = re[6], r32 = re[7], r33 = re[8];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13;
        oe[3] = l11 * r21 + l21 * r22 + l31 * r23;
        oe[4] = l12 * r21 + l22 * r22 + l32 * r23;
        oe[5] = l13 * r21 + l23 * r22 + l33 * r23;
        oe[6] = l11 * r31 + l21 * r32 + l31 * r33;
        oe[7] = l12 * r31 + l22 * r32 + l32 * r33;
        oe[8] = l13 * r31 + l23 * r32 + l33 * r33;
    };
    /**
   * Determines whether the specified matrices are equals.
   * @param left - The first matrix to compare
   * @param right - The second matrix to compare
   * @returns True if the specified matrices are equals, false otherwise
   */ Matrix3x3.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]);
    };
    /**
   * Performs a linear interpolation between two matrices.
   * @param start - The first matrix
   * @param end - The second matrix
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two matrices
   */ Matrix3x3.lerp = function lerp(start, end, t, out) {
        var se = start.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1.0 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
    };
    /**
   * Calculate a rotation matrix from a quaternion.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param out - The calculated rotation matrix
   */ Matrix3x3.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[3] = yx - wz;
        oe[6] = zx + wy;
        oe[1] = yx + wz;
        oe[4] = 1 - xx - zz;
        oe[7] = zy - wx;
        oe[2] = zx - wy;
        oe[5] = zy + wx;
        oe[8] = 1 - xx - yy;
    };
    /**
   * Calculate a matrix from scale vector.
   * @param s - The scale vector
   * @param out - The calculated matrix
   */ Matrix3x3.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = s._y;
        oe[5] = 0;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 1;
    };
    /**
   * Calculate a matrix from translation vector.
   * @param translation - The translation vector
   * @param out - The calculated matrix
   */ Matrix3x3.translation = function translation(translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 1;
        oe[5] = 0;
        oe[6] = translation._x;
        oe[7] = translation._y;
        oe[8] = 1;
    };
    /**
   * Calculate the inverse of the specified matrix.
   * @param a - The matrix whose inverse is to be calculated
   * @param out - The inverse of the specified matrix
   */ Matrix3x3.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        var b12 = a33 * a22 - a23 * a32;
        var b22 = -a33 * a21 + a23 * a31;
        var b32 = a32 * a21 - a22 * a31;
        var det = a11 * b12 + a12 * b22 + a13 * b32;
        if (!det) {
            return;
        }
        det = 1.0 / det;
        oe[0] = b12 * det;
        oe[1] = (-a33 * a12 + a13 * a32) * det;
        oe[2] = (a23 * a12 - a13 * a22) * det;
        oe[3] = b22 * det;
        oe[4] = (a33 * a11 - a13 * a31) * det;
        oe[5] = (-a23 * a11 + a13 * a21) * det;
        oe[6] = b32 * det;
        oe[7] = (-a32 * a11 + a12 * a31) * det;
        oe[8] = (a22 * a11 - a12 * a21) * det;
    };
    /**
   * Calculate a 3x3 normal matrix from a 4x4 matrix.
   * @remarks The calculation process is the transpose matrix of the inverse matrix.
   * @param mat4 - The 4x4 matrix
   * @param out - THe 3x3 normal matrix
   */ Matrix3x3.normalMatrix = function normalMatrix(mat4, out) {
        var ae = mat4.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[2] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[3] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[4] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[5] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[6] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[7] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[8] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
    };
    /**
   * The specified matrix rotates around an angle.
   * @param a - The specified matrix
   * @param r - The rotation angle in radians
   * @param out - The rotated matrix
   */ Matrix3x3.rotate = function rotate(a, r, out) {
        var ae = a.elements;
        var oe = out.elements;
        var s = Math.sin(r);
        var c = Math.cos(r);
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = c * a11 + s * a21;
        oe[1] = c * a12 + s * a22;
        oe[2] = c * a13 + s * a23;
        oe[3] = c * a21 - s * a11;
        oe[4] = c * a22 - s * a12;
        oe[5] = c * a23 - s * a13;
        oe[6] = a31;
        oe[7] = a32;
        oe[8] = a33;
    };
    /**
   * Scale a matrix by a given vector.
   * @param m - The matrix
   * @param s - The given vector
   * @param out - The scaled matrix
   */ Matrix3x3.scale = function scale(m, s, out) {
        var x = s._x, y = s._y;
        var ae = m.elements;
        var oe = out.elements;
        oe[0] = x * ae[0];
        oe[1] = x * ae[1];
        oe[2] = x * ae[2];
        oe[3] = y * ae[3];
        oe[4] = y * ae[4];
        oe[5] = y * ae[5];
        oe[6] = ae[6];
        oe[7] = ae[7];
        oe[8] = ae[8];
    };
    /**
   * Translate a matrix by a given vector.
   * @param m - The matrix
   * @param translation - The given vector
   * @param out - The translated matrix
   */ Matrix3x3.translate = function translate(m, translation, out) {
        var x = translation._x, y = translation._y;
        var ae = m.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2];
        var a21 = ae[3], a22 = ae[4], a23 = ae[5];
        var a31 = ae[6], a32 = ae[7], a33 = ae[8];
        oe[0] = a11;
        oe[1] = a12;
        oe[2] = a13;
        oe[3] = a21;
        oe[4] = a22;
        oe[5] = a23;
        oe[6] = x * a11 + y * a21 + a31;
        oe[7] = x * a12 + y * a22 + a32;
        oe[8] = x * a13 + y * a23 + a33;
    };
    /**
   * Calculate the transpose of the specified matrix.
   * @param a - The specified matrix
   * @param out - The transpose of the specified matrix
   */ Matrix3x3.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
            var a12 = ae[1];
            var a13 = ae[2];
            var a23 = ae[5];
            oe[1] = ae[3];
            oe[2] = ae[6];
            oe[3] = a12;
            oe[5] = ae[7];
            oe[6] = a13;
            oe[7] = a23;
        } else {
            oe[0] = ae[0];
            oe[1] = ae[3];
            oe[2] = ae[6];
            oe[3] = ae[1];
            oe[4] = ae[4];
            oe[5] = ae[7];
            oe[6] = ae[2];
            oe[7] = ae[5];
            oe[8] = ae[8];
        }
    };
    return Matrix3x3;
}();

/**
 * Represents a four dimensional mathematical quaternion.
 */ var Quaternion = /*#__PURE__*/ function() {
    function Quaternion(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 1;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    var _proto = Quaternion.prototype;
    /**
   * Set the value of this quaternion, and return this quaternion.
   * @param x - The x component of the quaternion
   * @param y - The y component of the quaternion
   * @param z - The z component of the quaternion
   * @param w - The w component of the quaternion
   * @returns This quaternion
   */ _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Transforms this quaternion into its conjugated version.
   * @returns This quaternion
   */ _proto.conjugate = function conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Get the rotation axis and rotation angle of the quaternion (unit: radians).
   * @param out - The axis as an output parameter
   * @returns The rotation angle (unit: radians)
   */ _proto.getAxisAngle = function getAxisAngle(out) {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z;
        var length = _x * _x + _y * _y + _z * _z;
        if (length < MathUtil.zeroTolerance) {
            out._x = 1;
            out._y = 0;
            out._z = 0;
            return 0;
        } else {
            var inv = 1.0 / length;
            out._x = this._x * inv;
            out._y = this._y * inv;
            out._z = this._z * inv;
            return Math.acos(this._w) * 2.0;
        }
    };
    /**
   * Identity this quaternion.
   * @returns This quaternion after identity
   */ _proto.identity = function identity() {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this quaternion.
   * @returns The length of this quaternion
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    };
    /**
   * Calculates the squared length of this quaternion.
   * @returns The squared length of this quaternion
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
    };
    /**
   * Converts this quaternion into a unit quaternion.
   * @returns This quaternion
   */ _proto.normalize = function normalize() {
        Quaternion.normalize(this, this);
        return this;
    };
    /**
   * Get the euler of this quaternion.
   * @param out - The euler (in radians) as an output parameter
   * @returns Euler x->pitch y->yaw z->roll
   */ _proto.toEuler = function toEuler(out) {
        this._toYawPitchRoll(out);
        var t = out._x;
        out._x = out._y;
        out._y = t;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Get the euler of this quaternion.
   * @param out - The euler (in radians) as an output parameter
   * @returns Euler x->yaw y->pitch z->roll
   */ _proto.toYawPitchRoll = function toYawPitchRoll(out) {
        this._toYawPitchRoll(out);
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Calculate this quaternion rotate around X axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateX = function rotateX(rad) {
        Quaternion.rotateX(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotate around Y axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateY = function rotateY(rad) {
        Quaternion.rotateY(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotate around Z axis.
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateZ = function rotateZ(rad) {
        Quaternion.rotateZ(this, rad, this);
        return this;
    };
    /**
   * Calculate this quaternion rotates around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotationAxisAngle = function rotationAxisAngle(axis, rad) {
        Quaternion.rotationAxisAngle(axis, rad, this);
        return this;
    };
    /**
   * Determines the product of this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @returns The product of the two quaternions
   */ _proto.multiply = function multiply(quat) {
        Quaternion.multiply(this, quat, this);
        return this;
    };
    /**
   * Invert this quaternion.
   * @returns This quaternion after invert
   */ _proto.invert = function invert() {
        Quaternion.invert(this, this);
        return this;
    };
    /**
   * Determines the dot product of this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @returns The dot product of two quaternions
   */ _proto.dot = function dot(quat) {
        return Quaternion.dot(this, quat);
    };
    /**
   * Performs a linear blend between this quaternion and the specified quaternion.
   * @param quat - The specified quaternion
   * @param t - The blend amount where 0 returns this and 1 quat
   * @returns - The result of linear blending between two quaternions
   */ _proto.lerp = function lerp(quat, t) {
        Quaternion.lerp(this, quat, t, this);
        return this;
    };
    /**
   * Calculate this quaternion rotation around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @returns This quaternion
   */ _proto.rotateAxisAngle = function rotateAxisAngle(axis, rad) {
        Quaternion._tempQuat1.rotationAxisAngle(axis, rad);
        this.multiply(Quaternion._tempQuat1);
        return this;
    };
    /**
   * Creates a clone of this quaternion.
   * @returns A clone of this quaternion
   */ _proto.clone = function clone() {
        return new Quaternion(this._x, this._y, this._z, this._w);
    };
    /**
   * Copy this quaternion from the specified quaternion.
   * @param source - The specified quaternion
   * @returns This quaternion
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this quaternion from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This quaternion
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this quaternion to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
    };
    /**
   * Serialize this quaternion to a JSON representation.
   * @returns A JSON Object representation of this quaternion
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z,
            w: this._w
        };
    };
    _proto._toYawPitchRoll = function _toYawPitchRoll(out) {
        // https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
        var _this = this, x = _this._x, y = _this._y, z = _this._z, w = _this._w;
        var xx = x * x;
        var sinP = 2.0 * (x * w - y * z);
        // use 90 degrees if out of range
        out._y = Math.abs(sinP) >= 1 ? Math.sign(sinP) * (Math.PI / 2) : Math.asin(sinP);
        out._x = Math.atan2(2.0 * (z * x + y * w), 1.0 - 2.0 * (y * y + xx));
        out._z = Math.atan2(2.0 * (x * y + z * w), 1.0 - 2.0 * (z * z + xx));
    };
    /**
   * Determines the sum of two quaternions.
   * @param left - The first quaternion to add
   * @param right - The second quaternion to add
   * @param out - The sum of two quaternions
   */ Quaternion.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two quaternions.
   * @param left - The first quaternion to multiply
   * @param right - The second quaternion to multiply
   * @param out - The product of two quaternions
   */ Quaternion.multiply = function multiply(left, right, out) {
        var ax = left._x, ay = left._y, az = left._z, aw = left._w;
        var bx = right._x, by = right._y, bz = right._z, bw = right._w;
        out._x = ax * bw + aw * bx + ay * bz - az * by;
        out._y = ay * bw + aw * by + az * bx - ax * bz;
        out._z = az * bw + aw * bz + ax * by - ay * bx;
        out._w = aw * bw - ax * bx - ay * by - az * bz;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate quaternion that contains conjugated version of the specified quaternion.
   * @param a - The specified quaternion
   * @param out - The conjugate version of the specified quaternion
   */ Quaternion.conjugate = function conjugate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = a._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two quaternions.
   * @param left - The first quaternion to dot
   * @param right - The second quaternion to dot
   * @returns The dot product of two quaternions
   */ Quaternion.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    };
    /**
   * Determines whether the specified quaternions are equals.
   * @param left - The first quaternion to compare
   * @param right - The second quaternion to compare
   * @returns True if the specified quaternions are equals, false otherwise
   */ Quaternion.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
    };
    /**
   * Calculate a quaternion rotates around an arbitrary axis.
   * @param axis - The axis
   * @param rad - The rotation angle in radians
   * @param out - The quaternion after rotate
   */ Quaternion.rotationAxisAngle = function rotationAxisAngle(axis, rad, out) {
        var normalAxis = Quaternion._tempVector3;
        Vector3.normalize(axis, normalAxis);
        rad *= 0.5;
        var s = Math.sin(rad);
        out._x = normalAxis._x * s;
        out._y = normalAxis._y * s;
        out._z = normalAxis._z * s;
        out._w = Math.cos(rad);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion rotates around x, y, z axis (pitch/yaw/roll).
   * @param x - The radian of rotation around X (pitch)
   * @param y - The radian of rotation around Y (yaw)
   * @param z - The radian of rotation around Z (roll)
   * @param out - The calculated quaternion
   */ Quaternion.rotationEuler = function rotationEuler(x, y, z, out) {
        Quaternion.rotationYawPitchRoll(y, x, z, out);
    };
    /**
   * Calculate a quaternion from the specified yaw, pitch and roll angles.
   * @param yaw - Yaw around the y axis in radians
   * @param pitch - Pitch around the x axis in radians
   * @param roll - Roll around the z axis in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationYawPitchRoll = function rotationYawPitchRoll(yaw, pitch, roll, out) {
        var halfRoll = roll * 0.5;
        var halfPitch = pitch * 0.5;
        var halfYaw = yaw * 0.5;
        var sinRoll = Math.sin(halfRoll);
        var cosRoll = Math.cos(halfRoll);
        var sinPitch = Math.sin(halfPitch);
        var cosPitch = Math.cos(halfPitch);
        var sinYaw = Math.sin(halfYaw);
        var cosYaw = Math.cos(halfYaw);
        var cosYawPitch = cosYaw * cosPitch;
        var sinYawPitch = sinYaw * sinPitch;
        out._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        out._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        out._z = cosYawPitch * sinRoll - sinYawPitch * cosRoll;
        out._w = cosYawPitch * cosRoll + sinYawPitch * sinRoll;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion from the specified 3x3 matrix.
   * @param m - The specified 3x3 matrix
   * @param out - The calculated quaternion
   */ Quaternion.rotationMatrix3x3 = function rotationMatrix3x3(m, out) {
        var me = m.elements;
        var m11 = me[0], m12 = me[1], m13 = me[2];
        var m21 = me[3], m22 = me[4], m23 = me[5];
        var m31 = me[6], m32 = me[7], m33 = me[8];
        var scale = m11 + m22 + m33;
        var sqrt, half;
        if (scale > 0) {
            sqrt = Math.sqrt(scale + 1.0);
            out._w = sqrt * 0.5;
            sqrt = 0.5 / sqrt;
            out._x = (m23 - m32) * sqrt;
            out._y = (m31 - m13) * sqrt;
            out._z = (m12 - m21) * sqrt;
        } else if (m11 >= m22 && m11 >= m33) {
            sqrt = Math.sqrt(1.0 + m11 - m22 - m33);
            half = 0.5 / sqrt;
            out._x = 0.5 * sqrt;
            out._y = (m12 + m21) * half;
            out._z = (m13 + m31) * half;
            out._w = (m23 - m32) * half;
        } else if (m22 > m33) {
            sqrt = Math.sqrt(1.0 + m22 - m11 - m33);
            half = 0.5 / sqrt;
            out._x = (m21 + m12) * half;
            out._y = 0.5 * sqrt;
            out._z = (m32 + m23) * half;
            out._w = (m31 - m13) * half;
        } else {
            sqrt = Math.sqrt(1.0 + m33 - m11 - m22);
            half = 0.5 / sqrt;
            out._x = (m13 + m31) * half;
            out._y = (m23 + m32) * half;
            out._z = 0.5 * sqrt;
            out._w = (m12 - m21) * half;
        }
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate the inverse of the specified quaternion.
   * @param a - The quaternion whose inverse is to be calculated
   * @param out - The inverse of the specified quaternion
   */ Quaternion.invert = function invert(a, out) {
        var x = a._x, y = a._y, z = a._z, w = a._w;
        var dot = x * x + y * y + z * z + w * w;
        if (dot > MathUtil.zeroTolerance) {
            var invDot = 1.0 / dot;
            out._x = -x * invDot;
            out._y = -y * invDot;
            out._z = -z * invDot;
            out._w = w * invDot;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Performs a linear blend between two quaternions.
   * @param start - The first quaternion
   * @param end - The second quaternion
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two quaternions
   */ Quaternion.lerp = function lerp(start, end, t, out) {
        var inv = 1.0 - t;
        if (Quaternion.dot(start, end) >= 0) {
            out._x = start._x * inv + end._x * t;
            out._y = start._y * inv + end._y * t;
            out._z = start._z * inv + end._z * t;
            out._w = start._w * inv + end._w * t;
        } else {
            out._x = start._x * inv - end._x * t;
            out._y = start._y * inv - end._y * t;
            out._z = start._z * inv - end._z * t;
            out._w = start._w * inv - end._w * t;
        }
        out.normalize();
    };
    /**
   * Performs a spherical linear blend between two quaternions.
   * @param start - The first quaternion
   * @param end - The second quaternion
   * @param amount - The blend amount where 0 returns start and 1 end
   * @param out - The result of spherical linear blending between two quaternions
   */ Quaternion.slerp = function slerp(start, end, amount, out) {
        var opposite;
        var inverse;
        var dot = Quaternion.dot(start, end);
        if (Math.abs(dot) > 1.0 - MathUtil.zeroTolerance) {
            inverse = 1.0 - amount;
            opposite = amount * Math.sign(dot);
        } else {
            var acos = Math.acos(Math.abs(dot));
            var invSin = 1.0 / Math.sin(acos);
            inverse = Math.sin((1.0 - amount) * acos) * invSin;
            opposite = Math.sin(amount * acos) * invSin * Math.sign(dot);
        }
        out.x = inverse * start.x + opposite * end.x;
        out.y = inverse * start.y + opposite * end.y;
        out.z = inverse * start.z + opposite * end.z;
        out.w = inverse * start.w + opposite * end.w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scales the specified quaternion magnitude to unit length.
   * @param a - The specified quaternion
   * @param out - The normalized quaternion
   */ Quaternion.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._z = _z * len;
            out._w = _w * len;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Calculate a quaternion rotate around X axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationX = function rotationX(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = s;
        out._y = 0;
        out._z = 0;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion rotate around Y axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationY = function rotationY(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = s;
        out._z = 0;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion rotate around Z axis.
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotationZ = function rotationZ(rad, out) {
        rad *= 0.5;
        var s = Math.sin(rad);
        var c = Math.cos(rad);
        out._x = 0;
        out._y = 0;
        out._z = s;
        out._w = c;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around X axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateX = function rotateX(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bx = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _w * bx;
        out._y = _y * bw + _z * bx;
        out._z = _z * bw - _y * bx;
        out._w = _w * bw - _x * bx;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around Y axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateY = function rotateY(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var by = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw - _z * by;
        out._y = _y * bw + _w * by;
        out._z = _z * bw + _x * by;
        out._w = _w * bw - _y * by;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a quaternion that the specified quaternion rotate around Z axis.
   * @param quaternion - The specified quaternion
   * @param rad - The rotation angle in radians
   * @param out - The calculated quaternion
   */ Quaternion.rotateZ = function rotateZ(quaternion, rad, out) {
        var _x = quaternion._x, _y = quaternion._y, _z = quaternion._z, _w = quaternion._w;
        rad *= 0.5;
        var bz = Math.sin(rad);
        var bw = Math.cos(rad);
        out._x = _x * bw + _y * bz;
        out._y = _y * bw - _x * bz;
        out._z = _z * bw + _w * bz;
        out._w = _w * bw - _z * bz;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scale a quaternion by a given number.
   * @param a - The quaternion
   * @param s - The given number
   * @param out - The scaled quaternion
   */ Quaternion.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class(Quaternion, [
        {
            key: "x",
            get: /**
   * The x component of the quaternion.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the quaternion.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the quaternion.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "normalized",
            get: /**
   * Indicting whether this instance is normalized.
   */ function get() {
                return Math.abs(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w - 1) < MathUtil.zeroTolerance;
            }
        },
        {
            key: "w",
            get: /**
   * The w component of the quaternion.
   */ function get() {
                return this._w;
            },
            set: function set(value) {
                this._w = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Quaternion;
}();
(function() {
    /** @internal */ Quaternion._tempVector3 = new Vector3();
})();
(function() {
    /** @internal */ Quaternion._tempQuat1 = new Quaternion();
})();

/**
 * Represents a 4x4 mathematical matrix.
 */ var Matrix = /*#__PURE__*/ function() {
    function Matrix(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        if (m11 === void 0) m11 = 1;
        if (m12 === void 0) m12 = 0;
        if (m13 === void 0) m13 = 0;
        if (m14 === void 0) m14 = 0;
        if (m21 === void 0) m21 = 0;
        if (m22 === void 0) m22 = 1;
        if (m23 === void 0) m23 = 0;
        if (m24 === void 0) m24 = 0;
        if (m31 === void 0) m31 = 0;
        if (m32 === void 0) m32 = 0;
        if (m33 === void 0) m33 = 1;
        if (m34 === void 0) m34 = 0;
        if (m41 === void 0) m41 = 0;
        if (m42 === void 0) m42 = 0;
        if (m43 === void 0) m43 = 0;
        if (m44 === void 0) m44 = 1;
        /**
   * An array containing the elements of the matrix (column matrix).
   * @remarks
   * elements[0] first column and first row value m11
   * elements[1] first column and second row value m12
   * elements[2] first column and third row value m13
   * elements[3] first column and fourth row value m14
   * elements[4] second column and first row value m21
   * and so on
   */ this.elements = new Float32Array(16);
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
    }
    var _proto = Matrix.prototype;
    /**
   * Set the value of this matrix, and return this matrix.
   * @param m11 - column 1, row 1
   * @param m12 - column 1, row 2
   * @param m13 - column 1, row 3
   * @param m14 - column 1, row 4
   * @param m21 - column 2, row 1
   * @param m22 - column 2, row 2
   * @param m23 - column 2, row 3
   * @param m24 - column 2, row 4
   * @param m31 - column 3, row 1
   * @param m32 - column 3, row 2
   * @param m33 - column 3, row 3
   * @param m34 - column 3, row 4
   * @param m41 - column 4, row 1
   * @param m42 - column 4, row 2
   * @param m43 - column 4, row 3
   * @param m44 - column 4, row 4
   * @returns This matrix
   */ _proto.set = function set(m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44) {
        var e = this.elements;
        e[0] = m11;
        e[1] = m12;
        e[2] = m13;
        e[3] = m14;
        e[4] = m21;
        e[5] = m22;
        e[6] = m23;
        e[7] = m24;
        e[8] = m31;
        e[9] = m32;
        e[10] = m33;
        e[11] = m34;
        e[12] = m41;
        e[13] = m42;
        e[14] = m43;
        e[15] = m44;
        return this;
    };
    /**
   * Determines the product of this matrix and the specified matrix.
   * @param right - The specified matrix
   * @returns This matrix that store the product of the two matrices
   */ _proto.multiply = function multiply(right) {
        Matrix.multiply(this, right, this);
        return this;
    };
    /**
   * Calculate a determinant of this matrix.
   * @returns The determinant of this matrix
   */ _proto.determinant = function determinant() {
        var e = this.elements;
        var a11 = e[0], a12 = e[1], a13 = e[2], a14 = e[3];
        var a21 = e[4], a22 = e[5], a23 = e[6], a24 = e[7];
        var a31 = e[8], a32 = e[9], a33 = e[10], a34 = e[11];
        var a41 = e[12], a42 = e[13], a43 = e[14], a44 = e[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        // Calculate the determinant
        return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    };
    /**
   * Decompose this matrix to translation, rotation and scale elements.
   * @param translation - Translation vector as an output parameter
   * @param rotation - Rotation quaternion as an output parameter
   * @param scale - Scale vector as an output parameter
   * @returns True if this matrix can be decomposed, false otherwise
   */ _proto.decompose = function decompose(translation, rotation, scale) {
        var rm = Matrix._tempMat30;
        var e = this.elements;
        var rme = rm.elements;
        var m11 = e[0];
        var m12 = e[1];
        var m13 = e[2];
        var m14 = e[3];
        var m21 = e[4];
        var m22 = e[5];
        var m23 = e[6];
        var m24 = e[7];
        var m31 = e[8];
        var m32 = e[9];
        var m33 = e[10];
        var m34 = e[11];
        translation.set(e[12], e[13], e[14]);
        var xs = Math.sign(m11 * m12 * m13 * m14) < 0 ? -1 : 1;
        var ys = Math.sign(m21 * m22 * m23 * m24) < 0 ? -1 : 1;
        var zs = Math.sign(m31 * m32 * m33 * m34) < 0 ? -1 : 1;
        var sx = xs * Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
        var sy = ys * Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
        var sz = zs * Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
        scale.set(sx, sy, sz);
        if (Math.abs(sx) < MathUtil.zeroTolerance || Math.abs(sy) < MathUtil.zeroTolerance || Math.abs(sz) < MathUtil.zeroTolerance) {
            rotation.identity();
            return false;
        } else {
            var invSX = 1 / sx;
            var invSY = 1 / sy;
            var invSZ = 1 / sz;
            rme[0] = m11 * invSX;
            rme[1] = m12 * invSX;
            rme[2] = m13 * invSX;
            rme[3] = m21 * invSY;
            rme[4] = m22 * invSY;
            rme[5] = m23 * invSY;
            rme[6] = m31 * invSZ;
            rme[7] = m32 * invSZ;
            rme[8] = m33 * invSZ;
            Quaternion.rotationMatrix3x3(rm, rotation);
            return true;
        }
    };
    /**
   * Get rotation from this matrix.
   * @param out - Rotation quaternion as an output parameter
   * @returns The out
   */ _proto.getRotation = function getRotation(out) {
        var e = this.elements;
        var trace = e[0] + e[5] + e[10];
        if (trace > MathUtil.zeroTolerance) {
            var s = Math.sqrt(trace + 1.0) * 2;
            out._w = 0.25 * s;
            out._x = (e[6] - e[9]) / s;
            out._y = (e[8] - e[2]) / s;
            out._z = (e[1] - e[4]) / s;
        } else if (e[0] > e[5] && e[0] > e[10]) {
            var s1 = Math.sqrt(1.0 + e[0] - e[5] - e[10]) * 2;
            out._w = (e[6] - e[9]) / s1;
            out._x = 0.25 * s1;
            out._y = (e[1] + e[4]) / s1;
            out._z = (e[8] + e[2]) / s1;
        } else if (e[5] > e[10]) {
            var s2 = Math.sqrt(1.0 + e[5] - e[0] - e[10]) * 2;
            out._w = (e[8] - e[2]) / s2;
            out._x = (e[1] + e[4]) / s2;
            out._y = 0.25 * s2;
            out._z = (e[6] + e[9]) / s2;
        } else {
            var s3 = Math.sqrt(1.0 + e[10] - e[0] - e[5]) * 2;
            out._w = (e[1] - e[4]) / s3;
            out._x = (e[8] + e[2]) / s3;
            out._y = (e[6] + e[9]) / s3;
            out._z = 0.25 * s3;
        }
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Get scale from this matrix.
   * @param out - Scale vector as an output parameter
   * @returns The out
   */ _proto.getScaling = function getScaling(out) {
        //getScale()
        var e = this.elements;
        var m11 = e[0], m12 = e[1], m13 = e[2];
        var m21 = e[4], m22 = e[5], m23 = e[6];
        var m31 = e[8], m32 = e[9], m33 = e[10];
        out.set(Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13), Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23), Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33));
        return out;
    };
    /**
   * Get translation from this matrix.
   * @param out - Translation vector as an output parameter
   * @returns The out
   */ _proto.getTranslation = function getTranslation(out) {
        var e = this.elements;
        out.set(e[12], e[13], e[14]);
        return out;
    };
    /**
   * Identity this matrix.
   * @returns This matrix after identity
   */ _proto.identity = function identity() {
        var e = this.elements;
        e[0] = 1;
        e[1] = 0;
        e[2] = 0;
        e[3] = 0;
        e[4] = 0;
        e[5] = 1;
        e[6] = 0;
        e[7] = 0;
        e[8] = 0;
        e[9] = 0;
        e[10] = 1;
        e[11] = 0;
        e[12] = 0;
        e[13] = 0;
        e[14] = 0;
        e[15] = 1;
        return this;
    };
    /**
   * Invert the matrix.
   * @returns The matrix after invert
   */ _proto.invert = function invert() {
        Matrix.invert(this, this);
        return this;
    };
    /**
   * This matrix rotates around an arbitrary axis.
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @returns This matrix after rotate
   */ _proto.rotateAxisAngle = function rotateAxisAngle(axis, r) {
        Matrix.rotateAxisAngle(this, axis, r, this);
        return this;
    };
    /**
   * Scale this matrix by a given vector.
   * @param s - The given vector
   * @returns This matrix after scale
   */ _proto.scale = function scale(s) {
        Matrix.scale(this, s, this);
        return this;
    };
    /**
   * Translate this matrix by a given vector.
   * @param v - The given vector
   * @returns This matrix after translate
   */ _proto.translate = function translate(v) {
        Matrix.translate(this, v, this);
        return this;
    };
    /**
   * Calculate the transpose of this matrix.
   * @returns This matrix after transpose
   */ _proto.transpose = function transpose() {
        Matrix.transpose(this, this);
        return this;
    };
    /**
   * Creates a clone of this matrix.
   * @returns A clone of this matrix
   */ _proto.clone = function clone() {
        var e = this.elements;
        var ret = new Matrix(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        return ret;
    };
    /**
   * Copy this matrix from the specified matrix.
   * @param source - The specified matrix
   * @returns This matrix
   */ _proto.copyFrom = function copyFrom(source) {
        var e = this.elements;
        var se = source.elements;
        e[0] = se[0];
        e[1] = se[1];
        e[2] = se[2];
        e[3] = se[3];
        e[4] = se[4];
        e[5] = se[5];
        e[6] = se[6];
        e[7] = se[7];
        e[8] = se[8];
        e[9] = se[9];
        e[10] = se[10];
        e[11] = se[11];
        e[12] = se[12];
        e[13] = se[13];
        e[14] = se[14];
        e[15] = se[15];
        return this;
    };
    /**
   * Copy the value of this matrix from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This matrix
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var srce = this.elements;
        for(var i = 0; i < 16; i++){
            srce[i] = array[i + offset];
        }
        return this;
    };
    /**
   * Copy the value of this matrix to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var e = this.elements;
        out[outOffset] = e[0];
        out[outOffset + 1] = e[1];
        out[outOffset + 2] = e[2];
        out[outOffset + 3] = e[3];
        out[outOffset + 4] = e[4];
        out[outOffset + 5] = e[5];
        out[outOffset + 6] = e[6];
        out[outOffset + 7] = e[7];
        out[outOffset + 8] = e[8];
        out[outOffset + 9] = e[9];
        out[outOffset + 10] = e[10];
        out[outOffset + 11] = e[11];
        out[outOffset + 12] = e[12];
        out[outOffset + 13] = e[13];
        out[outOffset + 14] = e[14];
        out[outOffset + 15] = e[15];
    };
    /**
   * Determines the product of two matrices.
   * @param left - The first matrix to multiply
   * @param right - The second matrix to multiply
   * @param out - The product of the two matrices
   */ Matrix.multiply = function multiply(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        // prettier-ignore
        var l11 = le[0], l12 = le[1], l13 = le[2], l14 = le[3], l21 = le[4], l22 = le[5], l23 = le[6], l24 = le[7], l31 = le[8], l32 = le[9], l33 = le[10], l34 = le[11], l41 = le[12], l42 = le[13], l43 = le[14], l44 = le[15];
        // prettier-ignore
        var r11 = re[0], r12 = re[1], r13 = re[2], r14 = re[3], r21 = re[4], r22 = re[5], r23 = re[6], r24 = re[7], r31 = re[8], r32 = re[9], r33 = re[10], r34 = re[11], r41 = re[12], r42 = re[13], r43 = re[14], r44 = re[15];
        oe[0] = l11 * r11 + l21 * r12 + l31 * r13 + l41 * r14;
        oe[1] = l12 * r11 + l22 * r12 + l32 * r13 + l42 * r14;
        oe[2] = l13 * r11 + l23 * r12 + l33 * r13 + l43 * r14;
        oe[3] = l14 * r11 + l24 * r12 + l34 * r13 + l44 * r14;
        oe[4] = l11 * r21 + l21 * r22 + l31 * r23 + l41 * r24;
        oe[5] = l12 * r21 + l22 * r22 + l32 * r23 + l42 * r24;
        oe[6] = l13 * r21 + l23 * r22 + l33 * r23 + l43 * r24;
        oe[7] = l14 * r21 + l24 * r22 + l34 * r23 + l44 * r24;
        oe[8] = l11 * r31 + l21 * r32 + l31 * r33 + l41 * r34;
        oe[9] = l12 * r31 + l22 * r32 + l32 * r33 + l42 * r34;
        oe[10] = l13 * r31 + l23 * r32 + l33 * r33 + l43 * r34;
        oe[11] = l14 * r31 + l24 * r32 + l34 * r33 + l44 * r34;
        oe[12] = l11 * r41 + l21 * r42 + l31 * r43 + l41 * r44;
        oe[13] = l12 * r41 + l22 * r42 + l32 * r43 + l42 * r44;
        oe[14] = l13 * r41 + l23 * r42 + l33 * r43 + l43 * r44;
        oe[15] = l14 * r41 + l24 * r42 + l34 * r43 + l44 * r44;
    };
    /**
   * Determines whether the specified matrices are equals.
   * @param left - The first matrix to compare
   * @param right - The second matrix to compare
   * @returns True if the specified matrices are equals, false otherwise
   */ Matrix.equals = function equals(left, right) {
        var le = left.elements;
        var re = right.elements;
        return MathUtil.equals(le[0], re[0]) && MathUtil.equals(le[1], re[1]) && MathUtil.equals(le[2], re[2]) && MathUtil.equals(le[3], re[3]) && MathUtil.equals(le[4], re[4]) && MathUtil.equals(le[5], re[5]) && MathUtil.equals(le[6], re[6]) && MathUtil.equals(le[7], re[7]) && MathUtil.equals(le[8], re[8]) && MathUtil.equals(le[9], re[9]) && MathUtil.equals(le[10], re[10]) && MathUtil.equals(le[11], re[11]) && MathUtil.equals(le[12], re[12]) && MathUtil.equals(le[13], re[13]) && MathUtil.equals(le[14], re[14]) && MathUtil.equals(le[15], re[15]);
    };
    /**
   * Performs a linear interpolation between two matrices.
   * @param start - The first matrix
   * @param end - The second matrix
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two matrices
   */ Matrix.lerp = function lerp(start, end, t, out) {
        var se = start.elements;
        var ee = end.elements;
        var oe = out.elements;
        var inv = 1.0 - t;
        oe[0] = se[0] * inv + ee[0] * t;
        oe[1] = se[1] * inv + ee[1] * t;
        oe[2] = se[2] * inv + ee[2] * t;
        oe[3] = se[3] * inv + ee[3] * t;
        oe[4] = se[4] * inv + ee[4] * t;
        oe[5] = se[5] * inv + ee[5] * t;
        oe[6] = se[6] * inv + ee[6] * t;
        oe[7] = se[7] * inv + ee[7] * t;
        oe[8] = se[8] * inv + ee[8] * t;
        oe[9] = se[9] * inv + ee[9] * t;
        oe[10] = se[10] * inv + ee[10] * t;
        oe[11] = se[11] * inv + ee[11] * t;
        oe[12] = se[12] * inv + ee[12] * t;
        oe[13] = se[13] * inv + ee[13] * t;
        oe[14] = se[14] * inv + ee[14] * t;
        oe[15] = se[15] * inv + ee[15] * t;
    };
    /**
   * Determines the sum of two matrices.
   * @param left - The first matrix to add
   * @param right - The second matrix to add
   * @param out - The sum of two matrices
   */ Matrix.add = function add(left, right, out) {
        var le = left.elements;
        var re = right.elements;
        var oe = out.elements;
        oe[0] = le[0] + re[0];
        oe[1] = le[1] + re[1];
        oe[2] = le[2] + re[2];
        oe[3] = le[3] + re[3];
        oe[4] = le[4] + re[4];
        oe[5] = le[5] + re[5];
        oe[6] = le[6] + re[6];
        oe[7] = le[7] + re[7];
        oe[8] = le[8] + re[8];
        oe[9] = le[9] + re[9];
        oe[10] = le[10] + re[10];
        oe[11] = le[11] + re[11];
        oe[12] = le[12] + re[12];
        oe[13] = le[13] + re[13];
        oe[14] = le[14] + re[14];
        oe[15] = le[15] + re[15];
    };
    /**
   * Multiplies a matrix by a scalar.
   * @param source - The matrix to multiply
   * @param scalar - The scalar to multiply
   * @param out - The result of multiplying a matrix by a scalar
   */ Matrix.multiplyScalar = function multiplyScalar(source, scalar, out) {
        var se = source.elements;
        var oe = out.elements;
        oe[0] = se[0] * scalar;
        oe[1] = se[1] * scalar;
        oe[2] = se[2] * scalar;
        oe[3] = se[3] * scalar;
        oe[4] = se[4] * scalar;
        oe[5] = se[5] * scalar;
        oe[6] = se[6] * scalar;
        oe[7] = se[7] * scalar;
        oe[8] = se[8] * scalar;
        oe[9] = se[9] * scalar;
        oe[10] = se[10] * scalar;
        oe[11] = se[11] * scalar;
        oe[12] = se[12] * scalar;
        oe[13] = se[13] * scalar;
        oe[14] = se[14] * scalar;
        oe[15] = se[15] * scalar;
    };
    /**
   * Calculate a rotation matrix from a quaternion.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param out - The calculated rotation matrix
   */ Matrix.rotationQuaternion = function rotationQuaternion(quaternion, out) {
        var oe = out.elements;
        var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var yx = y * x2;
        var yy = y * y2;
        var zx = z * x2;
        var zy = z * y2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        oe[0] = 1 - yy - zz;
        oe[1] = yx + wz;
        oe[2] = zx - wy;
        oe[3] = 0;
        oe[4] = yx - wz;
        oe[5] = 1 - xx - zz;
        oe[6] = zy + wx;
        oe[7] = 0;
        oe[8] = zx + wy;
        oe[9] = zy - wx;
        oe[10] = 1 - xx - yy;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix rotates around an arbitrary axis.
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @param out - The matrix after rotate
   */ Matrix.rotationAxisAngle = function rotationAxisAngle(axis, r, out) {
        var oe = out.elements;
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        var s, c, t;
        if (Math.abs(len) < MathUtil.zeroTolerance) {
            return;
        }
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        // Perform rotation-specific matrix multiplication
        oe[0] = x * x * t + c;
        oe[1] = y * x * t + z * s;
        oe[2] = z * x * t - y * s;
        oe[3] = 0;
        oe[4] = x * y * t - z * s;
        oe[5] = y * y * t + c;
        oe[6] = z * y * t + x * s;
        oe[7] = 0;
        oe[8] = x * z * t + y * s;
        oe[9] = y * z * t - x * s;
        oe[10] = z * z * t + c;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from a quaternion and a translation.
   * @param quaternion - The quaternion used to calculate the matrix
   * @param translation - The translation used to calculate the matrix
   * @param out - The calculated matrix
   */ Matrix.rotationTranslation = function rotationTranslation(quaternion, translation, out) {
        Matrix.rotationQuaternion(quaternion, out);
        var oe = out.elements;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
    };
    /**
   * Calculate an affine matrix.
   * @param scale - The scale used to calculate matrix
   * @param rotation - The rotation used to calculate matrix
   * @param translation - The translation used to calculate matrix
   * @param out - The calculated matrix
   */ Matrix.affineTransformation = function affineTransformation(scale, rotation, translation, out) {
        var oe = out.elements;
        var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
        var x2 = x + x;
        var y2 = y + y;
        var z2 = z + z;
        var xx = x * x2;
        var xy = x * y2;
        var xz = x * z2;
        var yy = y * y2;
        var yz = y * z2;
        var zz = z * z2;
        var wx = w * x2;
        var wy = w * y2;
        var wz = w * z2;
        var sx = scale._x;
        var sy = scale._y;
        var sz = scale._z;
        oe[0] = (1 - (yy + zz)) * sx;
        oe[1] = (xy + wz) * sx;
        oe[2] = (xz - wy) * sx;
        oe[3] = 0;
        oe[4] = (xy - wz) * sy;
        oe[5] = (1 - (xx + zz)) * sy;
        oe[6] = (yz + wx) * sy;
        oe[7] = 0;
        oe[8] = (xz + wy) * sz;
        oe[9] = (yz - wx) * sz;
        oe[10] = (1 - (xx + yy)) * sz;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from scale vector.
   * @param s - The scale vector
   * @param out - The calculated matrix
   */ Matrix.scaling = function scaling(s, out) {
        var oe = out.elements;
        oe[0] = s._x;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = s._y;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = s._z;
        oe[11] = 0;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 0;
        oe[15] = 1;
    };
    /**
   * Calculate a matrix from translation vector.
   * @param translation - The translation vector
   * @param out - The calculated matrix
   */ Matrix.translation = function translation(translation, out) {
        var oe = out.elements;
        oe[0] = 1;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = 1;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 1;
        oe[11] = 0;
        oe[12] = translation._x;
        oe[13] = translation._y;
        oe[14] = translation._z;
        oe[15] = 1;
    };
    /**
   * Calculate the inverse of the specified matrix.
   * @param a - The matrix whose inverse is to be calculated
   * @param out - The inverse of the specified matrix
   */ Matrix.invert = function invert(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        var a11 = ae[0], a12 = ae[1], a13 = ae[2], a14 = ae[3];
        var a21 = ae[4], a22 = ae[5], a23 = ae[6], a24 = ae[7];
        var a31 = ae[8], a32 = ae[9], a33 = ae[10], a34 = ae[11];
        var a41 = ae[12], a42 = ae[13], a43 = ae[14], a44 = ae[15];
        var b00 = a11 * a22 - a12 * a21;
        var b01 = a11 * a23 - a13 * a21;
        var b02 = a11 * a24 - a14 * a21;
        var b03 = a12 * a23 - a13 * a22;
        var b04 = a12 * a24 - a14 * a22;
        var b05 = a13 * a24 - a14 * a23;
        var b06 = a31 * a42 - a32 * a41;
        var b07 = a31 * a43 - a33 * a41;
        var b08 = a31 * a44 - a34 * a41;
        var b09 = a32 * a43 - a33 * a42;
        var b10 = a32 * a44 - a34 * a42;
        var b11 = a33 * a44 - a34 * a43;
        var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        if (!det) {
            return null;
        }
        det = 1.0 / det;
        oe[0] = (a22 * b11 - a23 * b10 + a24 * b09) * det;
        oe[1] = (a13 * b10 - a12 * b11 - a14 * b09) * det;
        oe[2] = (a42 * b05 - a43 * b04 + a44 * b03) * det;
        oe[3] = (a33 * b04 - a32 * b05 - a34 * b03) * det;
        oe[4] = (a23 * b08 - a21 * b11 - a24 * b07) * det;
        oe[5] = (a11 * b11 - a13 * b08 + a14 * b07) * det;
        oe[6] = (a43 * b02 - a41 * b05 - a44 * b01) * det;
        oe[7] = (a31 * b05 - a33 * b02 + a34 * b01) * det;
        oe[8] = (a21 * b10 - a22 * b08 + a24 * b06) * det;
        oe[9] = (a12 * b08 - a11 * b10 - a14 * b06) * det;
        oe[10] = (a41 * b04 - a42 * b02 + a44 * b00) * det;
        oe[11] = (a32 * b02 - a31 * b04 - a34 * b00) * det;
        oe[12] = (a22 * b07 - a21 * b09 - a23 * b06) * det;
        oe[13] = (a11 * b09 - a12 * b07 + a13 * b06) * det;
        oe[14] = (a42 * b01 - a41 * b03 - a43 * b00) * det;
        oe[15] = (a31 * b03 - a32 * b01 + a33 * b00) * det;
    };
    /**
   * Calculate a right-handed look-at matrix.
   * @param eye - The position of the viewer's eye
   * @param target - The camera look-at target
   * @param up - The camera's up vector
   * @param out - The calculated look-at matrix
   */ Matrix.lookAt = function lookAt(eye, target, up, out) {
        var oe = out.elements;
        var xAxis = Matrix._tempVec30;
        var yAxis = Matrix._tempVec31;
        var zAxis = Matrix._tempVec32;
        Vector3.subtract(eye, target, zAxis);
        zAxis.normalize();
        Vector3.cross(up, zAxis, xAxis);
        xAxis.normalize();
        Vector3.cross(zAxis, xAxis, yAxis);
        oe[0] = xAxis._x;
        oe[1] = yAxis._x;
        oe[2] = zAxis._x;
        oe[3] = 0;
        oe[4] = xAxis._y;
        oe[5] = yAxis._y;
        oe[6] = zAxis._y;
        oe[7] = 0;
        oe[8] = xAxis._z;
        oe[9] = yAxis._z;
        oe[10] = zAxis._z;
        oe[11] = 0;
        oe[12] = -Vector3.dot(xAxis, eye);
        oe[13] = -Vector3.dot(yAxis, eye);
        oe[14] = -Vector3.dot(zAxis, eye);
        oe[15] = 1;
    };
    /**
   * Calculate an orthographic projection matrix.
   * @param left - The left edge of the viewing
   * @param right - The right edge of the viewing
   * @param bottom - The bottom edge of the viewing
   * @param top - The top edge of the viewing
   * @param near - The depth of the near plane
   * @param far - The depth of the far plane
   * @param out - The calculated orthographic projection matrix
   */ Matrix.ortho = function ortho(left, right, bottom, top, near, far, out) {
        var oe = out.elements;
        var lr = 1 / (left - right);
        var bt = 1 / (bottom - top);
        var nf = 1 / (near - far);
        oe[0] = -2 * lr;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = -2 * bt;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = 2 * nf;
        oe[11] = 0;
        oe[12] = (left + right) * lr;
        oe[13] = (top + bottom) * bt;
        oe[14] = (far + near) * nf;
        oe[15] = 1;
    };
    /**
   * Calculate a perspective projection matrix.
   * @param fovY - Field of view in the y direction, in radians
   * @param aspect - Aspect ratio, defined as view space width divided by height
   * @param near - The depth of the near plane
   * @param far - The depth of the far plane
   * @param out - The calculated perspective projection matrix
   */ Matrix.perspective = function perspective(fovY, aspect, near, far, out) {
        var oe = out.elements;
        var f = 1.0 / Math.tan(fovY / 2);
        var nf = 1 / (near - far);
        oe[0] = f / aspect;
        oe[1] = 0;
        oe[2] = 0;
        oe[3] = 0;
        oe[4] = 0;
        oe[5] = f;
        oe[6] = 0;
        oe[7] = 0;
        oe[8] = 0;
        oe[9] = 0;
        oe[10] = (far + near) * nf;
        oe[11] = -1;
        oe[12] = 0;
        oe[13] = 0;
        oe[14] = 2 * far * near * nf;
        oe[15] = 0;
    };
    /**
   * The specified matrix rotates around an arbitrary axis.
   * @param m - The specified matrix
   * @param axis - The axis
   * @param r - The rotation angle in radians
   * @param out - The rotated matrix
   */ Matrix.rotateAxisAngle = function rotateAxisAngle(m, axis, r, out) {
        var x = axis._x, y = axis._y, z = axis._z;
        var len = Math.sqrt(x * x + y * y + z * z);
        if (Math.abs(len) < MathUtil.zeroTolerance) {
            return;
        }
        var me = m.elements;
        var oe = out.elements;
        var s, c, t;
        len = 1 / len;
        x *= len;
        y *= len;
        z *= len;
        s = Math.sin(r);
        c = Math.cos(r);
        t = 1 - c;
        var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
        var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
        var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
        // Construct the elements of the rotation matrix
        var b11 = x * x * t + c;
        var b12 = y * x * t + z * s;
        var b13 = z * x * t - y * s;
        var b21 = x * y * t - z * s;
        var b22 = y * y * t + c;
        var b23 = z * y * t + x * s;
        var b31 = x * z * t + y * s;
        var b32 = y * z * t - x * s;
        var b33 = z * z * t + c;
        // Perform rotation-specific matrix multiplication
        oe[0] = a11 * b11 + a21 * b12 + a31 * b13;
        oe[1] = a12 * b11 + a22 * b12 + a32 * b13;
        oe[2] = a13 * b11 + a23 * b12 + a33 * b13;
        oe[3] = a14 * b11 + a24 * b12 + a34 * b13;
        oe[4] = a11 * b21 + a21 * b22 + a31 * b23;
        oe[5] = a12 * b21 + a22 * b22 + a32 * b23;
        oe[6] = a13 * b21 + a23 * b22 + a33 * b23;
        oe[7] = a14 * b21 + a24 * b22 + a34 * b23;
        oe[8] = a11 * b31 + a21 * b32 + a31 * b33;
        oe[9] = a12 * b31 + a22 * b32 + a32 * b33;
        oe[10] = a13 * b31 + a23 * b32 + a33 * b33;
        oe[11] = a14 * b31 + a24 * b32 + a34 * b33;
        if (m !== out) {
            // If the source and destination differ, copy the unchanged last row
            oe[12] = me[12];
            oe[13] = me[13];
            oe[14] = me[14];
            oe[15] = me[15];
        }
    };
    /**
   * Scale a matrix by a given vector.
   * @param m - The matrix
   * @param s - The given vector
   * @param out - The scaled matrix
   */ Matrix.scale = function scale(m, s, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = s._x, y = s._y, z = s._z;
        oe[0] = me[0] * x;
        oe[1] = me[1] * x;
        oe[2] = me[2] * x;
        oe[3] = me[3] * x;
        oe[4] = me[4] * y;
        oe[5] = me[5] * y;
        oe[6] = me[6] * y;
        oe[7] = me[7] * y;
        oe[8] = me[8] * z;
        oe[9] = me[9] * z;
        oe[10] = me[10] * z;
        oe[11] = me[11] * z;
        oe[12] = me[12];
        oe[13] = me[13];
        oe[14] = me[14];
        oe[15] = me[15];
    };
    /**
   * Translate a matrix by a given vector.
   * @param m - The matrix
   * @param v - The given vector
   * @param out - The translated matrix
   */ Matrix.translate = function translate(m, v, out) {
        var me = m.elements;
        var oe = out.elements;
        var x = v._x, y = v._y, z = v._z;
        if (m === out) {
            oe[12] = me[0] * x + me[4] * y + me[8] * z + me[12];
            oe[13] = me[1] * x + me[5] * y + me[9] * z + me[13];
            oe[14] = me[2] * x + me[6] * y + me[10] * z + me[14];
            oe[15] = me[3] * x + me[7] * y + me[11] * z + me[15];
        } else {
            var a11 = me[0], a12 = me[1], a13 = me[2], a14 = me[3];
            var a21 = me[4], a22 = me[5], a23 = me[6], a24 = me[7];
            var a31 = me[8], a32 = me[9], a33 = me[10], a34 = me[11];
            oe[0] = a11, oe[1] = a12, oe[2] = a13, oe[3] = a14;
            oe[4] = a21, oe[5] = a22, oe[6] = a23, oe[7] = a24;
            oe[8] = a31, oe[9] = a32, oe[10] = a33, oe[11] = a34;
            oe[12] = a11 * x + a21 * y + a31 * z + me[12];
            oe[13] = a12 * x + a22 * y + a32 * z + me[13];
            oe[14] = a13 * x + a23 * y + a33 * z + me[14];
            oe[15] = a14 * x + a24 * y + a34 * z + me[15];
        }
    };
    /**
   * Calculate the transpose of the specified matrix.
   * @param a - The specified matrix
   * @param out - The transpose of the specified matrix
   */ Matrix.transpose = function transpose(a, out) {
        var ae = a.elements;
        var oe = out.elements;
        if (out === a) {
            var a12 = ae[1];
            var a13 = ae[2];
            var a14 = ae[3];
            var a23 = ae[6];
            var a24 = ae[7];
            var a34 = ae[11];
            oe[1] = ae[4];
            oe[2] = ae[8];
            oe[3] = ae[12];
            oe[4] = a12;
            oe[6] = ae[9];
            oe[7] = ae[13];
            oe[8] = a13;
            oe[9] = a23;
            oe[11] = ae[14];
            oe[12] = a14;
            oe[13] = a24;
            oe[14] = a34;
        } else {
            oe[0] = ae[0];
            oe[1] = ae[4];
            oe[2] = ae[8];
            oe[3] = ae[12];
            oe[4] = ae[1];
            oe[5] = ae[5];
            oe[6] = ae[9];
            oe[7] = ae[13];
            oe[8] = ae[2];
            oe[9] = ae[6];
            oe[10] = ae[10];
            oe[11] = ae[14];
            oe[12] = ae[3];
            oe[13] = ae[7];
            oe[14] = ae[11];
            oe[15] = ae[15];
        }
    };
    return Matrix;
}();
(function() {
    Matrix._tempVec30 = new Vector3();
})();
(function() {
    Matrix._tempVec31 = new Vector3();
})();
(function() {
    Matrix._tempVec32 = new Vector3();
})();
(function() {
    Matrix._tempMat30 = new Matrix3x3();
})();
(function() {
    /** @internal Identity matrix. */ Matrix._identity = new Matrix(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);
})();

/**
 * Represents a ray with an origin and a direction in 3D space.
 */ var Ray = /*#__PURE__*/ function() {
    function Ray(origin, direction) {
        if (origin === void 0) origin = null;
        if (direction === void 0) direction = null;
        /** The origin of the ray. */ this.origin = new Vector3();
        /** The normalized direction of the ray. */ this.direction = new Vector3();
        origin && this.origin.copyFrom(origin);
        direction && this.direction.copyFrom(direction);
    }
    var _proto = Ray.prototype;
    /**
   * Check if this ray intersects the specified plane.
   * @param plane - The specified plane
   * @returns The distance from this ray to the specified plane if intersecting, -1 otherwise
   */ _proto.intersectPlane = function intersectPlane(plane) {
        return CollisionUtil.intersectsRayAndPlane(this, plane);
    };
    /**
   * Check if this ray intersects the specified sphere.
   * @param sphere - The specified sphere
   * @returns The distance from this ray to the specified sphere if intersecting, -1 otherwise
   */ _proto.intersectSphere = function intersectSphere(sphere) {
        return CollisionUtil.intersectsRayAndSphere(this, sphere);
    };
    /**
   * Check if this ray intersects the specified box (AABB).
   * @param box - The specified box
   * @returns The distance from this ray to the specified box if intersecting, -1 otherwise
   */ _proto.intersectBox = function intersectBox(box) {
        return CollisionUtil.intersectsRayAndBox(this, box);
    };
    /**
   * The coordinates of the specified distance from the origin in the ray direction.
   * @param distance - The specified distance
   * @param out - The coordinates as an output parameter
   * @returns The out
   */ _proto.getPoint = function getPoint(distance, out) {
        Vector3.scale(this.direction, distance, out);
        return out.add(this.origin);
    };
    return Ray;
}();

/**
 * Describes a 2D-vector.
 */ var Vector2 = /*#__PURE__*/ function() {
    function Vector2(x, y) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
    }
    var _proto = Vector2.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y) {
        this._x = x;
        this._y = y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y;
        return Math.sqrt(_x * _x + _y * _y);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y;
        return _x * _x + _y * _y;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector2.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        return new Vector2(this._x, this._y);
    };
    /**
   * Copy from vector2 like object.
   * @param source - Vector2 like object
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector2.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector2.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector2.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector2.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector2.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y;
    };
    /**
   * Determines the distance of two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @returns The distance of two vectors
   */ Vector2.distance = function distance(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return Math.sqrt(x * x + y * y);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @returns The squared distance of two vectors
   */ Vector2.distanceSquared = function distanceSquared(left, right) {
        var x = right._x - left._x;
        var y = right._y - left._y;
        return x * x + y * y;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector2.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param t - The blend amount where 0 returns left and 1 right
   * @param out - The result of linear blending between two vectors
   */ Vector2.lerp = function lerp(left, right, t, out) {
        var _x = left._x, _y = left._y;
        out._x = _x + (right._x - _x) * t;
        out._y = _y + (right._y - _y) * t;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector2.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector2.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Reverses the direction of a given vector.
   * @param left - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector2.negate = function negate(left, out) {
        out._x = -left._x;
        out._y = -left._y;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Converts the vector into a unit vector.
   * @param left - The vector to normalize
   * @param out - The normalized vector
   */ Vector2.normalize = function normalize(left, out) {
        var _x = left._x, _y = left._y;
        var len = Math.sqrt(_x * _x + _y * _y);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Scale a vector by the given value.
   * @param left - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector2.scale = function scale(left, s, out) {
        out._x = left._x * s;
        out._y = left._y * s;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class(Vector2, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Vector2;
}();
(function() {
    /** @internal */ Vector2._zero = new Vector2(0.0, 0.0);
})();
(function() {
    /** @internal */ Vector2._one = new Vector2(1.0, 1.0);
})();

/**
 * Describes a 4D-vector.
 */ var Vector4 = /*#__PURE__*/ function() {
    function Vector4(x, y, z, w) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (z === void 0) z = 0;
        if (w === void 0) w = 0;
        /** @internal */ this._onValueChanged = null;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
    }
    var _proto = Vector4.prototype;
    /**
   * Set the value of this vector.
   * @param x - The x component of the vector
   * @param y - The y component of the vector
   * @param z - The z component of the vector
   * @param w - The w component of the vector
   * @returns This vector
   */ _proto.set = function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this vector and the specified vector.
   * @param right - The specified vector
   * @returns This vector
   */ _proto.add = function add(right) {
        this._x += right._x;
        this._y += right._y;
        this._z += right._z;
        this._w += right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the difference of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.subtract = function subtract(right) {
        this._x -= right._x;
        this._y -= right._y;
        this._z -= right._z;
        this._w -= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the product of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.multiply = function multiply(right) {
        this._x *= right._x;
        this._y *= right._y;
        this._z *= right._z;
        this._w *= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the divisor of this vector and the specified vector.
   * @param right - the specified vector
   * @returns This vector
   */ _proto.divide = function divide(right) {
        this._x /= right._x;
        this._y /= right._y;
        this._z /= right._z;
        this._w /= right._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Calculate the length of this vector.
   * @returns The length of this vector
   */ _proto.length = function length() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
    };
    /**
   * Calculate the squared length of this vector.
   * @returns The squared length of this vector
   */ _proto.lengthSquared = function lengthSquared() {
        var _this = this, _x = _this._x, _y = _this._y, _z = _this._z, _w = _this._w;
        return _x * _x + _y * _y + _z * _z + _w * _w;
    };
    /**
   * Reverses the direction of this vector.
   * @returns This vector
   */ _proto.negate = function negate() {
        this._x = -this._x;
        this._y = -this._y;
        this._z = -this._z;
        this._w = -this._w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Converts this vector into a unit vector.
   * @returns This vector
   */ _proto.normalize = function normalize() {
        Vector4.normalize(this, this);
        return this;
    };
    /**
   * Scale this vector by the given value.
   * @param s - The amount by which to scale the vector
   * @returns This vector
   */ _proto.scale = function scale(s) {
        this._x *= s;
        this._y *= s;
        this._z *= s;
        this._w *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this vector.
   * @returns A clone of this vector
   */ _proto.clone = function clone() {
        var ret = new Vector4(this._x, this._y, this._z, this._w);
        return ret;
    };
    /**
   * Copy from vector3 like object.
   * @param source - Vector3 like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._x = source.x;
        this._y = source.y;
        this._z = source.z;
        this._w = source.w;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector by an array.
   * @param array - The array
   * @param offset - The start offset of the array
   * @returns This vector
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Copy the value of this vector to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        out[outOffset] = this._x;
        out[outOffset + 1] = this._y;
        out[outOffset + 2] = this._z;
        out[outOffset + 3] = this._w;
    };
    /**
   * Serialize this vector to a JSON representation.
   * @returns A JSON representation of this vector
   */ _proto.toJSON = function toJSON() {
        return {
            x: this._x,
            y: this._y,
            z: this._z,
            w: this._w
        };
    };
    /**
   * Determines the sum of two vectors.
   * @param left - The first vector to add
   * @param right - The second vector to add
   * @param out - The sum of two vectors
   */ Vector4.add = function add(left, right, out) {
        out._x = left._x + right._x;
        out._y = left._y + right._y;
        out._z = left._z + right._z;
        out._w = left._w + right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the difference between two vectors.
   * @param left - The first vector to subtract
   * @param right - The second vector to subtract
   * @param out - The difference between two vectors
   */ Vector4.subtract = function subtract(left, right, out) {
        out._x = left._x - right._x;
        out._y = left._y - right._y;
        out._z = left._z - right._z;
        out._w = left._w - right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the product of two vectors.
   * @param left - The first vector to multiply
   * @param right - The second vector to multiply
   * @param out - The product of two vectors
   */ Vector4.multiply = function multiply(left, right, out) {
        out._x = left._x * right._x;
        out._y = left._y * right._y;
        out._z = left._z * right._z;
        out._w = left._w * right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the divisor of two vectors.
   * @param left - The first vector to divide
   * @param right - The second vector to divide
   * @param out - The divisor of two vectors
   */ Vector4.divide = function divide(left, right, out) {
        out._x = left._x / right._x;
        out._y = left._y / right._y;
        out._z = left._z / right._z;
        out._w = left._w / right._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Determines the dot product of two vectors.
   * @param left - The first vector to dot
   * @param right - The second vector to dot
   * @returns The dot product of two vectors
   */ Vector4.dot = function dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    };
    /**
   * Determines the distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The distance of two vectors
   */ Vector4.distance = function distance(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };
    /**
   * Determines the squared distance of two vectors.
   * @param a - The first vector
   * @param b - The second vector
   * @returns The squared distance of two vectors
   */ Vector4.distanceSquared = function distanceSquared(a, b) {
        var x = b._x - a._x;
        var y = b._y - a._y;
        var z = b._z - a._z;
        var w = b._w - a._w;
        return x * x + y * y + z * z + w * w;
    };
    /**
   * Determines whether the specified vectors are equals.
   * @param left - The first vector to compare
   * @param right - The second vector to compare
   * @returns True if the specified vectors are equals, false otherwise
   */ Vector4.equals = function equals(left, right) {
        return MathUtil.equals(left._x, right._x) && MathUtil.equals(left._y, right._y) && MathUtil.equals(left._z, right._z) && MathUtil.equals(left._w, right._w);
    };
    /**
   * Performs a linear interpolation between two vectors.
   * @param start - The first vector
   * @param end - The second vector
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two vectors
   */ Vector4.lerp = function lerp(start, end, t, out) {
        var _x = start._x, _y = start._y, _z = start._z, _w = start._w;
        out._x = _x + (end._x - _x) * t;
        out._y = _y + (end._y - _y) * t;
        out._z = _z + (end._z - _z) * t;
        out._w = _w + (end._w - _w) * t;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the largest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the largest components of the specified vectors
   */ Vector4.max = function max(left, right, out) {
        out._x = Math.max(left._x, right._x);
        out._y = Math.max(left._y, right._y);
        out._z = Math.max(left._z, right._z);
        out._w = Math.max(left._w, right._w);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Calculate a vector containing the smallest components of the specified vectors.
   * @param left - The first vector
   * @param right - The second vector
   * @param out - The vector containing the smallest components of the specified vectors
   */ Vector4.min = function min(left, right, out) {
        out._x = Math.min(left._x, right._x);
        out._y = Math.min(left._y, right._y);
        out._z = Math.min(left._z, right._z);
        out._w = Math.min(left._w, right._w);
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Reverses the direction of a given vector.
   * @param a - The vector to negate
   * @param out - The vector facing in the opposite direction
   */ Vector4.negate = function negate(a, out) {
        out._x = -a._x;
        out._y = -a._y;
        out._z = -a._z;
        out._w = -a._w;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Converts the vector into a unit vector.
   * @param a - The vector to normalize
   * @param out - The normalized vector
   */ Vector4.normalize = function normalize(a, out) {
        var _x = a._x, _y = a._y, _z = a._z, _w = a._w;
        var len = Math.sqrt(_x * _x + _y * _y + _z * _z + _w * _w);
        if (len > MathUtil.zeroTolerance) {
            len = 1 / len;
            out._x = _x * len;
            out._y = _y * len;
            out._z = _z * len;
            out._w = _w * len;
            out._onValueChanged && out._onValueChanged();
        }
    };
    /**
   * Scale a vector by the given value.
   * @param a - The vector to scale
   * @param s - The amount by which to scale the vector
   * @param out - The scaled vector
   */ Vector4.scale = function scale(a, s, out) {
        out._x = a._x * s;
        out._y = a._y * s;
        out._z = a._z * s;
        out._w = a._w * s;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given 4x4 matrix.
   * @param v - The vector to transform
   * @param m - The transform matrix
   * @param out - The transformed vector3
   */ Vector4.transform = function transform(v, m, out) {
        var _x = v._x, _y = v._y, _z = v._z, _w = v._w;
        var e = m.elements;
        out._x = _x * e[0] + _y * e[4] + _z * e[8] + _w * e[12];
        out._y = _x * e[1] + _y * e[5] + _z * e[9] + _w * e[13];
        out._z = _x * e[2] + _y * e[6] + _z * e[10] + _w * e[14];
        out._w = _x * e[3] + _y * e[7] + _z * e[11] + _w * e[15];
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Performs a transformation using the given quaternion.
   * @param v - The vector to transform
   * @param q - The transform quaternion
   * @param out - The transformed vector
   */ Vector4.transformByQuat = function transformByQuat(v, q, out) {
        var x = v._x, y = v._y, z = v._z, w = v._w;
        var qx = q._x;
        var qy = q._y;
        var qz = q._z;
        var qw = q._w;
        // calculate quat * vec
        var ix = qw * x + qy * z - qz * y;
        var iy = qw * y + qz * x - qx * z;
        var iz = qw * z + qx * y - qy * x;
        var iw = -qx * x - qy * y - qz * z;
        // calculate result * inverse quat
        out._x = ix * qw - iw * qx - iy * qz + iz * qy;
        out._y = iy * qw - iw * qy - iz * qx + ix * qz;
        out._z = iz * qw - iw * qz - ix * qy + iy * qx;
        out._w = w;
        out._onValueChanged && out._onValueChanged();
    };
    _create_class(Vector4, [
        {
            key: "x",
            get: /**
   * The x component of the vector.
   */ function get() {
                return this._x;
            },
            set: function set(value) {
                this._x = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "y",
            get: /**
   * The y component of the vector.
   */ function get() {
                return this._y;
            },
            set: function set(value) {
                this._y = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "z",
            get: /**
   * The z component of the vector.
   */ function get() {
                return this._z;
            },
            set: function set(value) {
                this._z = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "w",
            get: /**
   * The w component of the vector.
   */ function get() {
                return this._w;
            },
            set: function set(value) {
                this._w = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Vector4;
}();
(function() {
    /** @internal */ Vector4._zero = new Vector4(0.0, 0.0, 0.0, 0.0);
})();
(function() {
    /** @internal */ Vector4._one = new Vector4(1.0, 1.0, 1.0, 1.0);
})();

/**
 * Describes a color in the from of RGBA (in order: R, G, B, A).
 */ var Color = /*#__PURE__*/ function() {
    function Color(r, g, b, a) {
        if (r === void 0) r = 1;
        if (g === void 0) g = 1;
        if (b === void 0) b = 1;
        if (a === void 0) a = 1;
        /** @internal */ this._onValueChanged = null;
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
    }
    var _proto = Color.prototype;
    /**
   * Set the value of this color.
   * @param r - The red component of the color
   * @param g - The green component of the color
   * @param b - The blue component of the color
   * @param a - The alpha component of the color
   * @returns This color.
   */ _proto.set = function set(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Determines the sum of this color and the specified color.
   * @param color - The specified color
   * @returns The added color
   */ _proto.add = function add(color) {
        this._r += color._r;
        this._g += color._g;
        this._b += color._b;
        this._a += color._a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Scale this color by the given value.
   * @param s - The amount by which to scale the color
   * @returns The scaled color
   */ _proto.scale = function scale(s) {
        this._r *= s;
        this._g *= s;
        this._b *= s;
        this._a *= s;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Creates a clone of this color.
   * @returns A clone of this color
   */ _proto.clone = function clone() {
        var ret = new Color(this._r, this._g, this._b, this._a);
        return ret;
    };
    /**
   * Copy from color like object.
   * @param source - Color like object.
   * @returns This vector
   */ _proto.copyFrom = function copyFrom(source) {
        this._r = source.r;
        this._g = source.g;
        this._b = source.b;
        this._a = source.a;
        this._onValueChanged && this._onValueChanged();
        return this;
    };
    /**
   * Modify components (r, g, b) of this color from gamma space to linear space.
   * @param out - The color in linear space
   * @returns The color in linear space
   */ _proto.toLinear = function toLinear(out) {
        out._r = Color.gammaToLinearSpace(this._r);
        out._g = Color.gammaToLinearSpace(this._g);
        out._b = Color.gammaToLinearSpace(this._b);
        this._onValueChanged && this._onValueChanged();
        return out;
    };
    /**
   * Modify components (r, g, b) of this color from linear space to gamma space.
   * @param out - The color in gamma space
   * @returns The color in gamma space
   */ _proto.toGamma = function toGamma(out) {
        out._r = Color.linearToGammaSpace(this._r);
        out._g = Color.linearToGammaSpace(this._g);
        out._b = Color.linearToGammaSpace(this._b);
        this._onValueChanged && this._onValueChanged();
        return out;
    };
    /**
   * Gets the brightness.
   * @returns The Hue-Saturation-Brightness (HSB) saturation for this
   */ _proto.getBrightness = function getBrightness() {
        var r = this.r;
        var g = this.g;
        var b = this.b;
        var max = r;
        var min = r;
        if (g > max) max = g;
        if (b > max) max = b;
        if (g < min) min = g;
        if (b < min) min = b;
        return (max + min) / 2;
    };
    /**
   * Serialize this color to a JSON representation.
   * @return A JSON representation of this color
   */ _proto.toJSON = function toJSON() {
        return {
            r: this._r,
            g: this._g,
            b: this._b,
            a: this._a
        };
    };
    /**
   * Modify a value from the gamma space to the linear space.
   * @param value - The value in gamma space
   * @returns The value in linear space
   */ Color.gammaToLinearSpace = function gammaToLinearSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value <= 0.04045) return value / 12.92;
        else if (value < 1.0) return Math.pow((value + 0.055) / 1.055, 2.4);
        else return Math.pow(value, 2.4);
    };
    /**
   * Modify a value from the linear space to the gamma space.
   * @param value - The value in linear space
   * @returns The value in gamma space
   */ Color.linearToGammaSpace = function linearToGammaSpace(value) {
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_sRGB.txt
        // https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_texture_sRGB_decode.txt
        if (value <= 0.0) return 0.0;
        else if (value < 0.0031308) return 12.92 * value;
        else if (value < 1.0) return 1.055 * Math.pow(value, 0.41666) - 0.055;
        else return Math.pow(value, 0.41666);
    };
    /**
   * Determines whether the specified colors are equals.
   * @param left - The first color to compare
   * @param right - The second color to compare
   * @returns True if the specified colors are equals, false otherwise
   */ Color.equals = function equals(left, right) {
        return MathUtil.equals(left._r, right._r) && MathUtil.equals(left._g, right._g) && MathUtil.equals(left._b, right._b) && MathUtil.equals(left._a, right._a);
    };
    /**
   * Determines the sum of two colors.
   * @param left - The first color to add
   * @param right - The second color to add
   * @param out - The sum of two colors
   * @returns The added color
   */ Color.add = function add(left, right, out) {
        out._r = left._r + right._r;
        out._g = left._g + right._g;
        out._b = left._b + right._b;
        out._a = left._a + right._a;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Determines the difference between two colors.
   * @param left - The first color to subtract
   * @param right - The second color to subtract
   * @param out - The difference between two colors
   */ Color.subtract = function subtract(left, right, out) {
        out._r = left._r - right._r;
        out._g = left._g - right._g;
        out._b = left._b - right._b;
        out._a = left._a - right._a;
        out._onValueChanged && out._onValueChanged();
    };
    /**
   * Scale a color by the given value.
   * @param left - The color to scale
   * @param s - The amount by which to scale the color
   * @param out - The scaled color
   * @returns The scaled color
   */ Color.scale = function scale(left, s, out) {
        out._r = left._r * s;
        out._g = left._g * s;
        out._b = left._b * s;
        out._a = left._a * s;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    /**
   * Performs a linear interpolation between two color.
   * @param start - The first color
   * @param end - The second color
   * @param t - The blend amount where 0 returns start and 1 end
   * @param out - The result of linear blending between two color
   */ Color.lerp = function lerp(start, end, t, out) {
        var _r = start._r, _g = start._g, _b = start._b, _a = start._a;
        out._r = _r + (end._r - _r) * t;
        out._g = _g + (end._g - _g) * t;
        out._b = _b + (end._b - _b) * t;
        out._a = _a + (end._a - _a) * t;
        out._onValueChanged && out._onValueChanged();
        return out;
    };
    _create_class(Color, [
        {
            key: "r",
            get: /**
   * The red component of the color, 0~1.
   */ function get() {
                return this._r;
            },
            set: function set(value) {
                this._r = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "g",
            get: /**
   * The green component of the color, 0~1.
   */ function get() {
                return this._g;
            },
            set: function set(value) {
                this._g = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "b",
            get: /**
   * The blue component of the color, 0~1.
   */ function get() {
                return this._b;
            },
            set: function set(value) {
                this._b = value;
                this._onValueChanged && this._onValueChanged();
            }
        },
        {
            key: "a",
            get: /**
   * The alpha component of the color, 0~1.
   */ function get() {
                return this._a;
            },
            set: function set(value) {
                this._a = value;
                this._onValueChanged && this._onValueChanged();
            }
        }
    ]);
    return Color;
}();

// A 2d rectangle defined by x and y position, width and height.
var Rect = /*#__PURE__*/ function() {
    function Rect(x, y, width, height) {
        if (x === void 0) x = 0;
        if (y === void 0) y = 0;
        if (width === void 0) width = 0;
        if (height === void 0) height = 0;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    var _proto = Rect.prototype;
    /**
   * Set the value of this rectangle.
   * @param x - The x coordinate of the rectangle
   * @param y - The y coordinate of the rectangle
   * @param width - The width of the rectangle, measured from the x position
   * @param height - The height of the rectangle, measured from the y position
   * @returns This rectangle
   */ _proto.set = function set(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        return this;
    };
    /**
   * Creates a clone of this rect.
   * @returns A clone of this rect
   */ _proto.clone = function clone() {
        return new Rect(this.x, this.y, this.width, this.height);
    };
    /**
   * Copy this rect from the specified rect.
   * @param source - The specified rect
   * @returns This rect
   */ _proto.copyFrom = function copyFrom(source) {
        this.x = source.x;
        this.y = source.y;
        this.width = source.width;
        this.height = source.height;
        return this;
    };
    return Rect;
}();

/**
 * Use SH3 to represent irradiance environment maps efficiently, allowing for interactive rendering of diffuse objects under distant illumination.
 * @remarks
 * https://graphics.stanford.edu/papers/envmap/envmap.pdf
 * http://www.ppsloan.org/publications/StupidSH36.pdf
 * https://google.github.io/filament/Filament.md.html#annex/sphericalharmonics
 */ var SphericalHarmonics3 = /*#__PURE__*/ function() {
    function SphericalHarmonics3() {
        /** The coefficients of SphericalHarmonics3. */ this.coefficients = new Float32Array(27);
    }
    var _proto = SphericalHarmonics3.prototype;
    /**
   * Add light to SphericalHarmonics3.
   * @param direction - Light direction
   * @param color - Light color
   * @param deltaSolidAngle - The delta solid angle of the light
   */ _proto.addLight = function addLight(direction, color, deltaSolidAngle) {
        /**
     * Implements `EvalSHBasis` from [Projection from Cube maps] in http://www.ppsloan.org/publications/StupidSH36.pdf.
     *
     * Basis constants
     * 0: Math.sqrt(1/(4 * Math.PI))
     *
     * 1: -Math.sqrt(3 / (4 * Math.PI))
     * 2: Math.sqrt(3 / (4 * Math.PI))
     * 3: -Math.sqrt(3 / (4 * Math.PI))
     *
     * 4: Math.sqrt(15 / (4 * Math.PI))
     * 5: -Math.sqrt(15 / (4 * Math.PI))
     * 6: Math.sqrt(5 / (16 * Math.PI))
     * 7: -Math.sqrt(15 / (4 * Math.PI)ï¼‰
     * 8: Math.sqrt(15 / (16 * Math.PI))
     */ color.scale(deltaSolidAngle);
        var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var r = color.r, g = color.g, b = color.b;
        var bv0 = 0.282095; // basis0 = 0.886227
        var bv1 = -0.488603 * y; // basis1 = -0.488603
        var bv2 = 0.488603 * z; // basis2 = 0.488603
        var bv3 = -0.488603 * x; // basis3 = -0.488603
        var bv4 = 1.092548 * (x * y); // basis4 = 1.092548
        var bv5 = -1.092548 * (y * z); // basis5 = -1.092548
        var bv6 = 0.315392 * (3 * z * z - 1); // basis6 = 0.315392
        var bv7 = -1.092548 * (x * z); // basis7 = -1.092548
        var bv8 = 0.546274 * (x * x - y * y); // basis8 = 0.546274
        coe[0] += r * bv0, coe[1] += g * bv0, coe[2] += b * bv0;
        coe[3] += r * bv1, coe[4] += g * bv1, coe[5] += b * bv1;
        coe[6] += r * bv2, coe[7] += g * bv2, coe[8] += b * bv2;
        coe[9] += r * bv3, coe[10] += g * bv3, coe[11] += b * bv3;
        coe[12] += r * bv4, coe[13] += g * bv4, coe[14] += b * bv4;
        coe[15] += r * bv5, coe[16] += g * bv5, coe[17] += b * bv5;
        coe[18] += r * bv6, coe[19] += g * bv6, coe[20] += b * bv6;
        coe[21] += r * bv7, coe[22] += g * bv7, coe[23] += b * bv7;
        coe[24] += r * bv8, coe[25] += g * bv8, coe[26] += b * bv8;
    };
    /**
   * Evaluates the color for the specified direction.
   * @param direction - Specified direction
   * @param out - Out color
   */ _proto.evaluate = function evaluate(direction, out) {
        /**
     * Equations based on data from: http://ppsloan.org/publications/StupidSH36.pdf
     *
     *
     * Basis constants
     * 0: Math.sqrt(1/(4 * Math.PI))
     *
     * 1: -Math.sqrt(3 / (4 * Math.PI))
     * 2: Math.sqrt(3 / (4 * Math.PI))
     * 3: -Math.sqrt(3 / (4 * Math.PI))
     *
     * 4: Math.sqrt(15 / (4 * Math.PI)ï¼‰
     * 5: -Math.sqrt(15 / (4 * Math.PI))
     * 6: Math.sqrt(5 / (16 * Math.PI)ï¼‰
     * 7: -Math.sqrt(15 / (4 * Math.PI)ï¼‰
     * 8: Math.sqrt(15 / (16 * Math.PI)ï¼‰
     *
     *
     * Convolution kernel
     * 0: Math.PI
     * 1: (2 * Math.PI) / 3
     * 2: Math.PI / 4
     */ var coe = this.coefficients;
        var x = direction._x, y = direction._y, z = direction._z;
        var bv0 = 0.886227; // kernel0 * basis0 = 0.886227
        var bv1 = -1.023327 * y; // kernel1 * basis1 = -1.023327
        var bv2 = 1.023327 * z; // kernel1 * basis2 = 1.023327
        var bv3 = -1.023327 * x; // kernel1 * basis3 = -1.023327
        var bv4 = 0.858086 * y * x; // kernel2 * basis4 = 0.858086
        var bv5 = -0.858086 * y * z; // kernel2 * basis5 = -0.858086
        var bv6 = 0.247708 * (3 * z * z - 1); // kernel2 * basis6 = 0.247708
        var bv7 = -0.858086 * z * x; // kernel2 * basis7 = -0.858086
        var bv8 = 0.429042 * (x * x - y * y); // kernel2 * basis8 = 0.429042
        // l0
        var r = coe[0] * bv0;
        var g = coe[1] * bv0;
        var b = coe[2] * bv0;
        // l1
        r += coe[3] * bv1 + coe[6] * bv2 + coe[9] * bv3;
        g += coe[4] * bv1 + coe[7] * bv2 + coe[10] * bv3;
        b += coe[5] * bv1 + coe[8] * bv2 + coe[11] * bv3;
        // l2
        r += coe[12] * bv4 + coe[15] * bv5 + coe[18] * bv6 + coe[21] * bv7 + coe[24] * bv8;
        g += coe[13] * bv4 + coe[16] * bv5 + coe[19] * bv6 + coe[22] * bv7 + coe[25] * bv8;
        b += coe[14] * bv4 + coe[17] * bv5 + coe[20] * bv6 + coe[23] * bv7 + coe[26] * bv8;
        out.set(r, g, b, 1.0);
        return out;
    };
    /**
   * Scale the coefficients.
   * @param s - The amount by which to scale the SphericalHarmonics3
   */ _proto.scale = function scale(s) {
        var src = this.coefficients;
        src[0] *= s, src[1] *= s, src[2] *= s;
        src[3] *= s, src[4] *= s, src[5] *= s;
        src[6] *= s, src[7] *= s, src[8] *= s;
        src[9] *= s, src[10] *= s, src[11] *= s;
        src[12] *= s, src[13] *= s, src[14] *= s;
        src[15] *= s, src[16] *= s, src[17] *= s;
        src[18] *= s, src[19] *= s, src[20] *= s;
        src[21] *= s, src[22] *= s, src[23] *= s;
        src[24] *= s, src[25] *= s, src[26] *= s;
    };
    /**
   * Creates a clone of this SphericalHarmonics3.
   * @returns A clone of this SphericalHarmonics3
   */ _proto.clone = function clone() {
        var sh = new SphericalHarmonics3();
        sh.copyFrom(this);
        return sh;
    };
    /**
   * Copy this SphericalHarmonics3 from the specified SphericalHarmonics3.
   * @param source - The specified SphericalHarmonics3
   * @returns This SphericalHarmonics3
   */ _proto.copyFrom = function copyFrom(source) {
        source.copyToArray(this.coefficients);
        return this;
    };
    /**
   * Copy the value of this spherical harmonics from an array.
   * @param array - The array
   * @param offset - The start offset of the array
   */ _proto.copyFromArray = function copyFromArray(array, offset) {
        if (offset === void 0) offset = 0;
        var s = this.coefficients;
        s[0] = array[offset], s[1] = array[1 + offset], s[2] = array[2 + offset];
        s[3] = array[3 + offset], s[4] = array[4 + offset], s[5] = array[5 + offset];
        s[6] = array[6 + offset], s[7] = array[7 + offset], s[8] = array[8 + offset];
        s[9] = array[9 + offset], s[10] = array[10 + offset], s[11] = array[11 + offset];
        s[12] = array[12 + offset], s[13] = array[13 + offset], s[14] = array[14 + offset];
        s[15] = array[15 + offset], s[16] = array[16 + offset], s[17] = array[17 + offset];
        s[18] = array[18 + offset], s[19] = array[19 + offset], s[20] = array[20 + offset];
        s[21] = array[21 + offset], s[22] = array[22 + offset], s[23] = array[23 + offset];
        s[24] = array[24 + offset], s[25] = array[25 + offset], s[26] = array[26 + offset];
    };
    /**
   * Copy the value of this spherical harmonics to an array.
   * @param out - The array
   * @param outOffset - The start offset of the array
   */ _proto.copyToArray = function copyToArray(out, outOffset) {
        if (outOffset === void 0) outOffset = 0;
        var s = this.coefficients;
        out[0 + outOffset] = s[0], out[1 + outOffset] = s[1], out[2 + outOffset] = s[2];
        out[3 + outOffset] = s[3], out[4 + outOffset] = s[4], out[5 + outOffset] = s[5];
        out[6 + outOffset] = s[6], out[7 + outOffset] = s[7], out[8 + outOffset] = s[8];
        out[9 + outOffset] = s[9], out[10 + outOffset] = s[10], out[11 + outOffset] = s[11];
        out[12 + outOffset] = s[12], out[13 + outOffset] = s[13], out[14 + outOffset] = s[14];
        out[15 + outOffset] = s[15], out[16 + outOffset] = s[16], out[17 + outOffset] = s[17];
        out[18 + outOffset] = s[18], out[19 + outOffset] = s[19], out[20 + outOffset] = s[20];
        out[21 + outOffset] = s[21], out[22 + outOffset] = s[22], out[23 + outOffset] = s[23];
        out[24 + outOffset] = s[24], out[25 + outOffset] = s[25], out[26 + outOffset] = s[26];
    };
    return SphericalHarmonics3;
}();

export { BoundingBox, BoundingFrustum, BoundingSphere, CollisionUtil, Color, ContainmentType, FrustumFace, MathUtil, Matrix, Matrix3x3, Plane, PlaneIntersectionType, Quaternion, Ray, Rect, SphericalHarmonics3, Vector2, Vector3, Vector4 };
//# sourceMappingURL=module.js.map
